// Text of project NewtPck2.¹ written on 1/22/01 at 8:00 AM// Beginning of text file Project Data// NewtPack (Newt Packages) (autopart) 3.5// Copyright 1995-2001 S. Weyer. All Rights Reserved Worldwideconstant kAutoCnst 		:= "NewtPack";constant kVersionNum 	:= "3.5";constant kVersionInt	:= 35;constant kBetaVersion 	:= "d";constant kDemoVersion	:= NIL;constant kFile4			:= "pack";constant kSlotSymbol 	:= 'protos;constant kConstantSymbol:= 'protoPackage;constant kPartDataSymbol:= 'protoPackage;DefineGlobalConstant('kOmitPkgSlots, '[		// added by NewtDevEnv	_parent, _MyParent_, existingPackage, pkgSymbol, sizeHint,	newtSymbol, noOpen, devSignature, requires, rFrame,	// standard (already copied/used elsewhere)	version, partData, copyProtected, compressed, dispatchOnly, // icon, autoClose,	copyright, installScript, removeScript, shortTitle,	parts,	]);// remaining?: DoNotInstall, deletionScript, labels, TapAction, iconPro, ...constant kPartHeaderSize := 32;// more in AutoInstallRemove/*getpkgrefinfo(getpkgref("LunaObj:TKnollSys", GetStores()[1])).parts[0]._importTable#6004DE19 [{name: |L-LibContent:Lunaware|, major: 1, minor: 0},            {name: |L-LibURL:Lunaware|, major: 1, minor: 0}]getpkgrefinfo(getpkgref("LunaObj:TKnollSys", GetStores()[1])).partsgetpkgrefinfo(getpkgref("LS1 Libs 2.1Bc306", GetStores()[1])).partslunit := getpkgrefinfo(objectpkgref(getglobals().|newtdevenv:tknollsys|.constants.lunaobj.protolocation));call func(parts, sym)begin	local i;	for i:=1 to Length(parts)-1	do if parts[i]._ExportTable and parts[i]._ExportTable[0].name = sym	then return i;end with (lunit.parts, '|L-LibContent:Lunaware|)setcontains(lunit.parts[10]._exporttable[0].objects, getglobals().|newtdevenv:tknollsys|.constants.lunaobj.protolocation)*/// End of text file Project Data// Beginning of text file AutoInstallRemove// AutoInstallRemove// standard for most Newt autopart plugins// except: NewtDraw, protNOS1, Sloup ??/* "Project Data" precedes this and defines:kAutoCnstkVersionNumkVersionIntkFile4kBetaVersionkSlotSymbolkConstantSymbolkPartDataSymbol*/if not IsGlobalConstant('kBuild20)then DefineGlobalConstant('kBuild20,	// '|Newton 2.0| or '|Newton 2.1|		BeginsWith(SprintObject(platformVersion.platformFile), "Newton"));if not IsGlobalConstant('kBuild1x)then DefineGlobalConstant('kBuild1x, not kBuild20);DefineGlobalConstant('kVersionString,	kVersionNum & kBetaVersion &	(if kDebugOn then $D) &	(if kProfileOn then $P) &	(if not kIgnoreNativeKeyword then $N) &	(if kDemoVersion then $X) &	(if kBuild20 then "-2"));DefineGlobalConstant('kVersion, kAutoCnst && kVersionString);Print(kFile4 & kVersionInt & kBetaVersion &	(if not kIgnoreNativeKeyword then $N	else if kBuild20	then if language='English		then $2		else Upcase(SPrintObject(language))[0]	)	& ".pkg");Print(kVersion && DateNTime(time()));if not IsGlobalConstant('kNewtSymbol) thenDefineGlobalConstant('kNewtSymbol, '|NewtDevEnv:TKnollSys|);constant kInstalled		:= 'installed;DefineGlobalConstant('kPkgSymbol,	Intern(kPackageName)); // kAppSymbol='autoPrint(kPkgSymbol);DeclareGlobalFn('DeclareGlobalFn,2);if kBuild1xthen begin	DeclareGlobalFn('GetGlobalVar,1);	DeclareGlobalFn('DefGlobalVar,2);	end;DefineGlobalConstant('kRegExpMin, 5*1440);	// number of mins to expire in (5 days)DefineGlobalConstant('kRegTag, "NG:SK"); 	// this is the app-specific ID for this "lock" DefineGlobalConstant('kRegIspec, {	type: 'index,	IndexPath: 'tag,	startKey: kRegTag,	endTest: func(e) NOT StrEqual(e.tag,kRegTag),});DefineGlobalConstant('kRegExpired, func()begin	//	true - demo has expired	//	nil - full demo or non-demo build.	local prefSoup := GetStores()[0]:GetSoup(ROM_systemSoupName);	local cursor :=		if kBuild20		then prefSoup:Query(kRegIspec)		else Query(prefSoup, kRegIspec);	local prefsEntry := cursor:entry();	prefsEntry and		StrEqual(prefsEntry.tag, kRegTag) and		EntryModTime(prefsEntry) + kRegExpMin < Time()end);if kDemoVersionthen SetPartFrameSlot('DoNotInstall, kRegExpired);DefineGlobalConstant('kEmptyGlobal, {	constants: {}, libraries: {}, protos: {},	tools: {}, views: {}, installed: {},});InstallScript := func(partFrame, removeFrame)if not (kDemoVersion and call kRegExpired with ())then begin	local gData;	if kBuild1x and Functions.GetGlobals exists	then begin		gData := GetGlobals().(kNewtSymbol);		if not gData		then GetGlobals().(EnsureInternal(kNewtSymbol)) := gData := EnsureInternal(kEmptyGlobal);		end	else begin		gData := GetGlobalVar(kNewtSymbol);		if not gData		then DefGlobalVar(EnsureInternal(kNewtSymbol), gData := EnsureInternal(kEmptyGlobal));		end;//Print(kVersion);	gData.(kSlotSymbol).(EnsureInternal(kConstantSymbol)) :=		if kpartDataSymbol		then partFrame.partData.(kpartDataSymbol)		else partFrame.partData;	gData.(kInstalled).(EnsureInternal(kPkgSymbol))		  := kVersion;	end;RemoveScript := func(removeFrame)begin	local gData :=		if kBuild1x and Functions.GetGlobals exists		then GetGlobals().(kNewtSymbol)		else GetGlobalVar(kNewtSymbol);	if gData	then begin		RemoveSlot(gData.(kSlotSymbol), kConstantSymbol);		RemoveSlot(gData.(kInstalled),  kPkgSymbol);		end;end;// End of text file AutoInstallRemove// Beginning of text file reloFix// reloFix// Copyright 1997-98 S. Weyer. All Rights Reserved Worldwide// this can be incorporated in various package exporting utilities// if acknowledge is provided in product description, as well as a link// to my Newton page://    http://members.bellatlantic.net/~sweyer/newton/index.htm/* interested developers:Dan Rowley <dan@newts.com>Robert Bruce <rbruce@tactile.com>Reinhold Schoeb <schoeba@str.daimler-benz.com>Brian K. Ogilvie  <BKOgilvie@aol.com>*//*!!!b. flags changes related to unit references.Here is an improved version of reloFix. It now handles multipart packages-- unless these are 2.x packages that have formal "relocation headers"(that's something I could fix in a future version since it's documentedthough messy -- no current plans).  If the package is copyProtected(unless overridden by a new param) or has 2.x relo headers, reloFix nowreturns NIL instead of modified pkg.  I documented/relaxed more assumptions.Other changes: you do not need to copy the original package (reloFix does this).You do not need to supply dummy offset or relo (since there are two methods now);you do not need to put nextFlush or reloFix in your app base -- see example.If you turn on debugging, you'll print some package and part info.It appears to correctly convert NewtWorks (a 2-part package);I fixed/reinstalled via Sloup.It rejects NetHopper (relo headers), Internet Enabler (relo headers, copy protected).suggested usage:obtain a package, e.g.,	pkg := GetPkgRef(pkgName, store);or	pkg := entry.package (from Extras target cursor)	newpkg := {		nextFlush:	kVBOFlush,		reloFix: 	kReloFix,		reloFixObj: kReloFixObj,		}:reloFix(pkg, nil);	// orig pkg; don't copy if copyProtected	returns copied&fixed pkg; otherwise nil		if pkg is copyProtected and you specified copyOk=nil		if pkg has 2.x "relocation headers"*/DeclareGlobalFn('ClearVBOCache,1);DefineGlobalConstant('kVBOFlush, 24*1024);	// every 24K or so? ( < 32K?) constant kWordSize  := 65536;constant kByteSize  := 256;constant kByteSize3 := 65536 * 256;DefineGlobalConstant('kExtractNum3, // extract 3 digit number (inline for speed?)func NATIVE (pkg, INT offset)ExtractByte(pkg, offset) 	* kWordSize +ExtractByte(pkg, offset+1) 	* kByteSize +ExtractByte(pkg, offset+2));DefineGlobalConstant('kReloFix,func NATIVE (pkg, copyOk)/*pkg: 	a package VBO (original ok; this copies if necessary)copyOk:	copy copyProtected packages?returns	modified pkg	NIL (if copyProtected & not copyOk, or unhandled 2.x relocation info)this fixes relocation info in multiple parts in a 1.x package,or a 2.x package (without relocation header info)*/begin	local INT numParts 	:= ExtractWord(pkg, 50); 	// assume # parts < 65536(kWordSize)	local INT flagByte1 := ExtractByte(pkg, 12);	local okrelo :=		Band(flagByte1, 0x04) = 0					// relocation header flag off?		and (copyOk or Band(flagByte1, 0x40) = 0);	// copy protected flag off?if kDebugOnthen begin	local INT i;	local s;	for i := 0 to 7	do s := s & Chr(ExtractByte(pkg,i));	Print("format:" && s);	// usually(only?): package0 or package1	Print("numParts:" && numParts);	if Band(flagByte1, 0x40)<>0 then Print("COPY PROTECTED!");	if Band(flagByte1, 0x04)<>0 then Print("RELOCATION INFO!");	endelse if not okrelo	// copyprotected or 2.x relo info not handled yetthen return NIL;	local INT offset, partNum, partIndex, obj, partOffset := ExtractWord(pkg, 46);	local ARRAY relo := Array(4, NIL);	// !!!b	local part, any;	local ARRAY imports := Array(numParts, '[]);	// collect all import declarations (if any)	foreach partNum,part in GetPkgRefInfo(pkg).parts	do  if isArray(part._ImportTable)		then imports[partNum] := any := Clone(part._ImportTable);	if any and okrelo	then begin		local exports := {}, epkg, entry, objs;		local INT i;		// collect all export objects		foreach epkg in GetPackages()		do  if epkg.store and IsPackageActive(epkg := GetPkgRef(epkg.title,epkg.store))			then foreach part in GetPkgRefInfo(epkg).parts				 do if isFrame(part) and isArray(part._ExportTable)					then foreach entry in part._ExportTable					 	 do exports.(entry.name) := entry.objects;	// assume unique?? version?		// replace import declarations with object refs		foreach part in imports		do  foreach i,entry in part			do  if objs := exports.(entry.name)				then part[i] := foreach obj in objs collect RefOf(obj);//Print(imports);		exports := nil; // not needed		end;	if okrelo	then begin // copy, setup//if kDebugOn then//Print("len:" && Length(pkg));		gc();		pkg := BinaryMunger(			GetDefaultStore():NewCompressedVBO('package, Length(pkg), kTextCompander,nil),0,nil,			pkg,0,nil);		ClearVBOCache(pkg);	// do this now		end;	for partNum := 0 to numParts-1	do begin		partIndex := 52 + (partNum * 32);	// each part header is 32 bytes long		// first object of each part is an array with 1 element (a part frame)		offset := partOffset + call kExtractNum3 with (pkg, partIndex+1);if kDebugOnthen beginPrint("part:" && partNum);Print("offset:" && offset);Print("part length:" &&			// uncompressed? size: 8-11	call kExtractNum3 with (pkg, partIndex+9)); Print("part type:" &&			// type: 12-15 (assumes null term in 16!)	ExtractCString(pkg, partIndex+12)); Print("part kind:" &&			// flags: 20-23'["protocol", "frames", "raw", "??"][BAND(ExtractByte(pkg,partIndex+23),0x3)]);end;		if partNum=0 and okrelo		then begin			// skip header,0,type(+12)			// assume [0] points to next object (+4) in pkg			// keep relo in array of 4 bytes -- "long" is too big; (words messy)			// this appears to be constant throughout entire normal package			obj := offset+16;			relo[0] := ExtractByte(pkg,offset+12);			relo[1] := ExtractByte(pkg,offset+13) - (obj div kWordSize);			obj := obj mod kWordSize;			relo[2] := ExtractByte(pkg,offset+14) - (obj div kByteSize);			relo[3] := ExtractByte(pkg,offset+15) - (obj mod kByteSize) - 1;  // for obj ptr//if kDebugOn then//begin Write("relo: "); Print(relo); end;			end;		if okrelo		then :reloFixObj(pkg, offset, relo, imports[partNum]);	// !!!b		end;	if okrelo	then begin		ClearVBOCache(pkg);	// one last time		pkg;		end;	//else NILend);DefineGlobalConstant('kReloFixObj,func NATIVE (pkg, INT offset, ARRAY relo, ARRAY imports)begin // fix objects within a part//Print(offset);	// DATA (0x40), ARRAY (0x41), FRAME (0x43)	local INT ctype := ExtractByte(pkg, offset+3);	local INT clen :=		if ctype = 0x40 // DATA		then 12 // only check type		else call kExtractNum3 with (pkg, offset);	// inline?	local INT i, obj, plen := Length(pkg);	// ,p	local INT byte0, byte1, byte2, byte3;	local INT relo0 := relo[0], relo1 := relo[1], relo2 := relo[2], relo3 := relo[3]; // cache	for i := offset+8 to offset+clen-4 by 4	do	if BAND(byte3 := ExtractByte(pkg, i+3), 0x3) = 1	// obj ptr?			//and ExtractByte(pkg,i) <> 0 // not already relocated? (assumes pkg < 17M)	  	then begin			byte0 := ExtractByte(pkg, i);			byte1 := ExtractByte(pkg, i+1);			byte2 := ExtractByte(pkg, i+2);			obj := (byte0 << 22) + (byte1 << 14) + (byte2 << 6) + (byte3 >> 2);//Print(i & $: && obj);			if obj >= plen or obj < 0			then begin//Print([byte0,byte1,byte2,byte3]);//Print([byte0-relo0,byte1-relo1,byte2-relo2,byte3-relo3]);				obj :=					(byte0 - relo0) * kByteSize3 +					(byte1 - relo1) * kWordSize +					(byte2 - relo2) * kByteSize +					(byte3 - relo3);				//obj := 0;				//for p := 0 to 3				//do obj := obj*kByteSize + ExtractByte(pkg,i+p) - relo[p];//if kDebugOn then//Print(i & $: && obj);				if obj < 0	// !!!b. a unit reference???				then if Length(imports)					then begin						local INT tableNum, uref :=							byte0 * kByteSize3 + byte1 * kWordSize +							byte2 * kByteSize  + byte3;//Print("unit ref?" && uref);						local objs, pos;						foreach tableNum,objs in imports						do if pos := SetContains(objs, uref)							then begin//Print("table:" && tableNum+2 & $; && "index:" && pos);								StuffLong(pkg, i,						       		((tableNum+2) << 14) + (pos << 2) + 0x3);						       	break uref := nil;						       	end;						if uref						then Print("import not found!");						end					else Print("no import table!?")					//obj negative so no recursive				else StuffLong(pkg, i, obj);				if i > nextFlush				then begin					ClearVBOCache(pkg);					nextFlush := nextFlush + kVBOFlush;					end;				obj := obj-1; 		// make ptr an offset				// any "normal" package appears to first save a (forward) pointer to an object				// and later the object itself; other references to obj might be back (ok).				// if there is a package that doesn't re-upload properly				// you could comment out the following test, though since it would (re)check				// validity of every pointer in an array or frame, it could slow things down						//if obj > offset then		// needs fixing only if later in package? assumes first ref is forward				if obj > 0 and obj < plen	// !!!a				then :reloFixObj(pkg, obj, relo, imports);				end;			end;		//else if Band(byte3,0x3)=3		//then Print(i & ": magic" && ExtractLong(pkg,i));end);// End of text file reloFix// Beginning of text file Final Project Dataif kBuild20then begin	DeclareGlobalFn('Query,2);	// so we can use same names	//DefineGlobalConstant('kGetUserConfigFunc, kGetUserConfigDeprecatedFunc);	//DefineGlobalConstant('kGetDefaultStoreFunc, kGetDefaultStoreDeprecatedFunc);	endelse begin	DeclareGlobalFn('AddDeferredCall,2);	DeclareGlobalFn('GetGlobalFn, 1);	DeclareGlobalFn('GetGlobalVar,1);	DeclareGlobalFn('DefGlobalVar,2);	DeclareGlobalFn('LFetch,5);	DeclareGlobalFn('GetDefaultStore,0);	DeclareGlobalFn('IsString,1);	DeclareGlobalFn('GetUserConfig,1);	DeclareGlobalFn('DoProgress,3);	DeclareGlobalFn('IsEntryAlias, 1);	DeclareGlobalFn('ResolveEntryAlias, 1);	DeclareGlobalFn('EntryRemoveFromSoupXmit, 2);	DeclareGlobalFn('IsInteger, 1);	DefineGlobalConstant('kTextCompander,	"TLZStoreCompander");	end;DeclareGlobalFn('ClearVBOCache,1);DeclareGlobalFn('GetPkgRef,2);DeclareGlobalFn('BackupPackage,2);// !!!a. defined in reloFix//DefineGlobalConstant('kVBOFlush, 24*1024);	// every 24K or so? ( < 32K?)DefineGlobalConstant('pkgPad, if kBuild20 then 4 else 8);constant cr := "\n";constant kCopyright	:= "© 1995-2001,"; // used also for dev copyrightconstant kCopyAuthor:= "S. Weyer                                        ";DefineGlobalConstant('kCopyTool, kVersion && kCopyright && kCopyAuthor);constant kPkgSoupName	:= "TEMPPKG:TKnollSys";constant kSegSize		:= 4096;constant kTooBig		:= "pkgOffset too big";constant kFakeParent	:= '_MyParent_;partData := {}; // set protoPackage, protoProgress in afterScriptconstant kSymbolType := '|?$_Symbol_$?|;constant eArray := '[];DefineGlobalConstant('eFrame, {});DefineGlobalConstant('kSymCompare, func NATIVE (ARRAY a1, ARRAY a2) // [hi,lo,str,sym]  // #5begin	local INT hi := a1[0]-a2[0], lo;	if hi=0	then if (lo := a1[1]-a2[1])=0		then if kBuild20			then StrCompare(a1[2],a2[2])			else call Functions.StrCompare with (a1[2],a2[2])		else lo	else hi;end);DefineGlobalConstant('kFindArray, func NATIVE (ARRAY objs, ARRAY aobj, nocheck) // #6begin	local INT i, j, alen := Length(aobj);	local ARRAY obj1;	local aclass := ClassOf(aobj), found;	for i:=0 to Length(objs)-1	do if nocheck or IsArray(objs[i]) then		begin			obj1 := objs[i];			if alen = Length(obj1) and				(nocheck or (isReadonly(obj1) and aclass = ClassOf(obj1)))			then for j:=0 to (found := alen-1)				do if obj1[j]<>aobj[j] then break found := NIL;			if found then return i;		end;end);DefineGlobalConstant('kStuffNum, func NATIVE (data, INT offset, INT val, INT len, INT shoff)begin	// stuff 1-4 bytes as a (big) number, possibly shifted	local INT i, sh := shoff;	for i := offset+len-1 to offset by -1	do begin		StuffByte(data, i, if sh < 0 then val << -sh else val >> sh);		sh := sh + 8;		end;end);DefineGlobalConstant('kExtractNum, func(data, INT offset, INT len, INT shoff)begin	// extract 1-4 bytes as a number	// for len=4, use ExtractLong for "small" nums	local INT i, val := 0, sh := shoff, byte;	for i := len-1 to 0 by -1	do begin		byte := ExtractByte(data, offset+i);		val := val + (if sh < 0 then byte >> -sh else byte << sh);		sh := sh + 8;		end;	val;end);DefineGlobalConstant('kSaveOffset, func NATIVE (ARRAY objects, offsets, obj, INT offset, INT pos)begin	local INT last := Length(objects)-1, esize := 2;	local stuffFunc :=		if kBuild20 or Functions.IsVBO exists		then begin			esize := 4;			GetGlobalFn('StuffLong);			end		else Functions.StuffWord;	if pos < 0	then if offsets		then begin			if objects[last] // check last element			then objects[last] := objects[pos := objects[last]] // remove from chain			else begin				pos := last;				SetLength(objects, pos+2);				SetLength(offsets, (pos+1)*esize);				end;			objects[pos] := obj;			call stuffFunc with (offsets, pos*esize, offset div pkgPad);			//call kStuffNum with (offsets, pos*esize, offset div pkgPad, esize, 0);			pos; // for later remove			end		else begin // framemap			SetClass(obj, offset);			AddArraySlot(objects,obj);			NIL; //don't remove.   (or last?)			end	else begin // frame map		if pos <= 65535		then begin			objects[pos] := objects[last]; // add previous front			objects[last] := pos; // add to front of chain			end;//Print([offset,obj]);		if kBuild20		then offsets := MakeBinary(esize, '_pkgOffset_)		else begin			SetClass(offsets := Clone(""), '_pkgOffset_);			SetLength(offsets, esize);			end;		call stuffFunc with (offsets, 0, offset div pkgPad);		ReplaceObject(obj, offsets);		end;end);DefineGlobalConstant('kGetOffset, func NATIVE (offsets, INT pos)begin	local INT esize := if kBuild20 or Functions.IsVBO exists then 4 else 2;	pkgPad * call kExtractNum with (offsets, pos*esize, esize, 0);	// pkgPad * (ExtractByte(offsets, (pos*2)) * 256 + ExtractByte(offsets, (pos*2)+1));end);DefineGlobalConstant('orda, Ord($a));DefineGlobalConstant('ordz, Ord($z));DefineGlobalConstant('kSymHash, func NATIVE (data, INT offset, str, sym)begin	local INT i, ch, tot:=0;	local OrdFn := if kBuild1x then Functions.Ord; //GetGlobalFn('Ord) else 	for i:=0 to if kBuild20 then StrLen(str)-1 else call Functions.StrLen with(str)-1	do begin		ch := if kBuild20 then Ord(str[i]) else call OrdFn with(str[i]);		tot := tot + if orda <= ch and ch <= ordz then ch-32 else ch;		end;	local INT lo := 0x79B9 * tot;	local INT hi := (0x9E37 * tot) + (lo >> 16);	if data	then begin		StuffWord(data, offset,   hi);		StuffWord(data, offset+2, lo);		end	else begin // assume array		local ARRAY dd :=			if kBuild20			then Array(if sym then 4 else 2, NIL)			else call Functions.Array with (if sym then 4 else 2, NIL);		dd[offset]   := Band(hi,0xFFFF);		dd[offset+1] := Band(lo,0xFFFF);		if sym		then begin // for sorting			dd[offset+2] := str;			dd[offset+3] := sym;			end;		dd;		end;end);DefineGlobalConstant('kFormInstallScript, func(partFrame) // InstallScript for a normal (part) packagebegin//Print("installing" && partFrame.app);	if Extras exists and isArray(Extras) and		//Functions.ArrayPos exists and		// !!!d		(if kBuild20			then LSearch (Extras, partFrame, 0, '|=|, 'app)			// !!!d			else ArrayPos(Extras, partFrame.app, 0, func(a,e) a=e.app))	then GetRoot():Notify(kNotifyAlert,		EnsureInternal("Extras"),		"Duplicate App" && partFrame.app)	else if HasSlot(partFrame,'devInstallScript)	then begin		partFrame:devInstallScript(partFrame);		partFrame.devInstallScript := NIL;		end;	partFrame.InstallScript := NIL;//Print("end install");end);DefineGlobalConstant('kFormRemoveScript, func(partFrame)	partFrame:?devRemoveScript(partFrame));DefineGlobalConstant('kAutoInstallScript, func(partFrame)begin	local rFrame := EnsureInternal({removeScript: partFrame.devRemoveScript});	partFrame:devInstallScript(partFrame, rFrame);	rFrame;end);DefineGlobalConstant('kDeletionScript, func() nil);DefineGlobalConstant('kExportEntry, func(obj) // !!!a. used by StuffVPUMif kBuild20then begin	local pkgRef := ObjectPkgRef(obj), part, exportTable;	if isPackage(pkgRef) // !!!c	then //LFetch(GetPkgRefInfo(pkgRef).parts,obj,0, '|=|,[pathExpr: '_ExportTable, 0, 'objects])		foreach part in GetPkgRefInfo(pkgRef).parts		do  if isFrame(part) and	// !!!d				isArray(exportTable := part._ExportTable) and				SetContains(exportTable[0].objects, obj)			then return exportTable[0];	// {name:..., objects:} assume only 1 item in array?	NIL;	end);if kDebugOnthen DefineGlobalConstant('kArrayEqual, func (ARRAY a1, ARRAY a2)if Length(a1)=Length(a2)	and Classof(a1)=Classof(a2)then begin	local INT i;	for i := 0 to Length(a1)-1	do if a1[i] <> a2[i] then return NIL;	return TRUE;	end);if kDebugOnthen DefineGlobalConstant('kPrintObj, func(off,obj,len)	begin		Write(off & ": [" & len & "] "); Print(obj);	end);// End of text file Final Project Data// Beginning of file AnEmptyLayout_v74_0 :=    {viewBounds: {left: 40, top: 16, right: 152, bottom: 72},     viewClass: 74 /* clView */    };constant |layout_AnEmptyLayout| := _v74_0;// End of file AnEmptyLayout// Beginning of file protoProgressprotoProgress :=    {viewBounds: {left: 6, top: 155, right: -6, bottom: 223},     viewSetupDoneScript:       func()       begin       	closebox:hide();       	AddDeferredAction(func(view) // just 1.x       		if Visible(view) then view.closebox:show(), [self]);       end,     viewJustify: 48,     ReorientToScreen:       func()       begin //@588 //ROM_DefRotateFunc       	:SyncView();       	:RedoChildren();       end,     setStatus:       func(type, options) // same call as DoProgress       if Visible(self)       then begin       	local val;       	if not StrFilled(val := statusText.text) and val	// only 1st time (assume unchanging)       	then SetValue(statusText, 'text, val);              	if val := options.gauge	// %       	then SetValue(gauge, 'viewValue, max(min(val,100),0));              	if val := options.titleText       	then SetValue(titleText, 'text, val);              /*	local elapsed := if startTime       		then TimeInSeconds() - startTime       		else begin       			startTime := TimeInSeconds();       			0;       			end;       	local secs := elapsed mod 60;       	SetValue(elapsedTime, 'text,       		(elapsed div 60) & (if secs < 10 then ":0" else $:) & secs);       */       	RefreshViews();       	end              else begin       	self.curOptions := options;       	self:open();       	end;,     _proto: @179 /* protoFloater */    };appIcon :=    {viewBounds: {left: 0, top: 0, right: 31, bottom: 29},     viewSetupFormScript:       func()       if curOptions.icon       then begin       	icon := curOptions.icon;       	curOptions.icon := nil;	// avoid reshowing       	end,     icon: nil,     viewFlags: 1,     viewClass: 76 /* clPictureView */    };AddStepForm(protoProgress, appIcon);statusText :=    {text: "",     viewBounds: {top: 2, left: 33, right: -1, bottom: 26},     viewJustify: 48,     viewSetupFormScript:       func()       if StrFilled(curOptions.statusText)       then text := curOptions.statusText,     _proto: @218 /* protoStaticText */    };AddStepForm(protoProgress, statusText);StepDeclare(protoProgress, statusText, 'statusText);gauge :=    {viewBounds: {top: 29, left: 1, right: -1, bottom: 43},     viewSetupFormScript:       func()       begin       	local val := curOptions.gauge;       	if val       	then begin       		viewValue := val;	// usually 0       		minValue  := 0;       		maxValue  := 100;       		end       	else viewFlags := 0;       end,     viewValue: 50,     viewJustify: 48,     _proto: @182 /* protoGauge */    };AddStepForm(protoProgress, gauge);StepDeclare(protoProgress, gauge, 'gauge);titleText :=    {text: "",     viewBounds: {top: -25, left: 1, right: -1, bottom: -1},     viewJustify: 176,     viewSetupFormScript:       func()       if StrFilled(curOptions.titleText)       then text := curOptions.titleText,     _proto: @218 /* protoStaticText */    };AddStepForm(protoProgress, titleText);StepDeclare(protoProgress, titleText, 'titleText);closebox := {_proto: @166 /* protoCloseBox */};AddStepForm(protoProgress, closebox);StepDeclare(protoProgress, closebox, 'closebox);constant |layout_protoProgress| := protoProgress;// End of file protoProgress// Beginning of file protoPackageprotoPackage :=    {     printHexBin:       func(data, offset, len, hub)       begin       	// print Hex, Unicode or Binary format       	local s := if hub='h then "0x" else if hub='u then "\u" else "";       	local digits :=       		if hub='b       		then [       			"0000", //0       			"0001", //1       			"0010", //2       			"0011", //3       			"0100", //4       			"0101", //5       			"0110", //6       			"0111", //7       			"1000", //8       			"1001", //9       			"1010", //A       			"1011", //B       			"1100", //C       			"1101", //D       			"1110", //E       			"1111", //F       			]       		else "0123456789ABCDEF";              	local num := if isBinary(data) then NIL else data;       	local i, lim := len*8 - 4;       	for i:=0 to lim by 4       	do s := s & digits[       		Band(if num       				then num >> (lim-i)       				else ExtractByte(data, offset + (i div 8)) >> ((i+4) mod 8),       			0xF)];       	s;       end,     FrameDiff:       func(f1,f2,diff)       if length(f1)=length(f2)       then begin       	local slot,val;       	local slots1 := foreach slot,val in f1 collect slot;       	local slots2 := foreach slot,val in f2 collect slot;       	if (val := if classof(slots1) <> classof(slots2) then 'class)       		or val := :ArrayDiff(slots1,slots2,[])       	then return SetAdd(diff,['map, val],nil);              	foreach slot in slots1       	do if :ObjDiff(f1,f2,slot,diff)       		then return SetAdd(diff,slot,nil);       	//NIL;       	end       else SetAdd(diff,'len,nil),     ObjDiff:       func(obj1,obj2,path,diff)       begin       	local v1 := obj1, v2 := obj2;       	if path //and length(path)>0       	then begin       		v1 := obj1.(path);       		v2 := obj2.(path);       		end;              	if v1=v2 then return NIL;              	if classof(v1)<>classof(v2)       		or isImmediate(v1) or isImmediate(v2)       		or length(v1)<>length(v2)       	then return diff;              	if isInstance(v1,'string) // IsString(v1)       	then if StrEqual(v1,v2) // make case sensitive?? **       		then NIL       		else diff       	else if isFrame(v1)       	then :FrameDiff(v1,v2,diff)              	else if isArray(v1)       	then :ArrayDiff(v1,v2,diff)              	else if isBinary(v1)       	then :BinDiff(v1,v2,diff)              	else :Notify(3, "unrecognized type for", [v1,v2]);       end,     segOffset: nil,     setOffset:       func NATIVE (INT pkgOffset, alloc)       if kBuild1x and cursor       then begin       	local INT segNum := pkgOffset div kSegSize;       	local INT segLen := Length(segments), i, segBeg;       	segBegin := segBeg := segNum * kSegSize;       	segOffset := pkgOffset - segBeg;       	local ARRAY segs := segments;       	if alloc and segEntry       	then call Functions.EntryChange with(segEntry);       	if segNum < segLen       	then begin       		segment := segEntry := NIL;       		segEntry := cursor:GoToKey(segs[segNum]);       		segment := segEntry.packageEntry;       		end       	else if alloc       	then for i := segLen to segNum       		do begin       if kDebugOn then Print("seg" & i);       			segment := segEntry := NIL;       			segment := SetLength(clone("\u"), kSegSize);       			SetClass(segment, 'packageEntry);       			segEntry := cursor.soup:Add({packageEntry: segment});       			AddArraySlot(segs, call Functions.EntryUniqueId with (segEntry));       			segment;       			end       	else GetRoot():Notify(kNotifyAlert,       			EnsureInternal(kTooBig), SPrintObject(pkgOffset));       	end              else if alloc // small package/VBO       then if segment       	then begin       		SetLength(segment, segSize := ((pkgOffset div kSegSize)+1) * kSegSize); // pkgOffset=segOffset       		if (kBuild20 or nextFlush) and segSize >= nextFlush       		then begin       			ClearVBOCache(segment);       			ClearVBOCache(pkgOffs);       			nextFlush := nextFlush + kVBOFlush;       			end;       		end       	else begin // 1st time       		if kBuild20       		then segment := MakeBinary(kSegSize, 'packageEntry)       		else begin       			segment := SetLength(Clone("\u"), kSegSize);       			SetClass(segment, 'packageEntry);       			end;       		segBegin := 0;       		segOffset := pkgOffset;       		end              else if segBegin <= pkgOffset and pkgOffset < segSize       then segOffset := pkgOffset              else GetRoot():Notify(kNotifyAlert,       			EnsureInternal(kTooBig), SPrintObject(pkgOffset)),     smallPackage: nil,     extractChunk:       func(offset)       begin       	local obj, origOffset := offset, pos := SetContains(pkgOffs,offset);       	if pos       	then return pkgObjs[pos];       		/* begin       		obj := pkgObjs[pos];       		if isArray(obj) and isInstance(classof(obj),'int)       		then begin write("shared framemap "); print(obj); end;       		return obj; //pkgObjs[pos];       		end; */              //progress:?update(offset); //,nil,true);              	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,NIL);       	local ctype := ExtractByte(segment, segOffset+3);       	local len := :extractNum(segment, segOffset, 3, 0);       	local arg := :extractVPUM(offset:=offset+8), val;              	if ctype = 0x40			// DATA       	then begin       		obj := if arg=kSymbolType       			then begin       				if (segOffset := offset+4 - segBegin) >= segSize       					or offset < segBegin       				then :setOffset(offset+4,NIL);       				local shash := [:extractNum(segment,segOffset,  2,0),       									:extractNum(segment,segOffset+2,2,0)];       				val := :ExtractCString2(offset+8, len-16);              				local hilo := call kSymHash with(nil,0,val,nil);       				if not call kArrayEqual with (shash, hilo)       				then Print(["*****", val, shash, hilo]);              				Intern(val);       				end       			else if keepValue then :ExtractBytes2(offset+4, len-12, arg);       //Print(if arg='symbol or arg='string then obj else "<"&arg&":"&(len-12)&">");              		call kPrintObj with (origOffset,obj,len);              		:shareObj(obj,origOffset);       		obj;       		end              	else if ctype = 0x41	// ARRAY       	then begin       //if not IsInstance(arg,'symbol) then print(:printhexbin(segment,segOffset,4,'H)); // type as binary       		local i, alen := (len div 4) - 3;       //Print("["&alen&"]");       		if arg='Array and alen=0       		then eArray       		else begin       			obj := Array(alen,nil);       			if arg       			then SetClass(obj,arg);       			:shareObj(obj,origOffset);       			for i:= 0 to alen-1       			do obj[i] := :extractVPUM(offset:=offset+4);       //if isInstance(arg,'int) then begin write(arg&""); Print(obj); end;       if kDebugOn       then call kPrintObj with (origOffset,obj,len);       			obj;       			end;       		end              	else //if ctype = 0x43 then // FRAME       		begin       //Print(arg);       		if Length(arg)=0       		then eFrame       		else begin       			local slot, slot2;       			obj := {};       			:shareObj(obj,origOffset);       			foreach slot in arg       			do if isArray(slot)       			then begin       Print("??? nested frame map at" && origOffset); // assume no more than 1 level of nesting ***       				foreach slot2 in slot       				do if slot2       				then begin       					val := :extractVPUM(offset:=offset+4);       					if keepValue then obj.(slot2) := val;       					end;       				end       			else if slot       			then begin       					val := :extractVPUM(offset:=offset+4);       					if keepValue then obj.(slot) := val;       					end;       if kDebugOn       then call kPrintObj with (origOffset,obj,len);       			obj;       			end;       		end;       	/* else 					// ERROR       		:Notify(3,"unrecognized chunk",ctype);*/       end,     stuffPartHeader:       func(INT offset, ARRAY parts, devCopyright, packageName) // called by StuffPackage       begin       	// hoff = start of variable length area (after all part headers)       	local INT hoff := offset + (kPartHeaderSize * Length(parts)), i, strOff := 0, len;       	local part, t;              	// write copyright and packagename first (pointers already written in packageHeader)       	len := (StrLen(devCopyright)+1) * 2; // \u       	BinaryMunger(segment, hoff+strOff, len, devCopyright, 0, len);       	strOff := strOff+len;              	len := (StrLen(packageName)+1) * 2; // \u       	BinaryMunger(segment, hoff+strOff, len, packageName, 0, len);       	strOff := strOff+len;              	//StuffCString(segment, hoff+strOff, "form");       	//strOff := strOff+4;	// overwrite null              	//len := StrLen(kCopyTool)+1; // +null omitted       	StuffCString(segment, hoff+strOff, kCopyTool);       	strOff := strOff + StrLen(kCopyTool) + 1;		// !!!d include null              	for i:=0 to Length(parts)-1       	do begin       		part := parts[i];              		//StuffLong	(segment, offset+ 0, 0); 	// offset to beginning of part -- see stuffPackage       		//StuffLong	(segment, offset+ 4, 0); 	// compressed length -- see stuffPackage              		//StuffLong	(segment, offset+ 8, 0); 	// uncompressed length -- see stuffPackage       		StuffCString(segment, offset+12, part.type);	// form, book, auto, ***              		StuffLong	(segment, offset+16, 0);	// reserved. should be 0       		StuffLong	(segment, offset+20, if (t := part.flags) then t else 0x00000081);              		if ((t := part.notification) or t := part.type) and       			(if kBuild20 then IsString(t) else isInstance(t, 'string)) and       			(len := StrLen(t)) > 0       		then begin       			StuffCString(segment, hoff+strOff, t);	// ascii-null       			StuffWord	(segment, offset+24, strOff);       			StuffWord	(segment, offset+26, len);       			strOff := strOff+len;       			end       		else StuffLong(segment, offset+24, 0);              		if (t := part.compressor) and       			(if kBuild20 then IsString(t) else isInstance(t, 'string)) and       			(len := StrLen(t)) > 0       		then begin       			StuffCString(segment, hoff+strOff, t);	// ascii-null       			StuffWord	(segment, offset+28, strOff);       			StuffWord	(segment, offset+30, len);       			strOff := strOff+len;       			end       		else StuffLong(segment, offset+28, 0);              		offset := offset + kPartHeaderSize;       		end;              	// start of data for 1st part after variable length area       	nextChunk := ((hoff + strOff + pkgPad - 1) div pkgPad) * pkgPad; // round to first obj boundary       end,     nextChunk: nil,     segment: nil,     extractPackage:       func(reset)       begin       	if reset // after savePackage       	then begin       		pkgObjs 	:= [];       		pkgOffs 	:= [];       		pkgAObjs  := []; // ***       		pkgAOffs  := [];       		end;              	:setOffset(0,NIL);       	local pkgFrame := {};       	local offset := :printPkgEntries(       		segment,0, "PACKAGE HEADER", pkgFrame,'[       		[char, verify_text,		//   0 'package0' - lets us know this is a package!       			8, "package0"],	       		[char, unknown_text,		//   8 'xxxx' or ' no ' or 'none' - unknown usage       			4, "xxxx",],       		[long, package_flags],	//  12 a combination of the PF_ flags #define'd above       		[long, pkg_version],		//  16 version # of package from NTK dialog       		[int,  zeroPad, nil, 0],//  20 0       		[int,  dcopyright_len],	//  22 length of devel copyright text       		[int,  dcopyright_len2,	//  24 (repeated)       			nil, dcopyright_len],       		[int,  packname_len],	//  26 length of name of package       		[long, package_len],		//  28 length of entire package       		[long, create_time],		//  32 [Mac] creation time/date of package (secs since 1/1/04)       		[time, modif_time],		//  36 [Newton] modification time       		[long, zeroPad, nil, 0],//  40 0       		[long, hdr_length],		//  44 length of package header       		[long, num_parts,			//  48 number of parts in the package       			nil, 1],       		]);              	pkgFrame.real_part_len := pkgFrame.package_len - pkgFrame.hdr_length;              // assume 1 part ***       	offset := :printPkgEntries(       		segment,offset, "PART HEADER", pkgFrame, '[       			[long, part_offset,	//  52 offset of start of part data (within the package)       				nil, 0],	       			[long, part_length,	//  56 length of part       				nil, real_part_len],		       			[long, part_length2,	//  60 length of part       				nil, part_length],       			[char, part_type, 4,	//  64 'form', 'book', 'auto', etc.       				"form"],       			[long, zeroPad,		//  68 0       				nil, 0],       			[long, val81, nil,	//  72 0x00000081       					0x00000081],       			[int,  part_sym_off],//  76 offset from start of text section of the "part symbol"       			[int,  part_sym_len,	//  78 length of "part symbol"       				nil, 4],       			[long, zeroPad,		//  80 0       				nil, 0],       			]);              	offset := :printPkgEntries(       		segment,offset, "STRING SECTION", pkgFrame, '[       			[uchar,dev_copyright,       			   dcopyright_len],	//  84 copyright string from NTK project window.  Null terminated.       			[uchar,packname,       			   packname_len],		// name of package as seen in "Remove Software"       			[char, part_symbol,       			   part_sym_len, part_type],	// 'form' or 'Monaco' or freeform text - seemingly not used.       			[char,NTK_copyright],// 'Newtonª Toolkit Package © 1992-1994, Apple Computer, Inc.'       			]);              	local hlen := pkgFrame.hdr_length;       	pkgFrame := {}; // recycle       	pkgFrame.part1 := :extractChunk(hlen);       	pkgFrame;       end,     extractString:       func(data, offset, len, cl, step) // used only by printPkgEntry       begin       	// return string or unicode string,       	// either with length specified or null terminated       	// for step=1, len=nil  -- use ExtractCString       	// for step=2, len<>nil -- use ExtractBytes       	local i := offset, ch, null:=chr(0), s := "";       	local offlen := if len then offset+len;       	while not offlen or i < offlen       	do begin       		ch := if step=1       			then ExtractChar(data, i);       			else ExtractUniChar(data, i);       		if ch=null then break;               s := s&ch;               i := i+step;       		end;       	s;       end,     firstChunk: nil,     stuffChunk:       func (INT offset, obj)       begin       	local pos, val, arg, sym, origObj := obj; // esp. for entryAliases, deferredPackageObject       	if (kBuild20 or nos20) and not isFrame(obj) and IsEntryAlias(obj) // !!!c       	then begin       		val := ResolveEntryAlias(obj);       		obj := if (sym := val.appSymbol)       			then Perform(GetRoot().(sym), val.appMsg, [val.data])       			else val.data;       		EntryRemoveFromSoupXmit(val, nil);       		end;              	local cl := if isFrame(obj) then 'frame else ClassOf(obj);       	if //isArray(obj) and       		cl='deferredPackageObject       	then begin       		local fn := obj[0], args := obj[1];       		if not isArray(args) then args := [args];       		obj := if (if kBuild20 then IsSymbol(fn) else isInstance(fn,'symbol))       			then Perform(evalView,fn,args)       			else Apply(fn,args);       		cl := if isFrame(obj) then 'frame else ClassOf(obj);       		end;              	if cl = '_pkgOffset_ // and isBinary(obj)       	then return call kGetOffset with (obj,0);              	local ro := isReadonly(obj);       	if isArray(obj)       	then begin       		if not ro and	// a computed framemap?       			(if kBuild20 then IsInteger(cl) else isInstance(cl,'int))       		then (if pos := call kFindArray with (pkgAObjs,obj,true) // frame map       				then return ClassOf(pkgAObjs[pos])) //call kGetOffset with (pkgAOffs,pos))       		else if not (pos := SetContains(pkgObjs,obj)) // array (probably readonly)       					and ro and (cl='pathExpr or if kBuild20 then IsInteger(cl) else isInstance(cl,'int))       		then pos := call kFindArray with (pkgObjs,obj,nil);       		end              	else pos := SetContains(pkgObjs,obj); // other (readonly) obj       	if pos       	then return call kGetOffset with (pkgOffs,pos);                     	local INT origOffset := offset, ctype, len, long1 := 0;       	local slot, frameMap;              // INIT HEADER INFO       	if isFrame(obj) 		// FRAME       	then begin       		if HasSlot(obj,kFakeParent)       		then begin       			RemoveSlot(obj,kFakeParent);       			RemoveSlot(obj,'_parent);       			end;              		ctype := 0x43;       		len := Length(obj);       		local sortArg := len>20 and not HasSlot(obj,'_nextArgFrame);       		arg :=       			foreach slot,val in obj  // frame map w/o initial NIL       			collect if slot and sortArg       				then call kSymHash with (nil, 0, Stringer([slot]), slot)       				else slot;              		slot := if HasSlot(obj,'_proto)       			then 4       			else 0;              		if sortArg       		then begin       //if kDebugOn then begin Write("sort before: "); Print(arg); end;       			Sort(arg, kSymCompare, nil);       			for pos:=0 to len-1 // fixup       			do arg[pos] := arg[pos][3];       //if kDebugOn then begin Write("sort after: "); Print(arg); end;       			slot := slot+1;       			end;              		SetClass(arg,slot);       		len := 4 * (3+len); // frame entry len       		end              	else if isArray(obj)	// ARRAY       	then begin       		ctype := 0x41;       		len := 4 * (3 + Length(obj));       		if (if kBuild20 then IsInteger(cl) else isInstance(cl,'int)) and       			(len=12 or obj[0]) and not ro // our framemap?       		then frameMap := len := len+4;       		if origOffset <> firstChunk       		then arg := cl       		else if pkgPad=4 // type=nil       		then long1 := 1; // only in very 1st array!       		end              	else begin 				// SYMBOL, DATA       		ctype := 0x40;       		if (if kBuild20 then IsSymbol(obj) else isInstance(obj,'symbol))       		then begin       			arg := kSymbolType;       			sym := val := Stringer([obj]); // SPrintObject bug for symbols over 63 chars!       			len := 17 + StrLen(val); // + hash(4), null(1)       			end       		else begin       			arg := cl;       			len := 12 + Length(obj);       			//if (kBuild20 or nos20) and IsVbo(obj) then ro := true;       			end;       		end;              	//local currentPath := progress.currentPath.text;       //if ctype<>0x40 then Progress:?update(offset); //, nil, true);       if kDebugOn       then call kPrintObj with (offset, obj, len);              // WRITE CHUNK HEADER INFO       	// update offset ptr for nextChunk, rounded up to "4- or 8-byte" boundary       	nextChunk := nextChunk + ((len+pkgPad-1) div pkgPad) * pkgPad;              	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,TRUE);              	call kStuffNum with (segment, segOffset, len, 3, 0);       	StuffByte(segment, segOffset+3, ctype);              	offset := offset+4;       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,TRUE);       	StuffLong(segment, segOffset, long1);              	:stuffVPUM(offset:=offset+4, arg);              // WRITE OBJECT       	if ctype = 0x40			// DATA       	then if arg=kSymbolType       		then begin       			// keep symbol entry in pkgObjs       			call kSaveOffset with (pkgObjs,  pkgOffs,  origObj, origOffset, -1);       			offset := offset+4;         			if (segOffset := offset - segBegin) >= segSize       				or offset < segBegin       			then :setOffset(offset,TRUE);       			call kSymHash with (segment, segOffset, val, nil);       			:StuffCString2(offset+4, val, 0, -1);       			pos := NIL; // don't remove       			end       		else begin       			:StuffBytes2(offset+4, obj, 0, -1);       			if not (ro and cl='instructions)       			then call kSaveOffset with (pkgObjs,  pkgOffs,  origObj, origOffset, if ro then -1 else 65536);       			pos := NIL; // don't remove       			end              	else if ctype = 0x41	// ARRAY       	then begin       		if frameMap       		then begin       			pos := call kSaveOffset with (pkgAObjs, pkgAOffs, origObj, origOffset, -1);       			:stuffVPUM(offset := offset+4, NIL); // extra NIL at beginning. don't remove       			end       		else pos := if not (ro and cl='literals)       			then call kSaveOffset with (pkgObjs,  pkgOffs,  origObj, origOffset, -1);       		foreach val in obj       		do :stuffVPUM(offset := offset+4, val);       		end              	else // if ctype = 0x43 then // FRAME       		begin       			pos :=       				if not (ro and Length(arg) >= 3 and arg[0]='_nextArgFrame and        					arg[1]='_Parent and arg[2]='_implementor)       				then call kSaveOffset with (pkgObjs,  pkgOffs,  origObj, origOffset, -1);       			foreach slot in arg // since framemap may have been sorted!       			do begin       				if not SetContains('[       						class, literals, argFrame, instructions, numArgs,       						_nextArgFrame, _parent, _implementor, preAllocatedContext],       					slot)       				then begin       					progressOptions.titleText := slot & unicodeCR & nextChunk;       					if progressOptions.maxGauge       					then progressOptions.gauge := RIntToL(nextChunk / progressOptions.maxGauge * 100);       					progressView:SetStatus(progressOptions.type, progressOptions);       					end;       				:stuffVPUM(offset:=offset+4, GetSlot(obj,slot));       				end;       		end;              	// optimization. remove non-readonly entries. replace with <_pkgOffset_: offset>       	if pos and not ro       	then call kSaveOffset with (pkgObjs, pkgOffs, origObj, origOffset, pos);              	origOffset;       end,     segEntry: nil,     pkgObjs:       nil // array of some (e.g., symbol) package objects (corresponds to pkgOffs)       ,     pkgOffs:       nil // array of some (e.g., symbol) package offsets       ,     savePackage:       func()       begin       	local newtPkg := appTemplate._package, pkg := -1;       	RemoveSlot(appTemplate,'_package); // don't save this       //Print(newtpkg); Print(appTemplate);       	self.nos20 := kBuild20 or Functions.isVBO;       	local psym := newtPkg.pkgSymbol, sym, val;       	if not psym       	then psym := appTemplate.appSymbol;       	local pkgFrame, partData := newtpkg.partData, isbn := appTemplate.isbn;       	local devInstallScript := newtpkg.installScript;       	local devRemoveScript := newtpkg.removeScript;       	local icon := newtpkg.icon;       	local autopart := partData or newtpkg._ExportTable;	// !!!a              	local pkgType := if autopart then "auto" else if isbn then "book" else "form";       	local version := if isbn then appTemplate.version else newtpkg.version;       	local copyright := if isbn then appTemplate.copyright else newtpkg.copyright;       	if kBuild20 or nos20       	then begin       		if not isString(copyright)       		then copyright := kCopyright && GetUserConfig('name);       		if not IsInteger(version) then version := 1;       		end       	else begin       		if not isInstance(copyright, 'string)       		then copyright := kCopyright && call kGetUserConfigFunc with('name);       		if not isInstance(version, 'int) then version := 1;       		end;       //Print(copyright); Print(version);              	local stitle := newtpkg.shortTitle;	// moved earlier from app for autopart too       	if not stitle        	then stitle := if autopart then newtpkg.text else appTemplate.title;       	if not (if kBuild20 then IsString(stitle) else isInstance(stitle,'string)) // !!!a       	then stitle := SPrintObject(psym);              	if autopart       	then begin       		pkgFrame := {       			//_ImportTable:		nil,	// !!!a       			devInstallScript: 	devInstallScript,       			devRemoveScript: 	devRemoveScript,       			InstallScript:		kAutoInstallScript,       			partData: 			partData,       			text:				stitle,				// added always       			//icon:				// if any copied below       			};       		end              	else if isbn       	then begin       		pkgFrame := {       			//_ImportTable: nil, // !!!a       			book: appTemplate,       			};	       		icon := appTemplate.icon;       		if appTemplate.help       		then pkgFrame.help := true;       		//appTemplate.BookInstallScript, BookRemoveScript       		end              	else begin       		pkgFrame := {       			//_ImportTable: nil,	// !!!a       			app: psym,       			text: stitle,       			icon: if icon then icon else icon := genericAppIcon, // maybe copied again below       			theForm: appTemplate,       			InstallScript: kFormInstallScript,       			RemoveScript:  kFormRemoveScript,       			};       		//if autoClose := newtpkg.autoClose	// copy below       		//then pkgFrame.autoClose := autoClose;       		if devInstallScript       		then pkgFrame.devInstallScript := devInstallScript;       		if devRemoveScript       		then pkgFrame.devRemoveScript := devRemoveScript;       		end;              	gc();       	local defStore :=       		if kBuild20 or nos20       		then GetDefaultStore()       		else call kGetDefaultStoreFunc with ();       	:init([], defStore, newtPkg.sizeHint, psym,       		pkgType & if autopart and newtPkg.dispatchOnly then $!);              	if icon       	then progressOptions.icon := DeepClone(icon);              	local flags :=       		(if autopart and newtPkg.dispatchOnly then 0x8000 else 0) +       		(if newtPkg.copyProtected then 0x4000 else 0) +       		(if newtPkg.compressed       			then if kBuild20 and newtPkg.compressed='faster		// !!!a       				then 0x0200										// kUseFasterCompressionFlag       				else 0       			else 0x1000);              	local parts := newtpkg.parts;       	foreach sym in kOmitPkgSlots       	do RemoveSlot(newtpkg, sym);              	// copy remaining items directly:       	// DoNotInstall, deletionScript, labels, TapAction, iconPro, icon, autoclose       	// and any other setPartFrameSlot items       //Print(newtpkg); Print(pkgFrame);       	foreach sym, val in newtpkg       	do pkgFrame.(sym) := val;       	newtpkg := NIL;       	//if kBuild1x or not pkgFrame._ImportTable	// !!!a       	//then RemoveSlot(pkgFrame, '_ImportTable);       //Print(pkgFrame);              	pkgFrame := {       		type: 	pkgType,		// required       		//flags: 0x00000081,	// optional (default: 0x00000081)       		//notification: pkgType,// optional (default: pkgType)       		//compressor: nil,		// optional       		data: pkgFrame,			// required       		};       	parts :=       		if isArray(parts)       		then if kBuild20       			then ArrayInsert(Clone(parts), pkgFrame, 0)       			else ArrayMunger(Clone(parts),0,0, [pkgFrame],0,nil)       		else [pkgFrame];              //GetGlobals().pp := self; // ***              	if progressView = self       	then begin       		progressView:SetStatus('vStatus, {titleText: progressOptions.statusText});       		Sleep(60);	// leave visible for 1 sec       		pkg := :saveInstall(self, defStore, parts, version, copyright, psym, flags);       		end              	else if kBuild20 or nos20       	then DoProgress(progressOptions.type, progressOptions,       			func(contextView) pkg := :saveInstall(contextView, defStore, parts, version, copyright, psym, flags))              	else begin // 1.x       		pkg := :saveInstall(BuildContext(GetLayout("protoProgress")), defStore, parts, version, copyright, psym, flags);       		progressView:close();       		RefreshViews();       		end;              	pkgSoup:?removeAllEntries();       	if not (if kBuild20 then IsInteger(pkg) else isInstance(pkg,'int))       		or (pkg > 0 and pkg <> 666)       	then PlaySound(ROM_funBeep)       	else if HasVariable(self,'error)       	then :error('savePackage, {error: pkg})       	else GetRoot():Notify(kNotifyAlert,       			SPrintObject('savePackage), SPrintObject(pkg));       	NIL;       	end,     stuffPackage:       func(ARRAY parts, INT version, devCopyright, packageName, INT flags) // called by saveInstall       begin       	if kProfileOn then EnableProfiling(true);       	local INT partOffset := 52, partDataOffset, i;       	local part, t;       	:setOffset(0,TRUE);              // PACKAGE HEADER       	StuffCString(segment,  0, if pkgPad=4 then "package1xxxx" else "package0xxxx");       	StuffWord	(segment, 12, flags); //uncompressed,copyprotected,dispatchonly ***       	StuffWord	(segment, 14, 0);       	StuffLong	(segment, 16, version);              	StuffWord	(segment, 20, 0);	// offset       	StuffWord	(segment, 22, t := (StrLen(devCopyright)+1)*2); // \u       	StuffWord	(segment, 24, t); // offset       	StuffWord	(segment, 26, (StrLen(packageName) +1)*2); // \u              	//StuffLong	(segment, 28, nextChunk); // fill in at end when we know it       	//StuffLong	(segment, 32, 0); // create_time, Mac format -- too big              	local INT lo, hi; // minutes       	lo := (Band(t := Time(),0xFFFF) * 60) + (TimeInSeconds() mod 60);       	hi := ((t >> 16) * 60) + (lo >> 16);       	StuffWord	(segment, 32, hi);       	StuffWord	(segment, 34, lo);       	//StuffWord	(segment, 36, hi);       	//StuffWord	(segment, 38, lo);       	StuffLong	(segment, 36, 0);       	       	StuffLong	(segment, 40, 0);              	// write PART HEADERs, including variable length PACKAGE header strings       	:stuffPartHeader(partOffset, parts, devCopyright, packageName);              	StuffLong	(segment, 44, partDataOffset := nextChunk);       	StuffLong	(segment, 48, Length(parts));              	for i:=0 to Length(parts)-1       	do begin       		part := parts[i];       		part.offset := nextChunk - partDataOffset;       		part.start := nextChunk;       		t := part.data;       		if kBuild20	// !!!c,a       		then if t._ImportTable       			then begin       				curPart := {_ImportTable: t._ImportTable};		// preserve in Newt for subsequent build?       				t._ImportTable := TotalClone(t._ImportTable); 	// destroy copy       				end       			else curPart := nil;       		if StrEqual(part.type, "auto") and not t.InstallScript       		then t.InstallScript := kAutoInstallScript;       		:stuffChunk(firstChunk := nextChunk, [t]);       		part.stop := nextChunk;       		end;       //Print(parts);              	// fixup PACKAGE HEADER with package length       	if (nextChunk mod kSegSize) <> 0       	then begin       		if (segOffset := nextChunk - segBegin) >= segSize       			or nextChunk < segBegin       		then :setOffset(nextChunk,TRUE);       		SetLength (segment, segOffset);       		end;              	if 0 < segBegin       	then :setOffset(0,TRUE);       	StuffLong(segment, 28, nextChunk);	// PACKAGE length              	// fixup PART HEADER with part length       	// partOffset := 52;       	for i:=0 to Length(parts)-1       	do begin       		part := parts[i];       		t := part.stop - part.start;       		StuffLong(segment, partOffset, 	 part.offset);       		StuffLong(segment, partOffset+4, t);       		StuffLong(segment, partOffset+8, t);       		partOffset := partOffset + kPartHeaderSize;       		end;              	if segEntry then EntryChange(segEntry);       	if kProfileOn       	then EnableProfiling(nil);              	if kDebugOn       	then begin       		Print("package length" && nextChunk);       		Print([       			"pkgAoffs", Length(pkgAoffs),       			"pkgOffs", 	Length(pkgOffs),]);       		end;       end,     Init:       func(segs, defStore, sizeHint, psym, pkgType)       begin       	self.pkgObjs 	:= [nil];       	self.pkgOffs 	:= SetClass(Clone(""), '_pkgOffset_);       	self.pkgAObjs	:= [];       	//self.pkgAOffs	:= NIL; //SetClass(clone(""), '_pkgOffset_);       	self.segSize	:= kSegSize; // initially for smallPackage; constant for reg package       	self.segments 	:= if isArray(segs) then segs;       	self.nextFlush	:= NIL;              	self.progressOptions := // DoProgress format.       		{closebox: nil,       		statusText: kVersion & (if smallPackage then "+S")  & "©S.Weyer\n" & psym,       					//"Pkg(" & pkgType & "):" && psym,       		titleText: "",       		barber: not sizeHint,       		gauge: if sizeHint then 0,       		maxGauge: sizeHint,       		type: if sizeHint then 'vGauge else 'vBarber,       		//icon:       		};              	if kBuild20 or nos20       	then begin       		self.segBegin := 0;       		smallPackage := NIL; // for prog label       		self.segment :=       			if kDebugOn and not segments	// !!!a       			then {       				nextFlush:	kVBOFlush,       				reloFix: 	kReloFix,       				reloFixObj: kReloFixObj,       				}:reloFix(GetPkgRef(segs.title, segs.store), true)       			else defStore:NewCompressedVBO('packageEntry, kSegSize, kTextCompander, nil);	// new pkg       		pkgOffs 	:= defStore:NewCompressedVBO('_pkgOffset_, 0, kTextCompander, nil);       		nextFlush	:= kVBOFlush;       		end              	else if not smallPackage       	then begin       		self.pkgSoup := defStore:GetSoup(kPkgSoupName);       		if pkgSoup       		then pkgSoup:removeAllEntries()       		else pkgSoup := defStore:CreateSoup(kPkgSoupName,[]);              		self.cursor := Query(pkgSoup,{type: 'index});       		if kDebugOn and not segments       		then segments := BackupPackage(pkgSoup, segs); // test       		end;       end,     ArrayDiff:       func(a1,a2,diff)       if length(a1)=length(a2)       then begin       	local i;       	for i:=0 to length(a1)-1       	do if a1[i]<>a2[i] and :ObjDiff(a1,a2,i,diff)       		then return SetAdd(diff,i,nil);       	//NIL;       	end       else SetAdd(diff,'len,nil),     cursor: nil,     progressView: nil,     extractNum: kExtractNum,     segBegin: -kSegSize,     segments: nil,     printPkgEntry:       func(data,offset, type,len,name,const, hframe)       begin       	local vlen, val;       	if type='int       	then val := :extractNum(data, offset, vlen := 2, 0)              	else if type='long       	then begin       		vlen := 4;       		val :=       			if ExtractByte(data, offset) < 0x40       			then ExtractLong(data, offset)       			else :printHexBin(data, offset,4,'H);       		end              	else if type='time       	then begin       		vlen := 4;       		val := ExtractLong(data,offset);       		end              	else if type='char       	then if vlen := len       		then val := :extractString(data, offset, len, nil, 1)       		else begin       			val := ExtractCString(data,offset);       			vlen := StrLen(val)+1;       			end              	else if type='uchar       	then if vlen := len       		then val := ExtractBytes(data,offset,len,'String)       		else begin       			val := :extractString(data, offset, len, 'String, 2);       			vlen := (StrLen(val)+1)*2;       			end;              Print([       	offset, name, val,              	if type='time then DateNTime(val)       	else if isInstance(val,'string) then "len="&vlen // IsString(val)       	else :printHexBin(val,nil,vlen,'H),              	if const       	then if (if isInstance(const,'string) // IsString(val)       			then StrEqual(const,val) else const=val)       		then "OK"       		else "*********"       	else "",       	]);              	hframe.(name) := val;       	offset+vlen;       end,     pkgAObjs: nil,     pkgAOffs: nil,     extractCString2:       func(offset,len)       begin       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,NIL);       	local dlen := segSize - segOffset;       	local s := ExtractCString(segment, segOffset);       	if len > dlen       	then begin       Print("splitC" && s);       		s & :ExtractCString2(offset + dlen, len - dlen);       		end       	else s;       end,     printPkgEntries:       func(data,offset, heading, hframe, entries)       begin       	local elen, type, len, name, const;       Print("\n"&heading);       	foreach e in entries       	do begin       		elen := length(e);       		type := e[0];       		len := if elen >= 3 then e[2];       		if isInstance(len,'symbol) // IsSymbol(len)       		then len := hframe.(len); // e.g., 'part_sym_len       		name := if elen >=2 then e[1];       		if not name then name := intern(type&offset);       		const := if elen>=4 then e[3];       		if isInstance(const,'symbol) // IsSymbol(const)       		then const := hframe.(const);       		offset := :printPkgEntry(data,offset, e[0],len,name,const, hframe);       		end;       	offset;       end,     keepValue: kDebugOn,     shareObj:       func (obj, int offset) // used only by extractXXX       begin       	local cl := Classof(obj);       	if cl<>'instructions and cl<>'literals       	then begin       		AddArraySlot(pkgOffs, offset);       		AddArraySlot(pkgObjs, obj);       		end;       end,     extractBytes2:       func(offset,len,dtype)       begin       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,NIL);       	local dlen := segSize - segOffset;       	if len <= dlen       	then ExtractBytes(segment, segOffset, len, dtype)       	else begin       Print("splitB" && dlen);       		BinaryMunger(       			ExtractBytes(segment, segOffset, dlen, dtype), dlen, 0,       			:ExtractBytes2(offset+dlen, len-dlen, dtype), 0, nil);       		end;       end,     StuffCString2:       func NATIVE (INT offset, str, INT start, INT len)       begin       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,TRUE);       	local INT segOff := segOffset;       	local INT dlen := segSize - segOff;       	if len < 0 then len := if kBuild20 then StrLen(str)+1 else call Functions.StrLen with(str)+1;       	local nosplit := len <= dlen;              	// StuffCString break near end of data (last xx bytes?)       	// plus we don't always want to create substr for str       	if start=0 and nosplit and segOff+(len*2) < Length(segment)       	then StuffCString(segment,segOff,str)              	else begin // slower but reliable fallback       		local INT i, null := if nosplit then len-1 else -1; // null index?       		for i:=0 to (if nosplit then len else dlen)-1 // len includes null (if null)       		do StuffChar(segment, segOff+i,       			if i=null then 0 else str[start+i]);              		if not nosplit       		then :stuffCString2(offset+dlen, str, start+dlen, len-dlen);       	end;       end,     pkgSoup: nil,     BinDiff:       func(b1,b2,diff)       if length(b1)=length(b2)       then begin       	local i;       	for i:=0 to length(b1)-1       	do if ExtractByte(b1,i) <> ExtractByte(b2,i)       	then return SetAdd(diff,i,nil);       	//NIL;       	end       else SetAdd(diff,'len,nil),     StuffBytes2:       func NATIVE (INT offset, bytes, INT start, INT len)       begin       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,TRUE);       	local INT dlen := segSize - segOffset;       	if len<0 then len := Length(bytes);       	if len <= dlen       	then BinaryMunger(segment,segOffset,len, bytes,start,len)       	else begin       		BinaryMunger(segment,segOffset,dlen, bytes,start,dlen);       		:stuffBytes2(offset+dlen, bytes, start+dlen, len-dlen);       		end;       end,     viewClass: 74 /* clView */,     curPart:       nil // !!!b       ,     extractVPUM:       func(INT offset)       begin       	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,NIL);              	local kREF := Functions.REF; 	// avoid compiler warnings       	local INT byte3 := ExtractByte(segment, segOffset+3);       	local INT bits2 := Band(byte3, 0x3);       	local INT byte0 := ExtractByte(segment,segOffset);              	if bits2=0				// VALUE       	then if byte0 < 0x20       		then call kREF with(ExtractLong(segment,segOffset))       		else :extractNum(segment,segOffset,4,-2)              	else begin       		local INT longVal :=       			if byte0 < 0x20       			then ExtractLong(segment,segOffset)       			else :extractNum(segment,segOffset, 4, 0);	// !!!a       		if bits2=1			// POINTER to Data, Array or Frame       		then if longVal > 0 and longVal < Length(segment)       			then :extractChunk(longVal-1)       			else [funny: longVal]              		else if bits2=3			// MAGIC POINTER ??? Ref?       		then begin       Print("magic:" && longVal);       			call kREF with(longVal);       			end              		else if byte3=0x52 and	// UNUSUAL/UNICODE       			longVal=0x00055552		// SYMBOL       		then kSymbolType              		else call kREF with (longVal);	// NIL, TRUE, WEAK ARRAY, UNICODE CHAR       		end;       end,     testpackage:       func(ptitle,asym, doit, keepValue, extract)       //{_parent: tt, _proto: tt.protoPackage}:testPackage("ProtNOS2:TKnollSys",nil, true, nil, true)       begin       	local ARRAY pkgs := GetPackages();              	local ppos, pkg :=       		if kBuild1x and Functions.ArrayPos exists       		then begin       			if ppos := ArrayPos(pkgs,ptitle,0,func(pt,p) StrEqual(pt,p.title))       			then pkgs[ppos];       			end       		else LFetch(pkgs,ptitle,0,'|str=|,'title);              /*	local epos := ArrayPos(Extras,asym,0,       			if isInstance(asym,'symbol)       			then func(a,e) a=e.app       			else func(a,e) e.app='copperfield and StrEqual(a,e.isbn)       			);       	local exApp := if epos then Extras[epos];       	if not (doit and pkg and exApp)       	then return Print([pkg, exApp]);       */              	:init(pkg, if kBuild20 then GetDefaultStore() else call kGetDefaultStoreFunc with(),nil,ptitle,"?"); // ???       	pkgOffs := [0];              	if not extract       	then return self;              	local pkgFrame := :extractPackage(nil);       	progressView:?close();              /*       	if keepValue       	then begin       		Print(:ObjDiff(pkgFrame.part1[0], exApp, '[pathExpr: icon, bits], []));       		Print(:ObjDiff(pkgFrame.part1[0], exApp, '[pathExpr: theForm], []));       		end;       */              	pkgSoup:?removeAllEntries();       	pkgFrame;       end,     saveInstall:       func(contextView, defStore, ARRAY parts, INT version, copyright, psym, INT flags) // called by savePackage       begin       	local pkg;       	progressView := contextView;              	try begin       		:stuffPackage(parts,       			version,       			copyright,       			SPrintObject(psym),       			flags       			);       		progressOptions.titleText := "InstallingÉ" & unicodeCR & nextChunk;       		progressOptions.barber := nil;       		progressOptions.gauge := 0;       		progressView:SetStatus(progressOptions.type := 'vGauge, progressOptions);       //Print(segment);       		//if kDebugOn then :extractPackage(true);              		pkg := if kBuild20 or nos20       			then defStore:suckPackageFromBinary(segment,       				{callbackFreq: 2048,	// callbackFrequency wrong in docs!       				callBack: func(callbackInfo)       					begin       //Print(callbackInfo);       					progressOptions.gauge := RIntToL(callbackInfo.amountRead / callbackInfo.packageSize * 100);       					progressView:SetStatus(progressOptions.type, progressOptions);       					end,       					})       			else if pkgSoup       			then defStore:RestoreSegmentedPackage(pkgSoup, segments)       			else defStore:RestorePackage(segment); // "small" package (pre 1.3 ROMs) or VBO (2.x)              		end       		onexception |evt.ex|       		do begin	// 666 if Stop button       			pkg := currentException();       			pkg := if pkg.error       				then pkg.error       				else if pkg.data.errorCode exists       				then pkg.data.errorCode       				else -1;       			end;       	pkg;       end,     stuffVPUM:       func (INT offset, val)       begin       	local t, sval;       	sval :=       	if isImmediate(val) and		// isInstance breaks if array class is a number       		(if kBuild20 then IsInteger(val) else isInstance(val,'int)) and       		(val > 0x07FFFFFF or // 134217727       	 	val < 0x38000000)       	then NIL // write as "big" INT (RefOf inaccurate)              	else if val=kSymbolType 	// my special symbol flag       	then 0x00055552              	else if isImmediate(val) // IMMEDIATE: "small" INT, NIL, TRUE, WEAK ARRAY, UNICODE CHAR       		or IsMagicPtr(val)   // MAGIC POINTER       	then if kBuild20 then RefOf(val) else call Functions.RefOf with (val)   // val << 2, (val << 2) + 3 ???       //if IsMagicPtr(val) then Print("magic:" && sval);              	else // POINTER: FRAME, ARRAY, SYMBOL, BINARY       		if kBuild20 and curPart and isArray(t := curPart._ImportTable) and // !!!a       			(sval := call kExportEntry with (val))       	then begin // a unit reference -> funny magic pointer       //Print(sval);       		// position of name in IMPORT table = table       		// position of object in EXPORT table = offset       		local table := LSearch(t, sval.name, 0, GetGlobalFn('SymbolCompareLex), 'name);       		if not table       		then begin       			table := Length(t);       			AddArraySlot(t, {name: TotalClone(sval.name), major: sval.major, minor: sval.minor});       			end;       //Print(t);       //Print("loc:" && offset); Print("table:" && table); Print("index:" && SetContains(sval.objects, val)); Print(val);       //Print(  ((table+2) << 14) + (SetContains(sval.objects, val) << 2) + 0x3);       		((table+2) << 14) + (SetContains(sval.objects, val) << 2) + 0x3;       		end       	else :stuffChunk(nextChunk,val)+1;              	if (segOffset := offset - segBegin) >= segSize       		or offset < segBegin       	then :setOffset(offset,TRUE);              	if sval       	then StuffLong(segment, segOffset, sval)       	else call kStuffNum with (segment, segOffset, val, 4, -2);       end    };// After Script for protoPackagethisView := protoPackage;begin		RemoveSlot(thisView,'ObjDiff);		RemoveSlot(thisView,'FrameDiff);		RemoveSlot(thisView,'BinDiff);		RemoveSlot(thisView,'ArrayDiff);	if not kDebugOn	then begin		RemoveSlot(thisView,'testPackage);		RemoveSlot(thisView,'shareObj);		RemoveSlot(thisView,'keepValue);		RemoveSlot(thisView,'extractBytes2);		RemoveSlot(thisView,'extractChunk);		RemoveSlot(thisView,'extractCString2);		RemoveSlot(thisView,'extractNum);		RemoveSlot(thisView,'extractPackage);		RemoveSlot(thisView,'extractString);		RemoveSlot(thisView,'extractVPUM);		RemoveSlot(thisView,'printHexBin);		RemoveSlot(thisView,'printPkgEntries);		RemoveSlot(thisView,'printPkgEntry);		end;	partData.(kPartDataSymbol) := thisView;endconstant |layout_protoPackage| := protoPackage;// End of file protoPackage