// Text of project Newt2x.¹ written on 3/3/00 at 11:07 AM// Beginning of text file proterr1.txt// proterr1.txt// constant definitions for ProtErr1.pkg// Copyright 1995-98 S. Weyer. All Rights Reserved Worldwide// 19 Apr 96// based on NTK Appendix A (Copyright Apple Computer, Inc. 1993-1995)// provides constants to Newt: protoDict frame & errorCodes array// used directly by Newt 3.2, and by proterr1.pkg (e.g., for Newt's Cape)// pkg size =~??K/* NOTE: list of documented NOS 1.x protos as best as I can determine fromlatest docs(index) and MessagePad Defs file.Page numbers refer to page in latest online NTK docs (ftp.info.apple.com).Additional (undocumented) views & protos may be found in misccnst (plugin/.txt).*/SetLocalizationFrame({});if not IsGlobalConstant('kBuild20)then DefineGlobalConstant('kBuild20,	// '|Newton 2.0| or '|Newton 2.1|		BeginsWith(SprintObject(platformVersion.platformFile), "Newton"));if not IsGlobalConstant('kBuild1x)then DefineGlobalConstant('kBuild1x, not kBuild20);DefineGlobalConstant('kProtoDictFrame, {clView:				clView,			//  74 p.2-11 generic viewclEditView:			clEditView,		//  77 p.8-5 for containing text(para) and graphics(poly)clGaugeView:		clGaugeView,	//  92 p.7-37clKeyboardView:		clKeyboardView,	//  79 p.8-6clMonthView:		clMonthView,	//  80clOutline:			clOutline,		// 105 p.6-135clParagraphView:	clParagraphView,//  81 p.8-5 textclPictureView:		clPictureView,	//  76 p.12-34clPickView:			clPickView,		//  91 (used to implement protoPicker)clPolygonView:		clPolygonView,	//  82 p.12-33clRemoteView:		clRemoteView,	//  88 p.12-35/* UNDOCUMENTED??:clCharBoxView, clContainerView, clCopperfield, clDataView, clDayView,clLibrarian, clMathExpView, clMathOpView, clMathLineView, clMeetingView,clPage, clPrintView, clRepeatingView,clScheduleView, clSliderView, clTextView, clTrainView,*/// 1.xprotoApp:					protoApp,					//@157 p.2-12protoActionButton:			protoActionButton,			//@209 p.2-51 (comm) (formerly protoRoutingSlip)protoBorder:				protoBorder,				//@160 p.7-48protoCheckBox:				protoCheckBox,				//@164 p.7-26protoCloseBox:				protoCloseBox,				//@166 p.7-23ROM_coverpageformat:		if kBuild20 then NIL							else ROM_coverpageformat,	//@60,protoCoverPageFormat:		if kBuild20							then protoCoverPageFormatDeprecated							else ROM_coverpageformat, 	//@60protoDateExpando:			if kBuild20							then protoDateExpandoDeprecated							else protoDateExpando,		//@170protoDivider:				protoDivider,				//@172 p.7-49protoDrawer:				protoDrawer,				//@173 p.7-52//protoEndPoint:			protoEndPoint, 				// alloc in CommCnstprotoExpandoShell:			if kBuild20							then protoExpandoShellDeprecated							else protoExpandoShell,		//@175protoFilingButton:			protoFilingButton,			//@176 p.15-10protoFloater:				protoFloater,				//@179 p.7-56protoFloatNGo:				protoFloatNGo,				//@180 p.7-58protoFolderTab:				protoFolderTab,				//@211 p.15-10 (formerly protoShowBar)protoGauge:					protoGauge,					//@182 p.7-34protoGlance:				protoGlance,				//@183 p.7-50protoInputLine:				protoInputLine,				//@185 p.8-15protoKeyboard:				protoKeyboard,				//@187 p.8-38protoKeypad:				protoKeypad,				//@188 p.8-38protoLabeledBatteryGauge:	protoLabeledBatteryGauge,	//@316 p.7-36protoLabelInputLine:		protoLabelInputLine,		//@189 p.8-16protoLabelPicker:			protoLabelPicker,			//@190 p.6-32protoLargeCloseBox:			protoLargeCloseBox,			//@163 p.7-24 (formerly protoCancelButton)protoPhoneExpando:			if kBuild20							then protoPhoneExpandoDeprecated							else protoPhoneExpando,		//@194protoPicker:				protoPicker,				//@195 p.6-36protoPictIndexer:			protoPictIndexer,			//@196 p.6-101protoPictRadioButton:		protoPictRadioButton,		//@197 p.7-20protoPictureButton:			protoPictureButton,			//@198 p.7-12protoPrintFormat:			protoPrintFormat,			//@200 p.2-21(comm)protoRadioButton:			protoRadioButton,			//@202 p.7-19protoRadioCluster:			protoRadioCluster,			//@203 p.7-16protoRCheckbox:				protoRCheckbox,				//@204 p.7-28protoRecToggle:				protoRecToggle,				//@234 p.10-67protoRoll:					protoRoll,					//@206 p.6-128protoRollBrowser:			protoRollBrowser,			//@207 p.6-131protoRollItem:				protoRollItem,				//@208 p.6-134protoSetClock:				protoSetClock,				//@210 p.7-43protoSlider:				protoSlider,				//@212 p.7-32protoStaticText:			protoStaticText,			//@218 p.7-60protoStatus:				protoStatus,				//@219 p.7-61protoStatusBar:				protoStatusBar,				//@220 p.7-62protoTable:					protoTable,					//@223 p.6-48protoTableDef:				protoTableDef,				//@224 p.6-50protoTableEntry:			protoTableEntry,			//@225 p.6-52protoTextButton:			protoTextButton,			//@226 p.7-10protoTextExpando:			if kBuild20							then protoTextExpandoDeprecated							else protoTextExpando,		//@227protoTextList:				protoTextList,				//@228 p.6-45protoTitle:					protoTitle,					//@229 p.7-63/*UNDOCUMENTED: (see misccnst)protobatterygauge, protobook, protobookmark, protobottomtitle,protocalendaroverview, protocheckboxicon, protocorrectcontext, protocorrector,protocursivecheckbox, protodictionary, protofindcategory, protofinditem,protoformulaoptioncheckbox, protohilitebutton, protoiocategory, protooverview,protooverviews, protoparagraph, protopolygon, protoprintpage,protorecognitioncheckbox, protosmartaddressline,protosmartdateline, protosmartemailline, protosmartnamelineprotosmartphoneline, protostorycard, protostrokesitem, protozonestableprotoincategory, protooutcategory, protonavigator, protoirendpoint,protoserialendpoint, protomodemendpoint, protoadspendpoint*/});//print(kprotodictframe);constant kReadOnly	:= "obj. read-only";constant kExpSymbol	:= "exp. symbol";constant kExpFrame	:= "exp. frame";constant kPath 		:= "invalid seg. in path expr";constant kExpString	:= "exp. string";constant kFrameEx	:= "frame excp.";constant kBadTypeEx	:= "bad type excp.";constant kInterpEx	:= "interpreter excp.";constant kHeapOut	:= "Out of heap";// these are abbrev. see ErrCnst for longer & more messagesDefineGlobalConstant('kErrorCodesArray, [-10405,	"bad pkg. installScript?",//Object System Errors-48200,	"exp. frame, array or binary obj",-48202,	"empty path",-48203,	kPath,-48204,	"path failed",-48205,	"index out of bounds (string or array)",-48206,	"source & dest must be diff objs",-48207,	"long out of range",-48210,	"bad args",-48211,	"string too big",-48214,	kReadonly,-48215,	"func not impl",-48216,	kHeapOut,//Bad Type Errors-48400,	kExpFrame,-48401,	"exp. array",-48402,	kExpString,-48403,	"exp. pointer",-48404,	"exp. number",-48405,	"exp. real",-48406,	"exp. integer",-48407,	"exp. char",-48408,	"exp. binary obj",-48409,	"exp. path expr, sym or int",-48410,	kExpSymbol,-48411,	"exp. func",-48412,	"exp. frame or array",-48413,	"exp. array or NIL",-48414,	"exp. string or NIL",-48415,	"exp. binary obj or NIL",-48416,	"unexp. frame",-48417,	"unexp. binary obj",-48418,	"unexp. immediate",//Interpreter Errors-48800,	"not in break loop",-48802,	"too many args for CFunction",-48803,	"wrong num of args",-48804,	"FOR loop BY expr=0",-48806,	"no current excp.",-48807,	"undef var",-48808,	"undef global func",-48809,	"undef method",-48810,	"no _proto for inherited send",-48811,	"accessed slot in NIL context",-48814,	"no local vars and FOR loops at top level",'|evt.ex.fr|,						kFrameEx,'|evt.ex.fr;type.ref.frame|,		kFrameEx,'|evt.ex.fr.type|,					kBadTypeEx,'|evt.ex.fr.type;type.ref.frame|,	kBadTypeEx,'|evt.ex.fr.comp|,					"compiler excp.",'|evt.ex.fr.intrp|, 				kInterpEx,'|evt.ex.fr.intrp;type.ref.frame|, 	kInterpEx,'|evt.ex.fr.store|, 				"store excp.",'|evt.ex.comm|, 					"comm. excp.",'|evt.ex.div0|, 					"divide by 0",'|evt.ex.outofmem|,					kHeapOut,]);//print(kErrorCodesArray);// End of text file proterr1.txt// Beginning of text file protnos2.txt// protnos2.txt// constant definitions for ProtNOS2.pkg// Copyright 1996-98. S. Weyer. All Rights Reserved Worldwide// NOS 2.0/2.1 protosif not IsGlobalConstant('kBuild20)then DefineGlobalConstant('kBuild20,	// '|Newton 2.0| or '|Newton 2.1|		BeginsWith(SprintObject(platformVersion.platformFile), "Newton"));if not IsGlobalConstant('kBuild1x)then DefineGlobalConstant('kBuild1x, not kBuild20);// these are included with Newt 3.x-2// or can be added for Newt 3.x via protoNOS2 autopart// pkg size =~??K/* NOTE: list of documented NOS 2.0 protos as best as I can determine fromlatest docs(index) and Newton 2.0 Defs file. There will be someadditions/removals as I test examples and read docs more closely.Page numbers refer to page in latest online NTK docs (ftp.info.apple.com).Additional (undocumented) protos may be found in misccnst (plugin/.txt).Four protos are in NTK docs: newtROTextPhoneView, newtTextPhoneView,protoChild, protoDigitPicker -- but  are undefined in NTK.I have indicated these by @??? -- and have reported to Apple.*/DefineGlobalConstant('kProtoDictFrame2, {newtAboutView:				newtAboutView,				//@152 p.4-51newtActionButton:			newtActionButton,			//@439 p.4-53 (formerly newtRoutingButton)newtApplication:			newtApplication,			//@398 p.4-15//newtAreaCodeLine:			newtAreaCodeLine,			// @26 misccnst//newtAreaCodePhoneLine:	newtAreaCodePhoneLine,		//@294 misccnstnewtAZTabs:					newtAZTabs,					//@430 p.4-53// newtCheckAllButton = @872newtCheckBox:				newtCheckBox,				//@618 p.4-82newtCityFilter:				newtCityFilter,				//@647newtClockFolderTab:			newtClockFolderTab,			//@162 p.4-55 (formerly newtClockShowBar)newtCountryFilter:			newtCountryFilter,			//@649//newtCountrySymbolFilter:	newtCountrySymbolFilter,	//@146 misccnst//newtCustomFilter:			newtCustomFilter,			//@437 misccnstnewtDateFilter:				newtDateFilter,				//@642newtDateNTimeFilter:		newtDateNTimeFilter,		//@644newtEditView:				newtEditView,				//@413 p.4-82newtEntryLockedIcon:		newtEntryLockedIcon,		//@507 p.4-83newtEntryPageHeader:		newtEntryPageHeader,		//@309 p.4-71newtEntryRollHeader:		newtEntryRollHeader,		//@410 p.4-72newtEntryShowStationeryButton:						newtEntryShowStationeryButton,	//@816 p.5-28newtEntryView:				newtEntryView,				//@406 p.4-67newtEntryViewActionButton:	newtEntryViewActionButton,	//@407 p.4-73 (formerly newtEntryViewRouting)newtEntryViewFilingButton:	newtEntryViewFilingButton,	//@408 p.4-73 (formerly newtEntryViewFiling)newtFalseEntryView:			newtFalseEntryView,			//@652 p.4-28newtFilingButton:			newtFilingButton,			//@440 p.4-53newtFilter:					newtFilter,					//@638newtFloatingBar:			newtFloatingBar,			//@459 p.4-57newtFolderTab:				newtFolderTab,				//@143 p.4-54 (formerly newtShowBar)newtInfoBox:				newtInfoBox,				//@672 p.4-73newtInfoButton:				newtInfoButton,				//@124 p.4-50newtIntegerFilter:			newtIntegerFilter,			//@640//newtLabelCustomInputLine:	newtLabelCustomInputLine,	//@438 misccnstnewtLabelDateInputLine:		newtLabelDateInputLine,		//@424 p.4-94newtLabelInputLine:			newtLabelInputLine,			//@422 p.4-90newtLabelNumInputLine:		newtLabelNumInputLine,		//@423 p.4-93newtLabelPhoneInputLine:	newtLabelPhoneInputLine,	//@425 p.4-100newtLabelSimpleDateInputLine:						newtLabelSimpleDateInputLine,	//@682 p.4-96//newtLabelSymbolInputLine:	newtLabelSymbolInputLine,	//@496 misccnstnewtLabelTimeInputLine:		newtLabelTimeInputLine,		//@493 p.4-98newtLayout:					newtLayout,					//@402 p.4-58newtNewStationeryButton:	newtNewStationeryButton,	//@813 p.5-26newtNRLabelDateInputLine:	newtNRLabelDateInputLine,	//@636 p.4-96newtNRLabelDateNTimeInputLine:						newtNRLabelDateNTimeInputLine,	//@637 p.4-99newtNRLabelTimeInputLine:	newtNRLabelTimeInputLine,	//@635 p.4-98newtNumberFilter:			newtNumberFilter,			//@641newtNumView:				newtNumView,				//@417 p.4-78newtOverLayout:				newtOverLayout,				//@405 p.4-64newtPageLayout:				newtPageLayout,				//@404 p.4-63newtPhoneFilter:			newtPhoneFilter,			//@646//newtPhonePopupEdit:		newtPhonePopupEdit,			//@587 misccnst//newtPopupEdit:			newtPopupEdit,				//@510 misccnstnewtPrefsView:				newtPrefsView,				//@107 p.4-52newtProtoLine:				newtProtoLine,				//@565 p.4-88//newtProtoLineBase:		newtProtoLineBase,			//@564 misccnst//newtQBELabelInputLine:	newtQBELabelInputLine,		//@426 misccnst//newtQBETextView:			newtQBETextView,			//@420 misccnst//newtROComboView:			newtROComboView,			//@441 misccnstnewtROEditView:				newtROEditView,				//@412 p.4-81newtROLabelDateInputLine:	newtROLabelDateInputLine,	//@620 p.4-95newtROLabelInputLine:		newtROLabelInputLine,		//@421 p.4-91newtROLabelNumInputLine:	newtROLabelNumInputLine,	//@619 p.4-92newtROLabelTimeInputLine:	newtROLabelTimeInputLine,	//@621 p.4-97newtRollEntryView:			newtRollEntryView,			//@409 p.4-71newtRollLayout:				newtRollLayout,				//@403 p.4-62newtRolloverLayout:			newtRolloverLayout,			//@374 p.4-66newtRollShowStationeryButton:						newtRollShowStationeryButton,	//@815 p.5-28newtRONumView:				newtRONumView,				//@416 p.4-77//newtROSymbolView:			newtROSymbolView,			//@494 misccnstnewtROTextDateView:			newtROTextDateView,			//@418 p.4-78//newtROTextPhoneView:		newtROTextPhoneView,		//@??? p.4-80newtROTextTimeView:			newtROTextTimeView,			//@491 p.4-79newtROTextView:				newtROTextView,				//@414 p.4-76newtShowStationeryButton:	newtShowStationeryButton,	//@814 p.5-27newtSimpleDateFilter:		newtSimpleDateFilter,		//@683newtSmartNameFilter:		newtSmartNameFilter,		//@650newtSmartNameView:			newtSmartNameView,			//@427 p.4-101//newtSmartPhoneView:		newtSmartPhoneView,			//@428 misccnstnewtSoup:					newtSoup,					//@429 p.4-32newtStateFilter:			newtStateFilter,			//@648newtStationery:				newtStationery,				//@451 p.5-21newtStationeryPopupButton:	newtStationeryPopupButton,	//@812 p.5-24newtStationeryView:			newtStationeryView,			//@411 p.4-83newtStatusBar:				newtStatusBar,				//@401 p.4-56newtStatusBarNoClose:		newtStatusBarNoClose,		// @73 p.4-55//newtSymbolFilter:			newtSymbolFilter,			//@645 misccnst//newtSymbolView:			newtSymbolView,				//@495 misccnstnewtTextDateView:			newtTextDateView,			//@419 p.4-79newtTextFilter:				newtTextFilter,				//@639//newtTextPhoneView:		newtTextPhoneView,			//@??? p.4-81newtTextTimeView:			newtTextTimeView,			//@492 p.4-80newtTextView:				newtTextView,				//@415 p.4-77newtTimeFilter:				newtTimeFilter,				//@643//protoActionButton										//     proterr1protoAddressPicker:			protoAddressPicker,			//@259 p.3-36(comm)protoAlphaKeyboard:			protoAlphaKeyboard,			//@375protoAMPMCluster:			protoAMPMCluster,			//@379 p.7-47//protoAnalogClock:			protoAnalogClock,			//  @5 misccnstprotoAnalogTimePopup:		protoAnalogTimePopup,		//@280 p.6-91//protoApp												//     proterr1protoAZTabs:				protoAZTabs,				//@617 p.7-30protoAZVertTabs:			protoAZVertTabs,			//@339 p.7-31protoBasicEndpoint:			protoBasicEndpoint,			//@383 p.4-12(comm)protoBlindEntryLine:		protoBlindEntryLine,		//@552 NOS 2.1//protoBorder											//     proterr1//protoCanonicalCompass:	protoCanonicalCompass,		// @28 misccnstprotoCharEdit:				protoCharEdit,				//@393//protoCheckBox											//     proterr1//protoChild:				protoChild,					//@??? p.4-63protoCitiesTextPicker:		protoCitiesTextPicker,		//@634 p.6-78protoClockFolderTab:		protoClockFolderTab,		//@670 p.15-7 (formerly protoClockShowBar)//protoCloseBox											//     proterr1//protoCorrectInfo:			protoCorrectInfo,			//@614 misccnstprotoCountryPicker:			protoCountryPicker,			//@458 p.6-53protoCountryTextPicker:		protoCountryTextPicker,		//@632 p.6-76//protoCoverPageFormat									//     proterr1protoDateDurationTextPicker:protoDateDurationTextPicker,//@607 p.6-61//protoDateExpando										//     proterr1protoDateIntervalPopup:		protoDateIntervalPopup,		//@356 p.6-85protoDateNTimePopup:		protoDateNTimePopup,		//@288 p.6-84protoDateNTimeTextPicker:	protoDateNTimeTextPicker,	//@630 p.6-66//protoDateNYearPicker 									//@555 misccnstprotoDatePicker:			protoDatePicker,			//@387 p.7-40protoDatePopup:				protoDatePopup,				//@317 p.6-82protoDateTextPicker:		protoDateTextPicker,		//@629 p.6-59//protoDayPicker:			protoDayPicker,				//@605 misccnstprotoDigitalClock:			protoDigitalClock,			//@463 p.7-41//protoDigitalTimePopup:	protoDigitalTimePopup,		//@514 misccnst//protoDigitPicker:			protoDigitPicker,			//@??? p.6-98//protoDivider											//     proterr1protoDragger:				protoDragger,				//@132 p.7-53protoDragNGo:				protoDragNGo,				//@804 p.7-55//protoDrawer											//     proterr1protoDurationTextPicker:	protoDurationTextPicker,	//@628 p.6-70protoEmporiumPopup:			protoEmporiumPopup,			//@498 p.18-12//protoExpandoShell										//     proterr1//protoFilingButton										//     proterr1//protoFloater											//     proterr1//protoFloatNGo											//     proterr1//protoFolderTab										//     proterr1protoFormatPicker:			protoFormatPicker,			//@487 p.3-83(comm)protoFrameFormat:			protoFrameFormat,			// @52 p.2-26(comm)protoFullRouteSlip:			protoFullRouteSlip,			//@655 p.3-32(comm)//protoGauge											//     proterr1protoGeneralPopup:			protoGeneralPopup,			//@671 p.6-42//protoGlance											//     proterr1protoHorizontal2DScroller:	protoHorizontal2DScroller,	//@608 p.7-5protoHorizontalUpDownScroller:						protoHorizontalUpDownScroller,	//@475 p.7-8protoImageView:				protoImageView,				//@485 p.12-35//protoInputLine										//     proterr1protoInfoButton:			protoInfoButton,			//@478 p.7-13//protoKeyboard											//     proterr1protoKeyboardButton:		protoKeyboardButton,		//@434 p.8-38//protoKeypad											//     proterr1//protoLabeledBatteryGauge								//     proterr1//protoLabelInputLine									//     proterr1//protoLabelPicker										//     proterr1//protoLargeCloseBox									//     proterr1//protoLatitudePicker:		protoLatitudePicker,		//@518 misccnstprotoLeftRightScroller:		protoLeftRightScroller,		//@657 p.7-8//protoLetterFormat:		protoLetterFormat,			//@305 misccnstprotoListPicker:			protoListPicker,			//@461 p.6-110protoListView:				@465,						//@465 p.8-18//protoLocationPicker:		protoLocationPicker,		//@512 misccnstprotoLocationPopup:			protoLocationPopup,			//@436 p.6-96//protoLongitudePicker:		protoLongitudePicker,		//@519 misccnst//protoLongLatPicker:		protoLongLatPicker,			//@521 misccnstprotoLongLatTextPicker:		protoLongLatTextPicker,		//@523 p.6-80//protoMapPopup:			protoMapPopup,				//@360 misccnstprotoMapTextPicker:			protoMapTextPicker,			//@631 p.6-74protoMultiDatePopup:		protoMultiDatePopup,		//@357 p.6-87protoNameRefDataDef:		protoNameRefDataDef,		//@240 p.6-114protoNewFolderTab:			protoNewFolderTab,			//@669 p.15-7 (formerly protoNewShowBar)protoNewSetClock:			protoNewSetClock,			//@378 p.7-44//protoNotesContent:		protoNotesContent,			//@134 misccnstprotoNumberPicker:			protoNumberPicker,			// @72 p.6-97protoNumericKeyboard:		protoNumericKeyboard,		//@376protoOrientation:			protoOrientation,			//@474 p.7-15protoOverview:				protoOverview,				//@191 p.6-104protoPasswordSlip:			protoPasswordSlip,			// @10 NOS 2.1protoPeopleDataDef:			protoPeopleDataDef,			//@231 p.6-122protoPeoplePicker:			protoPeoplePicker,			//@664 p.6-126protoPeoplePopup:			protoPeoplePopup,			//@371 p.6-127//protoPeriodicAlarmEditor:	protoPeriodicAlarmEditor,	//  @2 misccnstprotoPersonaPopup:			protoPersonaPopup,			//@497 p.18-11//protoPhoneExpando:									//     proterr1protoPhonePad:				protoPhonePad,				//@676//protoPicker:											//     proterr1//protoPictIndexer:										//     proterr1//protoPictRadioButton:									//     proterr1//protoPictureButton:									//     proterr1protoPopinPlace:			protoPopinPlace,			//@377 p.6-30protoPopupButton:			protoPopupButton,			//@386 p.6-27protoPrefsRollItem:			protoPrefsRollItem,			//@385 p.18-34protoPrinterChooserButton:	protoPrinterChooserButton,	//@153 p.2-52(comm)//protoPrintFormat:										//     proterr1protoProvincePicker:		protoProvincePicker,		//@457 p.6-54//protoRadioButton:										//     proterr1//protoRadioCluster:									//     proterr1//protoRCheckbox:										//     proterr1protoRecorderView:			protoRecorderView,			//@853 NOS 2.1//protoRecToggle:										//     proterr1//protoRecConfig:			protoRecConfig,				//@450 misccnstprotoRepeatDateDurationTextPicker:					protoRepeatDateDurationTextPicker,	// @19 p.6-64protoRepeatPicker:			protoRepeatPicker, 			//@123 p.18-47protoRepeatView:			protoRepeatView,			//@279 p.18-48protoRichInputLine:			protoRichInputLine,			//@674 p.8-67protoRichLabelInputLine:	protoRichLabelInputLine,	//@675 p.8-71//protoRoll:											//     proterr1//protoRollBrowser:										//     proterr1//protoRollItem:										//     proterr1protoRoutingFormat:			protoRoutingFormat,			//@260 p.2-27(comm)//protoRubricPopup:			protoRubricPopup,			//@435 misccnstprotoSendButton:			protoSendButton,			//@488 p.3-83(comm)protoSenderPopup:			protoSenderPopup,			// @20 p.3-38(comm)//protoSetClock:										//     proterr1//protoSlider:											//     proterr1protoSmallKeyboardButton:	protoSmallKeyboardButton,	//@624 p.8-38//protoSmartCluster:		protoSmartCluster,			// @75 misccnstprotoSoundChannel:			protoSoundChannel,			//@431 p.13-17protoSoundFrame:			protoSoundFrame,			//@849 NOS 2.1?protoSoupOverView:			protoSoupOverView,			//@460 p.6-107protoStatePicker:			protoStatePicker,			//@456 p.6-55//protoStaticText:										//     proterr1//protoStatus:											//     proterr1//protoStatusBar:										//     proterr1protoStatusBarber:			protoStatusBarber,			// @21 p.16-44protoStatusButton:			protoStatusButton,			//@470 p.16-44protoStatusCloseBox:		protoStatusCloseBox,		//@468 p.16-44protoStatusGauge:			protoStatusGauge,			//@ p.16-44protoStatusIcon:			protoStatusIcon,			//@ p.16-44protoStatusProgress:		protoStatusProgress,		//@ p.16-44protoStatusTemplate:		protoStatusTemplate,		//@467 p.16-26,p.3-23(comm)protoStatusText:			protoStatusText,			//@473 p.16-44//protoStdClosing:			protoStdClosing,			//@236 misccnstprotoStreamingEndpoint:		protoStreamingEndpoint,		//@466 p.4-27(comm)//protoTable:											//     proterr1//protoTableDef:										//     proterr1//protoTableEntry:										//     proterr1//protoTextButton:										//     proterr1//protoTextExpando:										//     proterr1//protoTextList:										//     proterr1protoTextPicker:			protoTextPicker,			//@626 p.6-58protoThumbnail:				protoThumbnail,				//@484protoThumbnailFloater:		protoThumbnailFloater,		//@481//protoTimeButton:			protoTimeButton,			//@128 misccnst//protoTimeDeltaPicker:		protoTimeDeltaPicker,		//@516 misccnstprotoTimeDeltaPopup:		protoTimeDeltaPopup,		//@517 p.6-93protoTimeDeltaTextPicker:	protoTimeDeltaTextPicker,	//@522 p.6-72protoTimeIntervalPopup:		protoTimeIntervalPopup,		//@284 p.6-94protoTimePopup:				protoTimePopup,				//@147 p.6-90protoTimeTextPicker:		protoTimeTextPicker,		//@627 p.6-68//protoTitle:											//     proterr1protoTitleText:				protoTitleText,				//@563 p.16-44protoTouchTonePad:			protoTouchTonePad,			//@677protoTransport:				protoTransport,				//@389 p.3-6(comm)protoTransportHeader:		protoTransportHeader,		//@477 p.3-77(comm)protoTransportPrefs:		protoTransportPrefs,		//@678 p.3-40(comm)protoTXView:				protoTXView,				//@826 NOS 2.1protoTXViewFinder:			protoTXViewFinder,			//@827 NOS 2.1protoUpDownScroller:		protoUpDownScroller,		//@656 p.7-8protoUSStatesTextPicker:	protoUSStatesTextPicker,	//@633 p.6-76protoWordInfo:				protoWordInfo,				//@615 misccnstprotoWordInterp:			protoWordInterp,			//@616 misccnstprotoWorldPicker:			protoWorldPicker,			//@455 p.6-56//protoYearPicker:			protoYearPicker,			//@108 misccnstprotoYearPopup:				protoYearPopup,				//@358 p.6-89ROM_DefRotateFunc:			ROM_DefRotateFunc,			//@588ROM_RCInkorText:			ROM_RCInkorText,			//@449});// End of text file protnos2.txt// Beginning of text file Project Data// Newt 3.5// Copyright 1993-2000. S. Weyer. All Rights Reserved Worldwide/*use GetFolderStr instead of SPrintObject or & (search for label,folder):2 GetFolderListselectLibrary:pickActionScript (or makeheaderitem)?*/// GLOBALconstant kNewt			:= "Newt";constant kNewtDevEnv	:= "NewtDevEnv";constant kVersionNum  	:= "3.5";constant kVersionInt	:= 35;constant kBetaVersion 	:= "k";DefineGlobalConstant('kVersionString,	kVersionNum & kBetaVersion &	(if kDebugOn then $D) &	(if kProfileOn then $P) &	(if not kIgnoreNativeKeyword then $N) &	(if kBuild20 then "-2") &	(if language<>'english then $~ & Upcase(SPrintObject(language))[0]));DefineGlobalConstant('kTitle, kNewt && kVersionString);DefineGlobalConstant('kVersion, if kDebugOn then kTitle && DateNTime(Time()) else kTitle);DefineGlobalConstant('kBuild21, kBuild20 and TRUE);Print(kVersion && DateNTime(time()));Print("newt" & kVersionInt & kBetaVersion &	(if not kIgnoreNativeKeyword then $N	else if kBuild20	then if language='English		then $2		else Upcase(SPrintObject(language))[0]	)	& ".pkg");Print(kAppSymbol);DeclareGlobalFn('DeclareGlobalFn, 2);DeclareGlobalFn('DefineGlobalConstant,2);DeclareGlobalFn('IsGlobalConstant,1);if not IsGlobalConstant('kBuild20)then DefineGlobalConstant('kBuild20,		platformVersion.platformFile = '|Newton 2.0| or		platformVersion.platformFile = '|MessagePad2.1|);	// ???if not IsGlobalConstant('kBuild1x)then DefineGlobalConstant('kBuild1x, not kBuild20);SetLocalizationFrame({ // use with LocObj(defaultStr, 'symbol)	/*notes: ...Item: and ...Title: generally appear in menus, so can be a little longer	...Msg: appear in dialogs, so can be a little longer.	...Label and other strings should be same length if possible (or shorter)	it may not make sense to translate certain acronyms (HTML, ISBN, ADSP, URL,...)?	some items have have colon or question mark appended by Newt's Cape (is this ok?)	errors: would it be possible to use a single word to indicate error, precededor succeeded by status message?	*/English: {// info buttonaboutItem: 			"About",helpItem:			"Help",prefsItem:			"Prefs",aboutText:			"Newt is an environment for developingapplications using NewtonScript,and saving as packages on your Newton.Newt is shareware \u00A9\u 1993-2000, S. Weyer.After several days of trial use, pleaseregister your copy -- tap Save for Notepadform, tap $ for Kagi, or see register.htm",noteString: 		"download, or Mac or DOS floppies?",shareRegMsg:		"Shareware Registration",newMethod:			"newMethod",newObject:			"newObject",newPage:			"newPage",new:				"new",// action menusaveItem:			"Save Source",revertItem:			"Revert",addObjItem:			"Add(Obj)",buildAppItem:		"Build(App)",duplicateItem:		"Duplicate",deleteItem:			"Delete",deleteAllitem:		"Delete All",deleteAllNotesMsg:	"Delete all Notes in folder",reloadFolderItem:	"Reload Folder",selectLibraryItem:	"Select Library",copyAllitem:		"Copy All",copySourceItem:		"Copy Source",copyAllMsg:			"Copy all [^0] sources in ^1",selectAllitem:		"Select All",writeItem:			"Write",allitem:			"All",personalMediaItem:	"Personal Media",paperbackItem:		"Paperback",folderLibItem:		"FolderLib",newtworksItem:		"NewtWorks",unfiledLabel:		"Unfiled",removePkgMsg:		"Remove Package",replacePkgMsg:		"Replace Package",existingPkgMsg:		"existing package",// Eval ControlsexprLabel:			"Expr",evalLabel:			"Eval",stopLabel:			"Stop",heapLabel:			"Heap",saveLabel:			"Save",printLabel:			"Print",//PrefsaskWordsLabel:		"Ask Words",autoLoadLabel:		"Auto Load",viewSizeLabel:		"viewSize",			//"full", "portrait" ???doConfirmLabel:		"Do Confirm",closeLabel:			"Close",			//"noConfirm", "editedConfirm", "alwaysConfirm" ??reallyQuitMsg:		"Really quit Newt?",autoHeapLabel:		"Auto Heap",heapFreqLabel:		"Heap Freq",noneItem:			"none",printRefreshLabel:	"Print Refresh",newtFontLabel:		"newtFont",versionLabel:		"Version",menuFontLabel:		"menuFont",IpaidLabel:			"I Paid",smartEditLabel:		"Smart Edit",evalLogTitle:		"Eval Log",evalControlsTitle:	"Eval Controls",pageLabel:			"Page",addLabel:			"Add",// errors/messagesnoAppMsg:			"no app",noNewtPackMsg:		"no NewtPack",slotMsg:			"existing slot",noSlotMsg:			"not a slot/method",dupNameMsg:			"duplicate name",notFoundMsg:		"not found",missingMsg:			"missing",emptyMsg:			"empty",tooLongMsg:			"too long",illegalCharMsg:		"illegal char",notAddRemoveMsg:	"not add/remove",invalSegMsg:		"invalid seg. in path expr",existingBookMsg:	"existing book",noErrMsg:			"no err msg avail",bytesMsg:			"bytes",checkingMsg:		"checking",existingSysSlotMsg:	"existing system slot",funcLineMsg:		"func not at start of line",compilingMsg:		"compiling",nameErrMsg:			"name err",screenSmallErr:		"Screen smaller than",notNeededMsg:		"not needed by",potential1xMsg:		"potential 1.x incompatibility",},});DeclareGlobalFn('AddFolder,2);if kBuild20then begin	// so we can use same names	//DefineGlobalConstant('kGetUserConfigFunc, kGetUserConfigDeprecatedFunc);	//DefineGlobalConstant('kGetDefaultStoreFunc, kGetDefaultStoreDeprecatedFunc);	DeclareGlobalFn('Query,2);	DeclareGlobalFn('ClearVBOCache, 1);	endelse begin	DeclareGlobalFn('XmitSoupChange,4);	DeclareGlobalFn('GetAppPrefs,2);	DeclareGlobalFn('AsyncConfirm,3);	DeclareGlobalFn('IsRichString,1);	DeclareGlobalFn('LSearch,5);	DeclareGlobalFn('LFetch,5);	DeclareGlobalFn('GetGlobalVar,1);	DeclareGlobalFn('AddDeferredSend,3);	DeclareGlobalFn('DefGlobalVar,2);	DeclareGlobalFn('GetUserConfig,1);	DeclareGlobalFn('SetUserConfig,2);	DeclareGlobalFn('AddDeferredCall,2);	DeclareGlobalFn('GetDefaultStore,0);	DeclareGlobalFn('IsFunction,1);	DeclareGlobalFn('KeyboardConnected, 0);	DeclareGlobalFn('IsSymbol,1);	DeclareGlobalFn('IsString,1);	DeclareGlobalFn('ArrayInsert,3);	DeclareGlobalFn('GlobalFnExists, 1);	DeclareGlobalFn('GetGlobalFn, 1);	DeclareGlobalFn('AddUndoCall, 2);	DeclareGlobalFn('AddDelayedSend, 4);	DeclareGlobalFn('EntryChangeXmit, 2);	DeclareGlobalFn('MakeEntryAlias, 1);		DeclareGlobalFn('GetPkgRef, 2);	DeclareGlobalFn('IsPackageActive, 1);	DeclareGlobalFn('GetPkgRefInfo, 1);		end;DeclareGlobalFn('CharPos,3);DeclareGlobalFn('GetFolderList,2);DeclareGlobalFn('RemoveAppFolders, 1);DeclareGlobalFn('RemoveFolder,2);DeclareGlobalFn('BookAvailable,2);DeclareGlobalFn('SafeRemovePackage,1);DeclareGlobalFn('InetGetErrorString, 1);constant screenhtdiff := 0; // for testing different screen heights(100 vs. 110) in newtView:viewSetupFormScriptconstant kAppWidth  := 240;constant kAppHeight := 240;constant cr := "\n";constant cr2 := "\n\n";// aboutNewtDefineGlobalConstant('kAboutText, LocObj("Newt is an environment for developingapplications using NewtonScript,and saving as packages on your Newton.Newt is shareware \u00A9\u 1993-2000, S. Weyer.After several days of trial use, pleaseregister your copy -- tap Save for Notepadform, tap $ for Kagi, or see register.htm", 'aboutText) &"Steve Weyer17 Timber Knoll Dr.Washington Crossing, PA 18977-1052Internet: <A HREF=\"mailto:weyer@kagi.com\">weyer@kagi.com</A>AOL, CIS: SteveWeyer<A HREF=\"http://members.bellatlantic.net/~sweyer/newton/index.htm\">http://members.bellatlantic.net/~sweyer/newton/index.htm</A>");DefineGlobalConstant('kNoteString,LocObj("download, or Mac or DOS floppies?", 'noteString));DefineGlobalConstant('kRegistrationText,"Registration: ^0" & cr & // version"Date: ^1" & cr2 & // today's date"To:" & cr &"^2" & cr2 &  // kAuthor"From:" & cr &"^3" & cr &   // name"^4" & cr &   // company"^5 "& cr &   // address"^6" & cr &   // city,zip"^7" & cr2 &  // country"^8" & cr2 &  // kNoteString"Email:" & cr &"$45 enclosed." & cr &"Comments:");constant ksig				:= ":TKnollSys";//constant kPackageName		:= "NewtDevEnv:TKnollSys";constant kPackageStr		:= "|NewtDevEnv:TKnollSys|";//DefineGlobalConstant ('kAppSymbol,intern(kPackageName));//constant kRUNewtSymbol	:= '|RunNewtRun:TKnollSys|;constant kSlurpeeSymbol		:= '|Slurpee:TKnollSys|;constant kSloupSymbol		:= '|Sloup:TKnollSys|;DefineGlobalConstant ('kAppObject,[kNewt, "Newts"]);constant kBookReaderSymbol	:= 'Copperfield;constant kKbdSymbol			:= 'alphaKeyboard;constant kNTKsymbol			:= 'newToolsPro;constant kExtrasSymbol		:= 'extrasDrawer;constant kNotesName 		:= ROM_paperrollsoupname;constant newtSoupName 		:= ROM_paperrollsoupname;constant kNotesSym 			:= 'paperroll;/*DefineGlobalConstant('kPersonalMedia, 	LocObj("Personal Media", 'personalMediaLabel));constant kPMSoupName 		:= "DocDir:Gaia";constant kPersonalMediaSym	:= '|Personal Media:Gaia|;*/constant kPaperbackSlot		:= 'PaperbackVers;DefineGlobalConstant('kPaperbackName, 	LocObj("Paperback", 'paperbackLabel));DefineGlobalConstant('kFolderLib,		LocObj("FolderLib", 'folderLibLabel));DefineGlobalConstant('kUnfiled,			LocObj("Unfiled",	'unfiledLabel));DefineGlobalConstant('kNewtWorksName,	LocObj("NewtWorks", 'newtworksLabel));DefineGlobalConstant('kNewtWorksSoupName, "NewtWorks");	// !!!i. unchangingconstant kNewtWorksSym		:= 'NewtWorks;//constant kNewtsCapeSymbol	:= '|Newtscape:Newtscape|; // defined in protoAboutTextconstant kRegistrationPackage := '|Register:FlaSheridn|;constant kSharewareFee := 45.00;DefineGlobalConstant('kRegFrame,	{package: kAppSymbol, 	price:	 kSharewareFee,	platform: 'Newton, 	Version:  kVersionString,	notes:	 kNoteString,	});// info buttonconstant kAboutItem := 0;constant kHelpItem	:= 1;constant kPrefsItem := 2;// more Globalsconstant scrollLines := 8;     // for paraconstant kPopLeft := 10;constant kPopLineHeight := 13; // for popup//constant lpMax := 23; // number of lines in labelPicker-1constant kDragRadius := 5;constant sysSoupName :=  ROM_systemsoupname;constant eArray := '[]; // an empty array  (readonly)constant eString := ""; // an empty string (readonly)constant eFrame := '{}; // an empty frame  (readonly)constant nilString := "NIL";constant lf := "\u000A";DefineGlobalConstant('crlf, unicodeCR & unicodeLF);constant crfunc    := "\nfunc("; // for validTest: source is a  method?constant crfuncsp  := "\nfunc (";// for validTest: source is a  method?constant crfuncnat := "\nfunc native";// for validTest: source is a  method?constant crbrace   := "\n{";     // for validTest: source is an object?constant crdot     := "\n.";     // for validTest: source is a  page?constant crspdot   := "\n .";    // for validTest: (page from a BookMaker book)constant crcomment := "\n//";constant comment   := "//";      // a tea?DefineGlobalConstant('kStartDefs, [crbrace,crfunc,crfuncsp,crfuncnat,crdot,crspdot]);DefineGlobalConstant('kStartFunc, [crfunc,crfuncsp,crfuncnat]);DefineGlobalConstant('kRemovePackage,	LocObj("Remove Package",	'removePkgMsg)  & ":\n");DefineGlobalConstant('kReplacePackage,	LocObj("Replace Package", 	'replacePkgMsg) & ":\n");DefineGlobalConstant('knewMethod, $# & LocObj("newMethod", 	'newMethod));DefineGlobalConstant('knewObject, $# & LocObj("newObject", 	'newObject));DefineGlobalConstant('knewPage,   $# & LocObj("newPage",	'newPage));DefineGlobalConstant('defNewSym,  $# & LocObj("new", 'new));DefineGlobalConstant('templateSources, [{item: knewMethod, source: knewMethod & "\nfunc()\nbegin\n\nend"},{item: knewObject, source: knewObject & "\n{_proto: protoXXX,\nviewBounds: ,\n\n}"},{item: knewPage,   source: knewPage   & "\n.subject 1\nHeading\n.story\ntext"},'pickSeparator,]);DefineGlobalConstant('newArray,		templateSources);DefineGlobalConstant('defObjEntry,	templateSources[1]);DefineGlobalConstant('defObjSym, knewObject); // ="#newObject"DefineGlobalConstant('kTemplateOffset, Length(templateSources));constant lparen :=  "(";constant rparen :=  ")";constant commaSp := ", ";constant commaCr := ",\n";constant plusStr := "+";constant dotStr :=  ".";constant dotTilda:= ".~";constant tilda :=   "~";constant semiSp :=  "; ";constant vertBar := "|";constant quoteStr := "\"";DefineGlobalConstant('kPrintTitle,	LocObj("Eval Log", 'evalLogTitle));DefineGlobalConstant('kEvalTitle,	LocObj("Eval Controls", 'evalControlsTitle));DefineGlobalConstant('kPrefsTitle,	kNewt && LocObj("Prefs", 'prefsItem));DefineGlobalConstant('kAboutTitle, 	LocObj("About", 'aboutItem) && kTitle);DefineGlobalConstant('kHeap,		LocObj("Heap", 'heapLabel));DefineGlobalConstant('kSave,		LocObj("Save", 'saveLabel));DefineGlobalConstant('kEval,		LocObj("Eval", 'evalLabel));DefineGlobalConstant('kPage,		LocObj("Page", 'pageLabel));DefineGlobalConstant('kDeleteAll,	LocObj("Delete All", 'deleteAllitem) & "É");DefineGlobalConstant('kCopyAll,		LocObj("Copy All", 'copyAllitem) & "É");constant noteLeft		:=  10;constant noteTop		:=   2;constant noteWidth		:= 226;constant noteHeight		:= 265;constant evalHeight		:=  30; // height of 2 linesconstant kPrintSpacing	:=  12;	// viewlinespacing in EvalLog, Aboutconstant kEditSpacing	:=  16; // viewlinespacing in editorconstant kNewtFont	:= userFont10;DefineGlobalConstant('kTabs,[10,20,30,40,50,60,70,80,90,100,]); // only up to 8 supported?constant errSound	:= ROM_plinkbeep;constant keyboardIcon := ROM_keybuttbitmap;DefineGlobalConstant ('pgb1, [0, 0,206, 14]);DefineGlobalConstant ('pgb2, [0,16,206,214]);constant kdeepStart := "<<";constant kdeepEnd   := ">>";constant kdeepLen   := $#; //"len=";constant printIndent:= "   ";constant slotSep    := ": ";constant allsym     := '_all;constant slash      := $/;DefineGlobalConstant('noAppErr,		LocObj("no app", 'noAppMsg));DefineGlobalConstant('noSaveErr,	LocObj("no NewtPack", 'noNewtPackMsg));DefineGlobalConstant('slotErr,		LocObj("existing slot", 'slotMsg));DefineGlobalConstant('noSlotErr,	LocObj("not a slot/method", 'noSlotMsg));DefineGlobalConstant('dupName,		LocObj("duplicate name", 'dupNameMsg));DefineGlobalConstant('notFoundErr,	LocObj("not found", 'notFoundMsg));constant subLeft    :=  4;  // left offset of Print,Aboutconstant aboutTop   := 18;  // top offset of Aboutconstant subTop     := 27; // top of Edit,Printconstant subRight   := -4;  // right offset of Print,Aboutconstant subBottom  := -22; // bottom offset of Print,AboutDefineGlobalConstant ('sourcePath,'[pathExpr: data,0,text]);DefineGlobalConstant ('stylePath, '[pathExpr: data,0,styles]);constant kFakeParent := '_MyParent_;DefineGlobalConstant('kAppendList, func(a1,a2) // since AppendList not official	if a1	then ArrayMunger(a1,Length(a1),0, a2,0,nil)	else a2);// GLOBAL functionsDefineGlobalConstant('kRoundTo, func(val,grid,fn) // used in knewBounds, drawView:viewGestureScriptif grid then call Functions.(fn) with (val/grid)*grid else val); // e.g. Floor, RIntToLDefineGlobalConstant('kMakeFace, func(font,face)	// !!!dif isFrame(font)	then begin	local bfont := Clone(font);	bfont.face := Bor(font.face, if face=tsBold then kFaceBold else kFaceItalic);	bfont;	endelse Bor(font,face));DefineGlobalConstant('kSourceStyles, func(slotSource,slotLen,font) // used in saveNote, editCodebegin	if not slotLen	then slotLen :=		if kBuild20		then CharPos(slotSource, unicodeCR, 0)		else StrPos (slotSource, cr, 0);	if not slotLen then slotLen := 0;	[slotLen, call kMakeFace with (font,tsBold), StrLen(slotSource) - slotLen, font];	// !!!dend);//DefineGlobalConstant('kNilFunc,func() nil);DefineGlobalConstant('kNilFunc1,func(x) nil); 	// used for newtAlphaKeyboard, helpbook.viewClickScript//DefineGlobalConstant('kTrueFunc1,func(x) true); 	// used as validTest: predDefineGlobalConstant('kScrollUp,  func() para:scroll(0,scrollLines)); // evalLog, newtViewDefineGlobalConstant('kScrollDown,func() para:scroll(0,-scrollLines));DefineGlobalConstant('kNewBounds, func(view,loffset,toffset,roffset,boffset,xgrid,ygrid)begin	local vb := view.viewBounds;	RelBounds(		if loffset<0 then vb.left+vb.right +loffset else loffset, // - for evalControls		if toffset<0 then vb.top +vb.bottom+toffset else toffset,		call kRoundTo with (			if loffset<0  // was: if roffset>0			then roffset-loffset			else vb.right+roffset-vb.left-loffset,			xgrid,'Floor),		call kRoundTo with (			if toffset<0 // was: if boffset>0			then boffset-toffset			else vb.bottom+boffset-vb.top-toffset,			ygrid,'Floor)		);end);DefineGlobalConstant('kStrPosAny, func NATIVE (str, ARRAY astrs, INT start, minp)if kIgnoreNativeKeywordthen begin // regular version		local pos, mpos, astr;		foreach astr in astrs		do if pos := StrPos(str,astr,start)			then if minp				then (if (not mpos) or pos < mpos then mpos := pos)				else return pos;		mpos;	endelse begin // NATIVE version		local pos, mpos;		//local astr;		//foreach astr in astrs		local int apos;		for apos:=0 to Length(astrs)-1		do if pos := StrPos(str,astrs[apos],start)			then if minp				then (if (not mpos) or pos < mpos then mpos := pos)				else return pos;		mpos;	end);DefineGlobalConstant('kSubStr, func(str, pos, upto) // upto = str or NIL. #160begin	if isFrame(str) then str := str.(sourcePath);	local pos2 := if (if kBuild20 then IsString(upto) else isInstance(upto,'string))		then if kBuild20 and StrLen(upto)=1			then CharPos(str, upto[0], pos)			else StrPos (str, upto, pos)		else if isArray(upto)		then call kStrPosAny with (str, upto, pos, true)		else upto;	SubStr(str, pos, if pos2 then pos2-pos); // (if pos2 then pos2 else StrLen(str)) - posend);DefineGlobalConstant('kCheckSymbol, func NATIVE (str, INT start, INT stop)  // returns error string or NILbegin // used by saveMethodCode, printObject	local INT i;	local ch, kisAlphaNumeric := if kBuild20 then GetGlobalFn('isAlphaNumeric) else Functions.isAlphaNumeric;	for i := start to stop-1	do if not // allow initial digits. check alphanum first			//((ch := str[i]) = $_ or (call kisAlphaNumeric with (ch) and (i>start or ch>=$A)))			(call kisAlphaNumeric with (ch := str[i]) or ch = $_)      then return ch;end);DefineGlobalConstant('kFixDigitName, func(str)	// eliminate numeric prefix in :doObjbegin	local ch, del := 0, i;	for i:=0 to StrLen(str)-1	do if (ch := str[i]) <= $9 and $0 <= ch		then del := del+1		else break;	if del > 0	then StrMunger(str,0,del, nil,0,nil)	else str;end);DefineGlobalConstant('kMakeSourceEntry, func(sources, soupEntry, title, cursor, defCursor) // #162	// given a soup entry, return a cache entry for userSources	begin // used by collectEntries, saveNote		local entry := {			item:	title,			_alias: if kBuild20					then MakeEntryAlias(soupEntry)					else EntryUniqueId(soupEntry),			};		AddArraySlot(sources,entry);		if kBuild20		then return true		else if cursor<>defCursor		then entry.cursor := cursor		else if SetContains(GetStores(),EntryStore(soupEntry)) <> defCursor		then begin			if kBuild1x and Functions.BroadcastSoupChange exists			then BroadcastSoupChange(newtSoupName)			else XmitSoupChange(newtSoupName, kAppSymbol, 'whatThe, NIL);			return NIL;			end;		true; // for saveNote	end);/*DefineGlobalConstant('PerformVals, func(f,msg,aparams) // iterate over list of paramsbegin // e.g., :PerformVals(self,'removeNewt,clone(all_Newts))   local val;   foreach val in aparams   do Perform(f,msg,if isArray(val) then val else [val]);end);*//*DefineGlobalConstant('GetDateStringSpec, func(elemArray)	begin		local spec := 0, val;		foreach val in elemArray do			spec := spec<<kElementShift + val[1]<<kElementTypeWidth + val[0];		spec;	end);DefineGlobalConstant('shortDateStrSpec, call GetDateStringSpec with ([ [kElementMonth,  kFormatNumericDate], [kElementDay, kFormatNumericDate], [kElementYear, kFormatNumericDate], ]));*/constant shortDateStrSpec := 112220; // for ShortDateStr, e.g., 11/29/93// these defined in proterr1.txt//constant kExpSymbol	:= "exp. symbol";//constant kExpFrame	:= "exp. frame";//constant kExpString	:= "exp. string";// some specific errors (these actually take more space, but in pkg rather than heap?)DefineGlobalConstant('kSharewareErr, 	[LocObj("Shareware Registration", 'shareRegMsg), notFoundErr]); // money button in AboutDefineGlobalConstant('kFixFrameMissing,	['fixFrame, LocObj("missing", 'missingMsg)]);DefineGlobalConstant('kFixFrameExp, 	['fixFrame, "exp. frame, sym or num"]);DefineGlobalConstant('kAddSlotExp, 		['addSlot, kExpSymbol]);DefineGlobalConstant('kAddAppExp, 		['addApp, kExpFrame]);DefineGlobalConstant('kSaveAppErr, 		['saveApp, noAppErr]);DefineGlobalConstant('kAddStepExpSym, 	['addStep, kExpSymbol]);DefineGlobalConstant('kAddStepExpFrm, 	['addStep, kExpFrame]);DefineGlobalConstant('kRemoveSlotErr, 	['removeSlot, noSlotErr]);DefineGlobalConstant('kRemoveAppErr, 	['removeApp, noAppErr]);DefineGlobalConstant('kRunMethodErr, 	['run_method, noSlotErr]);DefineGlobalConstant('kFieldErr, 		['field, notFoundErr]);DefineGlobalConstant('kResourceErr, 	['resource, notFoundErr]);DefineGlobalConstant('kResourceExp, 	['resource, kExpString]);DefineGlobalConstant('kSoupErr, 		['soup, notFoundErr]);DefineGlobalConstant('kRemoveStepChild,['removeStep, "child not removed"]);DefineGlobalConstant('kRemoveStepErr, 	['removeStep, noSlotErr]);DefineGlobalConstant('kPathSeps, 		[plusStr, dotStr]);DefineGlobalConstant ('kPagePath,'[pathExpr: rendering,0,pages]);DefineGlobalConstant ('kHintPath,'[pathExpr: rendering,0,contents,0]);DefineGlobalConstant ('kTemplatePath,'[pathExpr: templates,0]);DefineGlobalConstant ('kTOCPath,'[pathExpr: browsers,0,list]);DefineGlobalConstant('kBookOpen, func()	if Length(book.contents) > 0	then GetRoot().(kBookReaderSymbol):openBook(isbn));DefineGlobalConstant('kLFetch, func(ARRAY a, item, INT start, test, path)begin // like limited LFetch for 1.x. if path=nil, use ArrayPos directly	local entry, val;	foreach entry in a	do if (val := entry.(path)) and call test with (item, val)	then return entry;	NIL;end);// same as Newt's CapeDefineGlobalConstant('kFindBook, func(isbn,libentry) // used by addApp, removeApp, addViewbegin	local viewer := GetRoot().(kBookReaderSymbol), nos20 := kBuild20 or HasVariable(viewer,'getLibraryEntry);	local libook := viewer:whereIsBook(isbn);	if (kBuild20 or nos20) and libook and		(not isFrame(libook.bookSoup)									// <bad pkg ref>		or not try libook.bookSoup.book onexception |evt.ex| do NIL)	// *** evt.ex.fr ***	then begin // see kBookCleanup		RemoveSlot(viewer.library, Intern(isbn)); // NOS 2.x bug. badly removed help book?		libook := NIL;		end;	// don't bother with thawing	if libook	then if libentry		then if kBuild20 or nos20			then libook.library			else begin				if viewer.library				then call kLFetch with (viewer.library.books, isbn, 0, Functions.StrEqual, 'isbn, nil);				end		else if libook.bookSoup and			(not nos20 or not libook.library or libook.library.bookPresent>0 or libook.bookSoup.help)		then libook.bookSoup.book;end);// used by addApp, removePackage, buildFolderLib (declareUnit?)DefineGlobalConstant('kFindPkg, func(pkgname,retpkg) // !!!b. same name as Newt's Cape, but extra argif kBuild20then begin	local store, pkg;	foreach store in GetStores()	do  if pkg := GetPkgRef(pkgname, store)			// active?		then return if retpkg then pkg else TRUE;	// pkg if binary obj rather than frame	NIL;	endelse begin	local pkg := call kLFetch with (GetPackages(), pkgname, 0, Functions.StrEqual, 'title); // no nil final arg	if pkg	then if retpkg then pkg else TRUE;	end);/*DefineGlobalConstant('kFindPkg, func(str,retpkg)begin	local pkg :=       	if kBuild20       	then LFetch(GetPackages(), str, 0, '|str=|, 'title)		else call kLFetch with (GetPackages(), str, 0, Functions.StrEqual, 'title);	if retpkg	then pkg	else if pkg	then TRUE;end);*/DefineGlobalConstant('kPrintStr, func(str, val) // used by printObjectif (if kBuild20 then IsString(str) else isInstance(str,'string))then StrMunger(str,StrLen(str),0, if val=unicodeCR then cr else val,0,nil)else begin	if val=unicodeCR	then val := crlf	else if (if kBuild20 then CharPos(val, unicodeCR, 0) else StrPos(val, cr, 0))	then StrReplace(val:=Clone(val), cr, crlf, nil);	str:Output(val,nil);	if not HasVariable(str, 'firstLineSpec) 	// !!!c	then str:FlushOutput();		// older Sloup. eventually remove this...	end);DefineGlobalConstant('kQuoteStr, func(str,qstr) // used by printObject	begin		if StrPos(str, qstr, 0)		then StrReplace(str := Clone(str), qstr, $\\ & qstr, nil);		qstr & str & qstr;	end);DefineGlobalConstant('kNewtPrintFunction, func(val)	begin		local newt := GetRoot().(kAppSymbol), prefs := newt.prefsCurrent;		newt:printVal(val, printDepth, true, nil,			if prefs then prefs.printRefresh,			if prefs then prefs.print,			unicodeCR);	end);DefineGlobalConstant('kNewtWriteFunction, func(val)	begin		local newt := GetRoot().(kAppSymbol), prefs := newt.prefsCurrent;		newt:printVal(val,printdepth,nil,nil,			if prefs then prefs.printRefresh,			if prefs then prefs.print,			"");	end);DefineGlobalConstant('kNewtNotifyMethod, func(num,v1,v2)	GetRoot().(kAppSymbol):Notify(num,v1,v2));/*DefineGlobalConstant('kSubSeq, func(a,start,count) // like SubStr for array	ArrayMunger([],0,nil,a,start,count));*//*  readonly error!?DefineGlobalConstant('kCheckPath, func NATIVE (slotstr) // use this from saveMethodCode. return string(err) or #	begin		local INT pos1 := sub := 0, pos2, epos := call Functions.StrLen with (slotstr);		local ch, dpos, ppos;      		// check (subparts of) slotstr name		repeat begin			ppos := if kBuild20 then CharPos(slotstr, $+, pos1)				else StrPos(slotstr, plusStr, pos1); // kStrPosAny ... kPathSeps			dpos := if kBuild20 then CharPos(slotstr, $., pos1)				else StrPos(slotstr, dotStr,  pos1);			pos2 :=				if dpos or ppos				then begin					sub := sub+1;					if dpos					then if ppos and ppos < dpos then ppos else dpos					else ppos;					end				else if sub > 0 and slotstr[epos-1] = $~				then epos := epos-1				else epos;      			if pos1 = pos2			then return LocObj("empty", 'emptyMsg)			else if (pos2 - pos1) > 254			then return LocObj("too long", 'tooLongMsg)			else if ch := call kCheckSymbol with (slotstr,pos1,pos2)			then return LocObj("illegal char", 'illegalCharMsg) & $: && ch;      			end until (pos1 := pos2+1) > epos;		sub;	end);*/DefineGlobalConstant('kFolderList, func(lab) // if lab=nil, return frame/arraybegin	local folders;	if kBuild20 or Functions.GetFolderList exists	then begin // 2.0 CheckThatFolderExists(prefsEntry) buggy on 2.0			folders := call Functions.GetFolderList with (kNotesSym, nil); // array			if lab			then SetContains(folders,lab)			else folders;		end	else begin // 1.x		folders := call kGetUserConfigFunc with ('userFolders); // frame		if lab		then HasSlot(folders, lab)		else folders;		end;end);DefineGlobalConstant('kAppendPickList, func(a1,a2,field) // added field. selectLibrary, pickActionScriptArrayMunger(a1,Length(a1),0, Sort(a2,'|str<|,field),0,nil));DefineGlobalConstant('kMakeHeaderItem, func(str,str2) // selectLibrary, pickActionScript, buildFolderLibbegin	constant dashes := "--";	if str2	then str := str & $: & str2;	{item: dashes & str & dashes,	pickable: NIL,	};end);DefineGlobalConstant('kGetHandlesFunc, func(docHandle, ARRAY items, docClass) // for Personal Media blotters,docsbegin /* 	docHandle	store or blotter	items		array	docClass	'pt_protoBlotter, 'pt_protoTextDoc, 'pt_protoEditPad*/	local docMngr := GetRoot().(kPersonalMediaSym).pt_clDocMngr;	local pmnew := docMngr.version;	local flstuff := // used in RQuery and GetChildren		if pmnew		then '{none: [tagClDocMngrRecycled]}	// >= 2.1		else func(fl) BAND(fl,1)=0;  			// 1.55,2.0	local docHandles :=		if docClass = 'pt_protoBlotter		then begin			local args := [docHandle, docClass, flstuff, nil];			if pmnew then AddArraySlot(args, nil);			Perform(docMngr:new(kPMSoupName), 'RQuery, args); 	// get blotters for store			end		else docHandle:GetChildren(docClass, flstuff, nil);	// get docs for blotter	if pmnew	then begin // cursor based. >= 2.1		docHandle := docHandles:entry();		while docHandle		do begin			AddArraySlot(items,				{item: docHandle:GetTitle(), docHandle: docHandle});			docHandle := docHandles:next();			end;		end	else if isArray(docHandles)	then foreach docHandle in docHandles		do AddArraySlot(items,			{item: docHandle.title, docHandle: docHandle});	items;end);constant kConstant 		:= 'constants; // for protoDictconstant kProto	   		:= 'protos;    // for errorCodesconstant kProtoDict		:= '|protErr1:TKnollSys|;constant kProtoDict2	:= '|protNOS2:TKnollSys|;constant kErrorCodes	:= 'errorCodes;constant kInstalled		:= 'installed;constant kEvalContextSym := 'getEvalContext;DefineGlobalConstant('kEvalContextFunc, func()begin	local evalContext, evalTemp, fr;	local gData :=		if kBuild1x and Functions.GetGlobals exists		then GetGlobals().(kAppSymbol)		else GetGlobalVar(kAppSymbol);	evalContext := evalTemp := {_parent: GetRoot()};	// e.g., protoDict, ViewCnst, PlatFunc	foreach fr in gData.(kConstant)	do evalTemp := evalTemp._parent :=		{_parent: evalTemp._parent, _proto: fr};	evalContext;end);DefineGlobalConstant('kIsNewtObj, func(slotSource) // used by matchNewtEntry, kNewtWorksDoItFuncbegin	local spos;	if (if kBuild20		then isString(slotSource) and			not IsRichString(slotSource) and			spos := CharPos(slotSource, unicodeCR, 0)		else isInstance(slotSource, 'string) and			spos := StrPos(slotSource, cr, 0)) and		spos > 0 and		slotSource[0] <> $< and //not BeginsWith(slotSource, "<") and // non-empty, possible HTML?		call kStrPosAny with (slotSource, kStartDefs, spos, NIL)	then slotSource;end);// ----------// NotesDefineGlobalConstant('kNotesGetHighlightedText, func(target)if HiliteOwner() and target = GetVariable(HiliteOwner(), 'realData) and GetHiliteOffsets()then begin	local ARRAY offset := GetHiliteOffsets()[0];	local start := offset[1];	if start	then SubStr(offset[0].realData.text, start, offset[2]-start);	end);DefineGlobalConstant('kNotesGetTitle, func(target)// for GetTitle slot of routeframeif targetthen begin	local str := call kNotesGetHighlightedText with (target);	if str	then kNewtDevEnv & $: & LocObj("Eval", 'evalLabel)	else if GetRoot().(kAppSymbol):matchNewtEntry(target)	then kNewtDevEnv & $: & LocObj("Add", 'addLabel);	end);DefineGlobalConstant('kNewtDoitFunc, func(str)begin	local newt := GetRoot().(kAppSymbol);	newt:open();	if kBuild1x and Functions.AddDeferredAction exists	then AddDeferredAction(		Functions.Perform, [newt, 'readEvalPrintContext, [str, nil]])	else AddDeferredSend(newt, 'readEvalPrintContext, [str, nil]);end);DefineGlobalConstant('kNotesRouteScript, func(target,targetView)begin // for RouteScript slot of routeframe	local str := call kNotesGetHighlightedText with (target);	if str	then call kNewtDoitFunc with (str)	else begin		local newt := GetRoot().(kAppSymbol);		newt:open();		newt.startFolder := target.labels;		if kBuild1x and Functions.AddDeferredAction exists		then AddDeferredAction(			Functions.Perform, [newt, 'addObj, [target,newt]])		else AddDeferredSend(newt, 'addObj, [target,newt]);		end;end);constant kNewtRouteScriptSym := 'NewtDevRouteScript;DefineGlobalConstant('kNotesRouteItem, { // for routeScript array (GetRouteScripts)GetTitle: 			kNotesGetTitle,//icon:				call kGetResource with (...),tag:				kAppSymbol,routeScript:		kNotesRouteScript,});DefineGlobalConstant('kNotesProtoItem, { // for Notes _proto chainGetRouteScripts:	func(targetInfo)begin	local routes := [kNotesRouteItem], oldRoutes;	if oldRoutes := inherited:?GetRouteScripts(targetInfo)	then routes := SetUnion(routes, oldRoutes, true);	SetUnion(routes, routeScripts, true);end});// ----------DefineGlobalConstant ('kAddPatchFunc, func(target, template)if targetthen begin	// init the patch	local patch := EnsureInternal({}), sym, val;	// copy all of the patched slots (including tag)	foreach sym, val in template	do patch.(EnsureInternal(sym)) := val;	patch.(EnsureInternal('tag)) := EnsureInternal(kAppSymbol);	// link into the target's proto chain	patch.(EnsureInternal('_proto)) := target._proto;	target._proto := patch; // returns patch	end);DefineGlobalConstant('kRemovePatchFunc, func(target)begin	local nextProto;	if target	then while nextProto := target._proto	do  if nextProto.tag = kAppSymbol		then break target._proto := nextProto._proto		else target := nextProto;end);// ----------// NewtWorksDefineGlobalConstant('kNewtWorksDoItFunc, func(viewDefView, newtAppBase)	// newtAppBase is unusedbegin	// check if anything is selected	local range := viewDefView:GetHiliteRange(), source;	// if nothing is selected, treat it as 'Select All'	if range.first = range.last	then begin	  	range.first := 0 ;	  	range.last 	:= viewDefView:GetCountCharacters() ;		end;	local source := viewDefView:GetRangeData(range, 'text);	local newt := GetRoot().(kAppSymbol);	newt:open();	AddDeferredSend(newt, 'newtText,		[if call kIsNewtObj with (source) then 'obj else 'expr, source, source]);end);DefineGlobalConstant('kToolFrame,	{ // see Rot13 exampledataTypeSymbol: 'paper,		// REQUIRED: ('paper for word processor; 'drawPaper for drawing app)item: 			kNewtDevEnv,// REQUIRED: appears in popup in tool picker.keyCommand: {				// optional	char:		$1,			// cmd-!	showchar:	$!,	modifiers:	if kBuild20 then kCommandModifier,	//1 << 25	keyMessage:	'DoNewtDevEnv,	keyFn:		func(viewDefView)					call kNewtWorksDoItFunc with (viewDefView, nil),	// newtAppBase is unused	name:		kNewtDevEnv,	category:	"General",	},// REQUIRED: called when user selects the item in the Tools pickercmdFunc:	kNewtWorksDoItFunc,});DefineGlobalConstant('bline, "\n-----");DefineGlobalConstant('eline, "-----\n");DefineGlobalConstant('kMargin32,	SetBounds(32, 32, 32, 32)); // !!!gif kBuild21then DefineGlobalConstant('kDummyTx, {	// !!!g. from Newt's Cape	_proto: protoTxView,	viewBounds: SetBounds(0,0,0,0),	viewFlags: 0,	ReorientToScreen: ROM_DefRotateFunc,	viewSetupFormScript: func()	begin		inherited:?viewSetupFormScript();		:SetGeometry(nil, 0, 0, kMargin32); // how to wrap long lines?		:SetStore(GetDefaultStore());	end,});if kBuild21then DefineGlobalConstant('kVBOFlush, 20*1024); // !!!gif kBuild21then DefineGlobalConstant('kNewVBO, func(store, cl, dlen)	// the recommended initializationbegin	gc();	local data := if not IsInteger(dlen) then dlen;		// string or binary obj	local vbo :=		(if store then store else GetDefaultStore()):NewCompressedVBO(			if cl then cl else 'string,			// cl == binary			if data then Length(data) else dlen,// length of string or binary or #			kTextCompander, 					//kBitmapCompander unreliable for bin?			nil);	if data	then begin		BinaryMunger(vbo, 0, nil, data, 0, nil);		if Length(data) > 2		then ClearVBOCache(vbo);		end;	vbo;end);if kBuild21then DefineGlobalConstant('kNewtWorksChunkSize, 2048);	// !!!gif kBuild21then DefineGlobalConstant('kNewtWorksGetDoc, func(entry)	// !!!g. from Newt's Capebegin	local textView := BuildContext(kDummyTx);	textView:Open();	textView:Internalize(entry.saveData);	// kCopyNewtWorksRange, func(textView, range, cleanup)	local INT start := 0, last := textView:GetCountCharacters();    local INT i, nextFlush := kVBOFlush, slen := 0;	local cstr, str := call kNewVBO with (nil, nil, "");	for i := start to last by kNewtWorksChunkSize    do begin		cstr := StringFilter( // strip out graphics characters					textView:GetRangeData(						{first: i, 						last: min(last, i + kNewtWorksChunkSize),						}, 'text),					"\u2206\u", 'rejectAll);		StrMunger(str, slen, 0,	cstr, 0, nil);	// !!!b. was i,nil		slen := slen + StrLen(cstr);		if (slen*2) >= nextFlush		then begin			ClearVBOCache(str);			nextFlush := nextFlush + kVBOFlush;			end;		end;	ClearVBOCache(str);	textView:close();	str;end);DefineGlobalConstant('kFixedFont, 	{family: 'Courier, 		face: kFaceNormal, size: 10, });DefineGlobalConstant('kLabelEqual, func(elabel1, elabel2)	// elabel1=labelsFilter, elabel2=entry.labelselabel1 = elabel2 or elabel1 = allsym or(isArray(elabel2) and	// SuperNotepad	if elabel1	then SetContains(elabel2, elabel1)	else Length(elabel2)=0));DefineGlobalConstant('kObjectConst, func(obj)	// !!!hIsArray(obj) or IsFrame(obj) or(IsBinary(obj) and not (	if kBuild20	then IsString(obj) or IsSymbol(obj)	// !!!j	else isInstance(obj,'string) or isInstance(obj,'symbol))));DefineGlobalConstant('kEmptyGlobal, {	constants: {}, libraries: {}, protos: {},	tools: {}, views: {}, installed: {},});//INSTALL & REMOVE scriptsInstallScript := func(partFrame)begin	local app := partFrame.theForm, root := GetRoot();	local asym := EnsureInternal(kAppSymbol);	local gData, routingFrame, notes, rs;	if kBuild1x and Functions.GetGlobals exists	then begin		gData 		 := GetGlobals().(kAppSymbol);		if not gData		then GetGlobals().(asym) := gData := EnsureInternal(kEmptyGlobal);		routingFrame := GetGlobals().Routing;		routingFrame.(asym) := app.routeScripts; // !!!h. renamed/moved		end	else begin		gData 		 := GetGlobalVar(kAppSymbol);		if not gData		then DefGlobalVar(asym, gData := EnsureInternal(kEmptyGlobal));		routingFrame := GetGlobalVar('Routing);		// for Notes (below)		end;//Print(kTitle);	gData.(kInstalled).(asym)						:= kTitle;	gData.(kConstant).(EnsureInternal(kProtoDict))	:= app.(kProtoDict);	if kBuild20	then gData.(kConstant).(EnsureInternal(kProtoDict2)) := app.(kProtoDict2);	//gData.(kProto).(EnsureInternal(kErrorCodes)) 	:= app.(kErrorCodes);	//gData.(EnsureInternal(kEvalContextSym)) 		:= app.(kEvalContextSym);	if not HasSlot(Functions,'originalPrint)	then Functions.(EnsureInternal('originalPrint)) := Functions.Print;	if not HasSlot(Functions,'originalWrite)	then Functions.(EnsureInternal('originalWrite)) := Functions.Write;	if not HasSlot(root,'originalNotify)	then root.(EnsureInternal('originalNotify)) 	:= root.Notify;	if notes := root.(kNotesSym)	then if kBuild20 or isArray(rs := notes.routeScripts) // 2.x. (ok since rs not used)		then call kAddPatchFunc with (notes, kNotesProtoItem)			/*begin			rf.routeScript := kNotesRouteScript;			if isReadonly(rs) 			then rs := notes.(EnsureInternal('routeScripts)) := Clone(rs);			AddArraySlot(rs, rf);			end*/		else if isFrame(rs := routingFrame.(kNotesSym)) // 1.x		then begin			local rf := EnsureInternal({GetTitle: nil, tag: asym, routeScript: nil});			rf.GetTitle := kNotesGetTitle;			notes.(EnsureInternal(rf.routeScript := kNewtRouteScriptSym)) := kNotesRouteScript;			if isReadonly(rs)			then rs := routingFrame.(kNotesSym) := Clone(rs);			rs.(asym) := rf;			end;	if kBuild21	// eMate only?	then // returns non-NIL if successful		root.(kNewtWorksSym):?RegNewtWorksTool(EnsureInternal(kAppSymbol), kToolFrame);end;RemoveScript := func(partFrame)begin	local gData, routingFrame, notes, root := GetRoot(), rs;	if kBuild1x and Functions.GetGlobals exists	then begin		gData 		 := GetGlobals().(kAppSymbol);		routingFrame := GetGlobals().Routing;		RemoveSlot(routingFrame, kAppSymbol);	// !!!h. moved		end	else begin		gData 		 := GetGlobalVar(kAppSymbol);		routingFrame := GetGlobalVar('Routing);		end;	RemoveSlot(gData.(kConstant), kProtoDict);	RemoveSlot(gData.(kInstalled), kAppSymbol);	if kBuild20	then RemoveSlot(gData.(kConstant), kProtoDict2);	//RemoveSlot(gData.(kProto), kErrorCodes);	//RemoveSlot(gData, kEvalContextSym);	if notes := root.(kNotesSym)	then if kBuild20 or isArray(rs := notes.routeScripts) // 2.x. (ok since rs not used)		then call kRemovePatchFunc with (notes)			/*begin			if i := LSearch(rs, kAppSymbol, 0, '|=|, 'tag)			then ArrayRemoveCount(rs,i,1);			end*/		else if isFrame(rs := routingFrame.(kNotesSym)) // 1.x		then begin			RemoveSlot(rs, kAppSymbol);			RemoveSlot(notes, kNewtRouteScriptSym);			end;	if kBuild21	then root.(kNewtWorksSym):?UnRegNewtWorksTool(kAppSymbol);end;// MetaDot support. these are used in para, evalField, Print:paraDefineGlobalConstant('kMetaDotKeyFrame, { // 2.x	char: 				$.,	modifiers:			if kBuild20 then kCommandModifier+kOptionModifier,	keyMessage:			'_keyMetaDot,		name:				"Meta-.",	category:			"Editing"});DefineGlobalConstant('kMetaDotKeyFunc, func(view)	// 2.x.  _keyMetaDotMetaDot:?popupMeta(view,nil,nil) // it uses GetCaretBox() for charpos/x1/y1);DefineGlobalConstant('kMetaDotSetupFunc, func() // 2.x. for viewSetupFormScriptbegin	:?AddKeyCommand(kMetaDotKeyFrame);	//self.viewFormat := if prefsEntry.noLines then 1 else 12289;	// !!!d noLines??	inherited:?viewSetupFormScript();end);DefineGlobalConstant('kMetaDotQuitFunc, func()		// 2.x. viewQuitScriptbegin	:?ClearKeyCommands();		inherited:?viewQuitScript();end);DefineGlobalConstant('kMetaDotGestureFunc, func(unit,gestureID)	// viewGestureScriptif gestureID = aeTap and prefsCurrent.smartEdit and not GetHiliteOffsets()	// !!!dthen begin	local INT x1 := GetPoint(firstX,unit), y1 := GetPoint(firstY,unit);	if kBuild20 or nos20	then MetaDot:?popupMeta(self, x1, y1)		//AddDelayedSend(MetaDot, 'popupMeta, [self,x1,y1], MetaDot.delay)	else AddDelayedAction(Functions.Perform,		[MetaDot, 'popupMeta, [self,x1,y1]], MetaDot.delay);	NIL;	// allow default (setting caret?)	end);DefineGlobalConstant('kMetaDotPickFunc, func(i)	// pickActionScript. see MetaDot.popupMeta, pickMetaif i := :realPopIndex(i)then begin	self.originalPopList := NIL;	local newText := MetaDot:?pickMeta(self, i);	if newText	then begin		if kBuild20 or nos20		then AddUndoCall(GetGlobalFn('SetValue), [self, 'text, text]);		else AddUndoAction('setText, [text]);	// uses current context?		SetValue(self, 'text, newText);		if (if kBuild20 then IsInteger(charCaret) else isInstance(charCaret,'int))		then SetKeyView(self, charCaret);	// set in pickMeta		end;	end);	DefineGlobalConstant('kMetaDotSetEditFunc, func(newEdit)	// setEdit. 1.xbegin	local oldEdit := edited;	// from parent	edited := newEdit;			// set it (w/o updating)	oldEdit;					// return previous valend);	/*tt := GetRoot().|NewtDevEnv:TKnollSys|; nilss := GetRoot().|Sloup:TKnollSys|; nilbreakonthrows := truestacktrace()exitbreakloop()breakonthrows := nilgetroot().|NewtDevEnv:TKnollSys|.unitsmapgetroot().|NewtDevEnv:TKnollSys|.unitsimportgetpkgrefinfo(getpkgref("MooUser:Newt", GetStores()[1]))getpkgrefinfo(objectpkgref(getpkgrefinfo(getpkgref("MooUnit:Newt", GetStores()[1])).parts[0]._ExportTable[0].objects[1]))getroot().|NewtDevEnv:TKnollSys|.myapp._package._ImportTablegetpkgrefinfo(getpkgref("LS1 Libs 2.1Bc306", GetStores()[1])).partslunit := getpkgrefinfo(objectpkgref(getglobals().|newtdevenv:tknollsys|.constants.lunaobj.protolocation));lunit.parts[1]._exporttable[0].objects*/// End of text file Project Data// Beginning of file myProtoInfoButton// Before Script for _v76_0DefConst('kFixupInfoItems, func(template)begin	local items := template.AppInfoItems := [];	if HasSlot(template, 'DoInfoAbout)	then AddArraySlot(items, LocObj("About", 'aboutItem));	if HasSlot(template, 'DoInfoHelp)	then AddArraySlot(items, LocObj("Help", 'helpItem));	if HasSlot(template, 'DoInfoPrefs)	then AddArraySlot(items, LocObj("Prefs", 'prefsItem));	local auxItems := template:?GenInfoAuxItems();	if isArray(auxItems) and Length(auxItems) > 0		and HasSlot(template,'DoInfoAux)	then begin		AddArraySlot(items, 'pickSeparator);		template.AuxOffset := Length(items);		ArrayMunger(			items, Length(items), 0,			auxItems, 0, nil);		end;end)_v76_0 :=    {icon: GetPictAsBits("info icon", nil),     viewBounds: {left: 6, top: 0, right: 19, bottom: 13},     viewFlags: 513,     viewFormat: 67109457,     viewJustify: 17446,     viewClickScript:       func(unit)       if :TrackHilite(unit)       then if kBuild20 or HasVariable(:Parent(),'PopupMenu)       	then :PopupMenu(AppInfoItems, {left: 0, top: 0})       	else begin       		local l := :LocalBox();       		DoPopUp(AppInfoItems, l.right+3, l.top, self);       		end,     pickActionScript:       func(index)       begin       	// MUST do this       	:Hilite(nil);              	if auxOffset and index >= auxOffset       	then :DoInfoAux(:GenInfoAuxItems(), index - auxOffset)       	else Perform(self, '{       		About:	DoInfoAbout,       		Help:	DoInfoHelp,       		Prefs:	DoInfoPrefs}.(Intern(AppInfoItems[index])), []);       end,     pickCancelledScript: func() :Hilite(nil),     AppInfoItems:       [] // set in afterScript       ,     auxOffset: nil,     viewClass: 76 /* clPictureView */    };// After Script for _v76_0thisView := _v76_0;// for NewtthisView.viewSetupFormScript := func()begin	if not IsReadOnly(self._proto)	then call kFixupInfoItems with (self._proto);	//inherited:?viewSetupFormScript();endconstant |layout_myProtoInfoButton| := _v76_0;// End of file myProtoInfoButton// Beginning of file protoAboutText// Before Script for _v81_0beginconstant kNewtsCapeSymbol	:= '|Newtscape:Newtscape|;DefConst('kFixupHREFtext, func(template) // used in instance's afterScriptbegin	// extract&remove HREF info, emphasize URLs with underline	// this version assumes syntactically correct URLs (no extra/missing chars)	// <A HREF="href">label</A>	// e.g., <A HREF="http://">home page</A>	// e.g., <A HREF="mailto:...">email addr</A>	local ARRAY styles := [], hrefs := [];	local text := template.text, href;	local regfont := template.viewFont, urlfont;	if isFrame(regfont)	then begin		urlfont := Clone(regfont);		urlfont.face := BOR(urlfont.face, kFaceUnderline);		end	else urlfont := BOR(regfont,tsUnderLine);	local spos, qpos, epos := 0;	while spos := StrPos(text, "<A HREF", epos)	do begin		// non-empty regular text before <A...		if spos > epos		then begin			AddArraySlot(styles, spos-epos);			AddArraySlot(styles, regfont);			end;		// extract href string: "http:..."		qpos := StrPos(text,"\"",spos)+1;		epos := StrPos(text,"\"",qpos);		href := SubStr(text,qpos,epos-qpos);		// remove HTML before label: <A HREF="...">		epos := StrPos(text, ">", epos);		StrMunger(text,spos,epos+1-spos, nil,0,nil);		// remove HTML after label: </A>		epos := StrPos(text,"</A>",spos);		StrMunger(text,epos,4, nil,0,nil);		// highlight label		AddArraySlot(styles, epos-spos);		AddArraySlot(styles, urlfont);		// save href (for viewClickScript)		AddArraySlot(hrefs, [href, spos, epos]);		end;	// any regular text at end?	if epos < StrLen(text)	then begin		AddArraySlot(styles,StrLen(text)-epos);		AddArraySlot(styles, regfont);		end;if kDebugOnthen begin	Print("about text:");	Print(text);	Print("about hrefs:");	Print(hrefs);	end;	template.styles := styles;	template.hrefs := hrefs;	template.text := text;	RemoveSlot(template,'viewFont);end);end_v81_0 :=    {viewBounds: {left: 1, top: 1, right: -1, bottom: -15},     viewFlags: 513,     viewFont:       simpleFont10 // note: this will be replaced by styles. coord with linespacing       ,     viewFormat: 257,     viewLineSpacing: 12,     text: "",     viewClickScript:       func(unit)       begin       /*       	this finds the HREF that's clicked on (precomputed in afterScript)       	highlights it       	dispatches via urlCop or Newt's Cape       	unhighlights       */              	local hrefentry, href, options := {}, spos, epos, app;       	local INT cpos := :MyPointToCharOffset(GetPoint(firstX,unit), GetPoint(firstY,unit));       	local ttitle := GetVariable(self, 'title);	// from app       	if not isInstance(ttitle, 'string)       	then ttitle := "untitled";              //Print(cpos);       //if cpos >=0 then Print(text[cpos]);              	if cpos >= 0       	then foreach hrefentry in hrefs // e.g., [["http:...", 10,20],...]       		do if (spos := hrefentry[1]) <= cpos and       				cpos <= (epos := hrefentry[2])       		then begin       			:SetHilite(spos, epos, true);       			href := hrefEntry[0];              			// dispatch using urlCop if installed (and url type is registered)       			if (app := GetRoot().urlCop:?PreferredApp(href, 'getURL, {}))       				and app <> kNewtsCapeSymbol       			then GetRoot().urlCop:getURL(href,options) // .(app): ?              			else if GetRoot().(kNewtsCapeSymbol) // Newt's Cape installed?       			then begin       				if BeginsWith(href,"mailto:")       				then begin       					options.subject := ttitle;        					options.name 	:= SubStr(text,spos,epos-spos);       					options.body 	:= "I really like" && ttitle;       					end       				else options.noStatus := not kDebugOn; // hidden for end users       				GetRoot().(kNewtsCapeSymbol):getURL(href,options);       				end       			else if kDebugOn       			then Print(href);              			break :SetHilite(cpos,cpos,true); // would be nice to get rid of the caret too       			end;       	TRUE; // handled click       end,     viewJustify: 240,     MyPointToCharOffset:       func(x,y)        if kBuild20 or HasVariable(self, 'PointToCharOffset)       then :PointToCharOffset(x,y)              else begin // 1.x definition       	local gb := :GlobalBox();       	x := x - gb.left;       	y := y - gb.top;       	//Print([x,y]);              	local spos, epos := -1;       	local INT i, linenum := y div viewLineSpacing;       	if linenum < 0 then return -1;              	// find the line       	// assume all cr-delimited with no wrapping       	for i:=0 to linenum       	do if epos       		then begin       			spos := epos+1;       			epos := StrPos(text,"\n",spos);       			end       		else return -1;              	local newstr := {       		viewFont: styles[1],       		msg: Functions.StrTruncate}:msg(SubStr(text,spos,epos), x);              	spos + StrLen(newstr)-1; // É on end       	end,     viewClass: 81 /* clParagraphView */    };// After Script for _v81_0thisView := _v81_0;begin// for NewtthisView.viewSetupFormScript := func()begin	if not IsReadOnly(self._proto) and StrPos(text,"<A HREF",0)	then call kFixupHREFtext with (self._proto);	//inherited:?viewSetupFormScript();end;endconstant |layout_protoAboutText| := _v81_0;// End of file protoAboutText// Beginning of text file Final Project Dataif kBuild1xthen kProtoDictFrame.protoInfoButton := GetLayout("myProtoInfoButton");kProtoDictFrame.protoAboutText := GetLayout("protoAboutText");// End of text file Final Project Data// Beginning of file newtFloatProto_v180_0 :=    {viewBounds: {left: -16, top: 22, right: 132, bottom: 98},     viewFormat: 83952385,     viewSetupFormScript:       func()       begin       	self.growView := self;       	// aboutNewt, evalLog, Prefs, newtDraw       	self.viewBounds := call knewBounds with(newtView,subLeft,floatTop,subRight,subBottom,nil,nil);       end       ,     viewJustify: 0,     viewClickScript:       func(unit) // 1.x       //:changeBounds(unit,TRUE));       self=growView       and ABS(GetPoint(firstY, unit) - :GlobalBox().top) <= kDragRadius       and ABS(GetPoint(firstX, unit) - :GlobalBox().left - ((viewBounds.right - viewBounds.left) div 2)) <= kDragRadius       and :Drag(unit, nil)   // returns TRUE       ,     viewDrawScript:       func()       begin       	constant y := -1;       	local INT x := (viewBounds.right - viewBounds.left) div 2;       	:DrawShape(       		MakeOval(x-kDragRadius, y-kDragRadius, x+kDragRadius, y+kDragRadius), // left,top,right,bottom       		{transferMode: modeCopy,       		fillPattern: vfFillWhite,       		penSize: 2,       		});       end,     floatTop: subTop,     viewFlags: 608,     _proto: @180 /* protoFloatNGo */    };// After Script for _v180_0thisView := _v180_0;begin//thisView.viewBounds := NIL;RemoveSlot(thisView,'viewBounds);// when growing implemented, change to :changeBounds(unit,NIL) ???if kBuild20then begin	thisView._proto := protoDragNGo;	RemoveSlot(thisView, 'viewClickScript);	RemoveSlot(thisView, 'viewDrawScript);	RemoveSlot(thisView, 'viewFlags);	thisView.viewFormat := Bor(thisView.viewFormat, 208); //vfFrameDragger);	endelse begin	thisView.viewFormat := Bor(thisView.viewFormat, vfFrameMatte);	end;endconstant |layout_newtFloatProto| := _v180_0;// End of file newtFloatProto// Beginning of file newtTitleProto_v218_0 :=    {viewBounds: {top: -11, left: 0, right: 120, bottom: 0},     viewJustify: 8388754,     _proto: @218 /* protoStaticText */    };constant |layout_newtTitleProto| := _v218_0;// End of file newtTitleProto// Beginning of file NewtScrollProto_v74_0 :=    {viewBounds: {left: 16, top: 16, right: 224, bottom: 256},     viewFlags: 33,     viewFormat: 337,     viewOriginX: 0,     viewOriginY: 0,     viewClass: 74 /* clView */    };// After Script for _v74_0thisView := _v74_0;//thisView.viewBounds := NILRemoveSlot(thisView,'viewBounds); // computed in viewSetupFormscriptconstant |layout_NewtScrollProto| := _v74_0;// End of file NewtScrollProto// Beginning of file newtScrollParaProto_v81_0 :=    {viewFlags: 145921,     viewFormat: 12289,     viewFont: kNewtFont,     viewBounds: {top: 0, left: 0, right: 20000, bottom: 20000},     tabs: kTabs,     viewSetupFormScript:       func()       begin       	self.viewFont := prefsCurrent.newtFont;       	//self.viewLineSpacing := FontHeight(viewFont) + 4;       	local vb := :parent().viewBounds;       	self.viewBounds := SetBounds(0, 0, vb.right-vb.left, 20000);       	self.text := Clone("");       end,     Scroll:       func(col,row)       :Parent():SetOrigin(       	max(0, viewOriginX - (col * viewLineSpacing)),       	max(0, viewOriginY - (row * viewLineSpacing))       	),     textFlags:       1<<10 //vSingleKeyStrokes       ,     _tabParent: true,     viewClass: 81 /* clParagraphView */    };// After Script for _v81_0thisView := _v81_0;begin	RemoveSlot(thisView,'viewBounds);	RemoveSlot(thisView,'viewFont);endconstant |layout_newtScrollParaProto| := _v81_0;// End of file newtScrollParaProto// Beginning of file AboutLayoutaboutView :=    {viewBounds: {top: 18, left: 0, right: 230, bottom: 306},     save:       func()       :saveNotePara(nil,ParamStr(       kRegistrationText,       [kVersion,                              	// 0=version       ShortDateStr(Time(), shortDateStrSpec),  	// 1=date w/o time       SubStr(aboutText.text,       	StrPos(aboutText.text,"Steve",0),nil),	// 2=SW name&address -- see kAboutText       SPrintObject(:GetUserConfig('name)),    	// 3=user name       SPrintObject(:GetUserConfig('company)), 	// 4=user company w/ cr, if present       SPrintObject(:GetUserConfig('address)), 	// 5=user address       SPrintObject(:GetUserConfig('cityZip)), 	// 6=user city,state,zip       SPrintObject(:GetUserConfig('country)), 	// 7=user country       kNoteString,								// 8=noteString       ]), nil,nil),     title: kAboutTitle,     viewFlags: 580,     floatTop: aboutTop,     viewOverviewScript: func() newtView:viewOverviewScript(),     _proto: _v180_0    };registerButton :=    {viewBounds: {top: -15, left: 2, right: 17, bottom: -3},     buttonClickScript:       func()       begin       	local RegView := GetRoot().(kRegistrationPackage);       	if RegView       	then begin              	RegView:?open();             	RegView:?ExternalRegister(kRegFrame);       		end       	else :error(kSharewareErr, kRegistrationPackage);       end,     viewJustify: 134,     icon: GetPictAsBits("RegisterMoneyButton", nil),     viewSetupFormScript:       func()       begin       	viewFlags := if GetRoot().(kRegistrationPackage) exists       		then vClickable+vReadonly+vVisible       		else 0;       	inherited:?viewSetupFormScript();       end,     _proto: @198 /* protoPictureButton */    };AddStepForm(aboutView, registerButton);aboutText :=    {text: kAboutText,     viewFont: kNewtFont,     viewLineSpacing: kPrintSpacing,     _proto: _v81_0    };AddStepForm(aboutView, aboutText);StepDeclare(aboutView, aboutText, 'aboutText);// After Script for aboutTextthisView := aboutText;call kFixupHREFText with (thisView)aboutTitle := {text: kAboutTitle, _proto: _v218_0};AddStepForm(aboutView, aboutTitle);// After Script for aboutViewthisView := aboutView;begin   thisView.viewScrollUpScript :=    thisView.viewScrollDownScript := func() NIL;   //thisView.viewOverviewScript := kOverviewScript;   //thisView.viewBounds := NIL;	RemoveSlot(thisView,'viewBounds);	if kBuild20 or not kIgnoreNativeKeyword	then ArrayRemoveCount(thisView.stepChildren,0,1);	// remove registerButton in N,-2 versionsendconstant |layout_AboutLayout| := aboutView;// End of file AboutLayout// Beginning of file PrintLayoutprintView :=    {viewBounds: {left: 4, top: 12, right: 234, bottom: 263},     viewFlags: 612,     save:       func()       if para.text > eString       then :saveNotePara(nil,para.text,para.styles,nil),     title: kPrintTitle,     printVal:       func(val, level, quote, font, refresh, suffix)       begin       	self:open();       	local str := para.text, styles := para.styles;       	if not str then str := Clone("");       	local INT oldlen := StrLen(str);       	SetValue(para, 'text, str := :PrintObject(val, str, level, quote, "", suffix));       	SetValue(para, 'styles, call kAppendList with (styles, [StrLen(str)-oldlen, if font then font else prefsCurrent.newtFont]));       	if refresh then RefreshViews(); // force update       end,     viewOverviewScript: func() newtView:viewOverviewScript(),     _proto: _v180_0    };printView_v0_0 :=    {     viewSetupFormScript:       func()       self.viewBounds := call kNewBounds with(evalLog,0,0,0,-16,nil,kPrintSpacing)     ,     _proto: _v74_0    };AddStepForm(printView, printView_v0_0);para := {viewLineSpacing: kPrintSpacing, _proto: _v81_0};AddStepForm(printView_v0_0, para);StepDeclare(printView, para, 'para);// After Script for parathisView := para;begin // !!!iif kBuild20then begin	thisView.viewSetupFormScript:= kMetaDotSetupFunc; 	thisView.viewQuitScript 	:= kMetaDotQuitFunc;	thisView._keyMetaDot 		:= kMetaDotKeyFunc;	endelse begin	thisView.setEdit := kMetaDotSetEditFunc;	end;	thisView.viewGestureScript 	:= kMetaDotGestureFunc;thisView.pickActionScript 	:= kMetaDotPickFunc;endprintTitle := {text: kPrintTitle, _proto: _v218_0};AddStepForm(printView, printTitle);// After Script for printViewthisView := printView;begin   //thisView.viewOverviewScript := kOverviewScript;   thisView.viewScrollDownScript := kScrollDown;   thisView.viewScrollUpScript := kScrollUp;   //thisView.viewBounds := NIL;	RemoveSlot(thisView,'viewBounds);endconstant |layout_PrintLayout| := printView;// End of file PrintLayout// Beginning of file protoPrefCheckbox_v164_0 :=    {text: "",     viewBounds: {left: 16, top: 16, right: 184, bottom: 40},     viewSetupFormScript:       func()       begin       	viewValue := prefsCurrent.(prefSym);       	inherited:?viewSetupFormScript();       end,     valueChanged: func() :setPreference(prefSym,viewValue),     _proto: @164 /* protoCheckBox */    };// After Script for _v164_0thisView := _v164_0;beginRemoveslot(thisView, 'viewBounds)endconstant |layout_protoPrefCheckbox| := _v164_0;// End of file protoPrefCheckbox// Beginning of file protoPrefPicker_v190_0 :=    {viewBounds: {left: 26, top: 18, right: 158, bottom: 30},     textSetup:       func()       begin       	local str := prefsCurrent.(prefSym);       	if str       	then if prefType='symbol or prefType='int       		then SPrintObject(str)       		else if isArray(prefType) // pathExpr       		then if isFrame(str) and prefSym='newtFont // !!!d       			then begin       				local val, fval;       				foreach val in labelCommands       				do  if isFrame(fval := val.(prefType)) and       						fval.family=str.family and fval.face=str.face and fval.size=str.size       					then return val.item;       				labelCommands[0].item;	// !!!e       				end       			else if kBuild20 or nos20       			then LFetch(labelCommands, str, 0, '|=|, prefType).item       			else call kLFetch with (labelCommands, str, 0, Functions.|=|, prefType).item       		else str       	else labelCommands[0];       end,     prefType: 'string,     labelActionScript:       func(cmd)       begin       	local item := labelCommands[cmd], val;       	:setPreference(prefSym, val :=       		if isArray(prefType) // pathExpr?       		then item.(prefType)       		else if cmd=0       		then nil       		else if prefType = 'symbol       		then Intern(item)       		else if prefType = 'int       		then Floor(StringToNumber(item))       		else item);              	if kBuild1x and isFrame(item)       	then :updateText(item.item);              	if EndsWith(SPrintObject(prefSym), "font")	// newtFont, menuFont       	then SetValue(entryLine, 'viewFont, val);       end,     alwaysCallPickActionScript: true,     _proto: @190 /* protoLabelPicker */    };// After Script for _v190_0thisView := _v190_0;beginif kBuild1xthen RemoveSlot(thisView, 'alwaysCallPickActionScript);	// !!!jRemoveSlot(thisView,'viewBounds);endconstant |layout_protoPrefPicker| := _v190_0;// End of file protoPrefPicker// Beginning of file PrefsLayoutPrefsLayout :=    {viewBounds: {left: -16, top: 22, right: 212, bottom: 252},     title: kPrefsTitle,     _proto: _v180_0    };askWordsCheck :=    {viewBounds: {left: 90, top: 2, right: 230, bottom: 16},     text: "Ask Words?",     prefSym: 'askWords,     _proto: _v164_0    };AddStepForm(PrefsLayout, askWordsCheck);// After Script for askWordsCheckthisView := askWordsCheck;begin	thisView.text := LocObj("Ask Words", 'askWordsLabel) & $?;endrotateButton :=    {viewBounds: {left: 2, top: -14, right: 78, bottom: -2},     viewFlags: 515,     viewJustify: 130,     _proto: @474 /* clView */    };AddStepForm(PrefsLayout, rotateButton);// After Script for rotateButtonthisView := rotateButton;if kBuild20then thisView._proto := protoOrientationviewSizePicker :=    {     labelCommands:       ["full", "portrait"]	// LocObj???       ,     text:       "viewSize"	// LocObj???       ,     viewBounds: {left: 0, top: 92, right: 160, bottom: 106},     prefSym: 'viewSize,     prefType: 'symbol,     _proto: _v190_0    };AddStepForm(PrefsLayout, viewSizePicker);menuFontPicker :=    {     labelCommands:       [       {item: "Espy9 ('system')",	value: 0x00002400},       {item: "Espy9B",			value: 0x00102400},       {item: "Espy10",			value: 0x00002800},       {item: "Espy10B",			value: 0x00102800},       ],     text: "menuFont",     viewBounds: {left: 0, top: 110, right: 230, bottom: 124},     prefSym: 'menuFont,     prefType: '[pathExpr: value],     viewSetupFormScript:       func()       begin       	local font := prefsCurrent.(prefSym);       	if font       	then entryLine.viewFont := font;       	inherited:?viewSetupFormScript();       end,     _proto: _v190_0    };AddStepForm(PrefsLayout, menuFontPicker);// After Script for menuFontPickerthisView := menuFontPicker;begin	thisView.text := LocObj("menuFont", 'menuFontLabel);enddocLevelCheck :=    {viewBounds: {left: 2, top: 145, right: 140, bottom: 159},     text: "NewtWorks doc menu?",     prefSym: 'docLevel,     _proto: _v164_0    };AddStepForm(PrefsLayout, docLevelCheck);// After Script for docLevelCheckthisView := docLevelCheck;begin	//thisView.text := LocObj("I Paid", 'IpaidLabel) & $?;endsmartEditCheck :=    {viewBounds: {left: 90, top: 128, right: 230, bottom: 142},     text: "Smart Edit?",     prefSym: 'smartEdit,     _proto: _v164_0    };AddStepForm(PrefsLayout, smartEditCheck);// After Script for smartEditCheckthisView := smartEditCheck;begin	thisView.text := LocObj("Smart Edit", 'smartEditLabel) & $?;endautoLoadCheck :=    {viewBounds: {left: 2, top: 2, right: 90, bottom: 16},     text: "Auto Load?",     prefSym: 'autoLoad,     _proto: _v164_0    };AddStepForm(PrefsLayout, autoLoadCheck);// After Script for autoLoadCheckthisView := autoLoadCheck;begin	thisView.text := LocObj("Auto Load", 'autoLoadLabel) & $?;enddoConfirmCheck :=    {viewBounds: {left: 2, top: 20, right: 90, bottom: 34},     text: "Do Confirm?",     prefSym: 'doConfirm,     _proto: _v164_0    };AddStepForm(PrefsLayout, doConfirmCheck);// After Script for doConfirmCheckthisView := doConfirmCheck;begin	thisView.text := LocObj("Do Confirm", 'doConfirmLabel) & $?;endcloseConfirmPicker :=    {labelCommands: ["noConfirm", "editedConfirm", "alwaysConfirm"],     text: "Close",     viewBounds: {left: 90, top: 20, right: 230, bottom: 34},     prefSym: 'closeConfirm,     prefType: 'symbol,     _proto: _v190_0    };AddStepForm(PrefsLayout, closeConfirmPicker);// After Script for closeConfirmPickerthisView := closeConfirmPicker;begin	thisView.text := LocObj("Close", 'closeLabel);endautoHeapCheck :=    {viewBounds: {left: 2, top: 38, right: 90, bottom: 52},     text: "Auto Heap?",     prefSym: 'autoHeap,     _proto: _v164_0    };AddStepForm(PrefsLayout, autoHeapCheck);// After Script for autoHeapCheckthisView := autoHeapCheck;begin	thisView.text := LocObj("Auto Heap", 'autoHeapLabel) & $?;endheapFreqPicker :=    {     labelCommands:       [LocObj("none", 'noneItem), "5000", "10000", "15000", "20000", "30000",],     text: "Heap Freq",     viewBounds: {left: 90, top: 38, right: 230, bottom: 52},     prefSym: 'heapFreq,     prefType: 'int,     _proto: _v190_0    };AddStepForm(PrefsLayout, heapFreqPicker);// After Script for heapFreqPickerthisView := heapFreqPicker;begin	thisView.text := LocObj("Heap Freq", 'heapFreqLabel);endprintRefreshCheck :=    {viewBounds: {left: 2, top: 74, right: 90, bottom: 88},     text: "Print Refresh?",     prefSym: 'printRefresh,     _proto: _v164_0    };AddStepForm(PrefsLayout, printRefreshCheck);// After Script for printRefreshCheckthisView := printRefreshCheck;begin	thisView.text := LocObj("Print Refresh", 'printRefreshLabel) & $?;endnewtFontPicker :=    {     labelCommands:       [       {item: "Espy9 (System)",	value: 0x00002400},       {item: "Espy10",			value: 0x00002800},       {item: "Espy12",			value: 0x00003000},              {item: "Geneva9 (Simple)",	value: simpleFont9},       {item: "Geneva10",			value: simpleFont10},       {item: "Geneva12",			value: simpleFont12},              {item: "NewYork9 (Fancy)",	value: userFont9},       {item: "NewYork10",			value: userFont10},       {item: "NewYork12",			value: userFont12},              // 1.x: remove in viewSetupFormScript       {item: "Handwriting9 (Casual)",	value: 0x00002403},       {item: "Handwriting10",			value: 0x00002803},       {item: "Handwriting12",			value: 0x00003003},              // add others       ],     text: "newtFont",     viewBounds: {left: 0, top: 56, right: 220, bottom: 70},     prefSym: 'newtFont,     prefType: '[pathExpr: value],     viewSetupFormScript:       func()       begin       	local font := prefsCurrent.(prefSym), s, v, sname;       	if font       	then entryLine.viewFont := font;       	labelCommands := Clone(labelCommands);       	if kBuild1x and not nos20       	then SetLength(labelCommands, Length(labelCommands)-3);	// !!!e              	// !!!d. add other built-ins, user-installed (e.g., Monaco, Minico)       	foreach s,v deeply in Fonts	// 2.x use?: call kGetAllFontsFunc with () except where System font?       	do  if not SetContains('[espy, newYork, geneva, handwriting], s)       		then begin       			sname := Capitalize(SPrintObject(s));       			AddArraySlot(labelCommands,       				{item: sname & 9 && $( & v.name & $), value: {family: s, face: 0, size: 9}});       			AddArraySlot(labelCommands,       				{item: sname & 10, value: {family: s, face: 0, size: 10}});       			AddArraySlot(labelCommands,       				{item: sname & 12, value: {family: s, face: 0, size: 12}});       			end;       	inherited:?viewSetupFormScript();       end,     _proto: _v190_0    };AddStepForm(PrefsLayout, newtFontPicker);// After Script for newtFontPickerthisView := newtFontPicker;begin	thisView.text := LocObj("newtFont", 'newtFontLabel);endprefsTitle := {text: kPrefsTitle, _proto: _v218_0};AddStepForm(PrefsLayout, prefsTitle);versionButton :=    {buttonClickScript: func() :version(nil),     text: "Version",     viewBounds: {left: -70, top: -14, right: -25, bottom: -2},     viewJustify: 8388774,     _proto: @226 /* protoTextButton */    };AddStepForm(PrefsLayout, versionButton);// After Script for versionButtonthisView := versionButton;begin	thisView.text := LocObj("Version", 'versionLabel);enddebugCheck :=    {viewBounds: {left: 90, top: 74, right: 230, bottom: 88},     text: "Compile for debugging?",     prefSym: 'debugCompile,     _proto: _v164_0    };AddStepForm(PrefsLayout, debugCheck);// After Script for debugCheckthisView := debugCheck;begin	//thisView.text := LocObj("Print Refresh", 'printRefreshLabel) & $?; ???endIpaidCheck :=    {viewBounds: {left: 2, top: 128, right: 90, bottom: 142},     text: "I Paid?",     prefSym: 'Ipaid,     _proto: _v164_0    };AddStepForm(PrefsLayout, IpaidCheck);// After Script for IpaidCheckthisView := IpaidCheck;begin	thisView.text := LocObj("I Paid", 'IpaidLabel) & $?;endnotifyPick :=    {labelCommands: ["Newt only", "Newt & System", "System only"],     text:       "notify"	// LocObj???       ,     viewBounds: {left: 0, top: 162, right: 160, bottom: 176},     prefSym: 'notify,     prefType: 'int,     textSetup:       func()       labelCommands[prefsCurrent.(prefSym)],     labelActionScript:       func(cmd)       :setPreference(prefSym, cmd),     _proto: _v190_0    };AddStepForm(PrefsLayout, notifyPick);// After Script for PrefsLayoutthisView := PrefsLayout;beginRemoveSlot(thisView,'viewBounds);// when growing implemented, change to :changeBounds(unit,NIL) ???local children := thisView.stepChildren;if kBuild20then ArrayRemoveCount(children,0,1)		// AskWordselse ArrayRemoveCount(children,1,4);	// Rotate, viewSize, menuFont, docLevelendconstant |layout_PrefsLayout| := PrefsLayout;// End of file PrefsLayout// Beginning of file Main NewtnewtView :=    {deleteAllAnim: func(fl) if fl then :Delete('deleteAll, eArray),     deleteAllConfirm:       func(target,targetView)       if targetView.edited       then PlaySound(errSound)              else if targetView.prefsCurrent.doConfirm       then targetView:Confirm(       		targetView.title,       		LocObj("Delete all Notes in folder", 'deleteAllNotesMsg) & $: &&       			if kBuild20       			then GetFolderStr(targetView.labelsFilter)	// !!!k       			else if targetView.labelsFilter       			then targetView.labelsFilter       			else kUnfiled,       		targetView,       		'deleteAllAnim)              else targetView:deleteAllAnim(true),     copySource:       func(target,targetView)       if targetView.edited or Length(targetView.librarySources)=0       then PlaySound(errSound)       else targetView.status:newtPopup(targetView.librarySources,       	if kBuild20 then targetView.viewBounds.right-160 else kPopLeft, targetView.viewBounds.top)     ,     reallyQuit:       func(fl) // called via Confirm (see closebox)       if fl then newtView:close(),     viewSetupDoneScript:       func()       begin       if kProfileOn then EnableProfiling(true);       	all_Apps := edited := NIL;       	self.all_ViewNames := self.all_Views := NIL;       	self.dummyPopList := self.originalPopList := NIL;              	if not (kBuild20 or nos20)       	then GetRoot().(kExtrasSymbol):?close(); // regain 4K              	cleanup := [];       	self.newt_Views := [aboutNewt, evalControls, evalLog, _prefsView, ];       	//aboutNewt.viewOverviewScript := evalLog.viewOverviewScript := viewOverviewScript;              	local gData :=       		if kBuild20 or nos20       		then GetGlobalVar(kAppSymbol)       		else GetGlobals().(kAppSymbol);       	local slot, fr, fr2;       	foreach slot,fr in gData.tools	// e.g., newtControls, newtDrawing, ExprKbd       	do begin       		fr2 := BuildContext(fr);       		fr2.(EnsureInternal('_parent)) := self;       		self.(slot) := fr2;       		AddArraySlot(cleanup,slot);       		AddArraySlot(newt_Views,fr2);       		end;       	Sort(newt_Views, '|str<|, 'title);              	foreach slot,fr in gData.protos // e.g., protoPackage, ErrCnst       	do begin       		self.(slot) := fr;       		AddArraySlot(cleanup,slot);       		end;              	// set up inheritance context       	evalView := if HasSlot(self, 'newtDrawing) then newtDrawing else newtView;       	fr2 := call kEvalContextFunc with (); // gData:?getEvalContext();       	// if not fr2 then fr2 := {_parent: GetRoot()};       	fr2._proto := defConstants := {};       	self.(EnsureInternal('_parent)) := fr2;              	/* evalView := {_parent: fr2, _proto: newtView};       	if HasSlot(self, 'newtDrawing)       	then evalView := {_parent: evalView, _proto: newtDrawing}; */              	foreach slot,fr in gData.views // e.g., Sloup       	do begin       		self.(slot) := :addView(fr);       		AddArraySlot(cleanup, slot);       		end;       	:addView(kNTKsymbol);		// NTK inspector       	:addView(kNewtsCapeSymbol);       	if kBuild21       	then :addView(kNewtWorksSym);              	userSourceSoup := GetUnionSoup(newtSoupName);       	SetKeyView(para,0); // default for kbd              	AddArraySlot(soupNotify, EnsureInternal(newtSoupName)); // if any changes while we're open       	AddArraySlot(soupNotify, EnsureInternal(kAppSymbol));       	:setInspector(true, nil);              	if prefsCurrent.autoLoad or startFolder exists       	then if kBuild20 or nos20       	then begin       		AddDeferredSend(newtView, 'soupChanged, [newtSoupName]);       		if not prefsCurrent.Ipaid       		then AddDeferredSend(aboutNewt, 'open, nil);       		end       	else begin       		AddDeferredAction(       			Functions.Perform, [newtView, 'soupChanged, [newtSoupName]]);       		if not prefsCurrent.Ipaid       		then AddDeferredAction(       			Functions.Perform, [aboutNewt, 'open, []]);       		end;       	RemoveSlot(self, 'startFolder); // if it's added       	inherited:?viewSetupDoneScript();       end,     Confirm:       func(apptitle, str, obj, msg)       if kBuild20 or Functions.AsyncConfirm       then AsyncConfirm(str, 'yesNo, func(x) Perform(obj,msg,[x]))       else GetRoot():Confirm(apptitle, str, obj, msg);,     librarySources: nil,     sharewareFee: kSharewareFee,     setPreference:       func(sym,val)       begin       	:setPreferenceI(sym,sym,val);       	if sym='newtFont       	then begin       		local txt := para.text, oldEdited := edited;       		SetValue(para, 'viewFont, val); // zaps       		if kBuild1x       		then SetValue(para, 'text, txt);	// !!!d       		SetValue(para, 'styles, call kSourceStyles with (txt, nil, val));       		if kBuild1x and not oldEdited	// !!!d       		then begin       			edited := nil;       			SetValue(slotPicker, 'text, "\uFC01");       			end;              		SetValue(evalField, 'viewFont, val);       		if :ViewIsOpen(evalLog)       		then SetValue(evalLog.para, 'viewFont, val);       		end       	       	//else if sym='noLines	// !!!d       	//then SetValue(para, 'viewFormat, if val then 1 else 12289)              	else if kBuild1x and sym='askWords       	then GetRoot().(kKbdSymbol).askWords := val;       end,     fixFrame:       func(frame)       if (if kBuild20       	then IsInteger(frame) or IsSymbol(frame)       	else isInstance(frame,'int) or isInstance(frame,'symbol))       	or IsReadOnly(frame)       then frame              else if isFrame(frame)       then begin       	local INT n;       	local slot ,val, proto, psym, acontext;              	if (if kBuild20       		then IsFunction(frame)       		else isInstance(frame,' _function)		// 2.x       			or isInstance(frame, 'CodeBlock)) 	// 1.x       	then begin       		if val := frame.argFrame       		then val._nextArgFrame := val._parent := val._implementor := NIL;       		:fixObjectConst(frame,nil);	// !!!h       		if not prefsEntry.debugCompile       		then RemoveSlot(frame, 'DebuggerInfo); 	// if present, e.g., from 2.x compatibility       		end;       	// allow fixup of method              	foreach slot,val in frame       	do       //begin Print(slot);       		if slot = '_proto or slot = 'viewClass       			or (isFrame(val) and not IsReadOnly(val) and slot <> '_parent       			//and (HasSlot(val,'_proto) or HasSlot(val,'viewClass) or HasSlot(val,kFakeParent))       			)       		then frame.(slot) := :fixFrame(val)              		else if isArray(val) and Length(val) > 0 and isFrame(val[0])       		then begin       			n:=0;       			acontext :=       				if slot = 'stepChildren or slot = 'viewChildren       				then Array(2*Length(val),NIL);       			foreach proto in val       			do  if isFrame(proto)       				then begin       					:fixFrame(proto);       					if acontext and psym := proto.preallocatedContext       					then begin       						acontext[n] := psym;       						acontext[n+1] := proto;       						n := n+2;       						//frame.(psym) := NIL;       						end;       					end;       			if n > 0       			then frame.(if slot='stepChildren       						then 'stepAllocateContext       						else 'allocateContext) := SetLength(acontext,n);       			end;       	frame;       	end       else newtView:error(kFixFrameExp,frame),     readEvalPrintContext:       func(source, context) // used by readEvalPrint & InspecTerm       if source > eString       then begin       	source := :fixSource(Clone(source));							// substitute defConstants       	local val := :readEvalContext(source,context); 					// read, eval          :printVal(source,												// print source expression       		printdepth, nil, call kMakeFace with (prefsCurrent.newtFont,tsBold), nil, prefsCurrent.print, unicodeCR); // !!!d          :printVal(val,               		printdepth, true, nil, nil, prefsCurrent.print, unicodeCR);	// print & return value          end,     errPerform:       func(frm,msg,args) // return err val or break ??       if HasVariable(frm,msg)       then try Perform(frm,msg,args);            onexception |evt.ex|       		do newtView:error(msg, currentException()),     viewFormat: 327937,     fixSource:       func(source) // called by readEvalPrintContext, saveMethodCode       if Length(defConstants)=0 or StrPos(source,":defConst",0)       then source       else begin // assumes ok to modify source       	local slot,val,slotstr;       	foreach slot,val in defConstants       	do if StrPos(source, slotstr := SPrintObject(slot), 0)       		then StrReplace(source, slotstr,       				:PrintObject(       					if call kObjectConst with (val) then slot else val,	// !!!h       					Clone(""), 99, true, "", ""),       				nil);       	source;       	end,     viewQuitScript:       func()       begin       //Print("viewQuit");       if kProfileOn then EnableProfiling(nil);       	self.(EnsureInternal('_parent)) := GetRoot(); // ***       	if kBuild20 or nos20       	then GetRoot().|StartBar:SAS|:?AppClosed(self);              	:setInspector(nil,TRUE);       	local rpos, sym, fr;       	while rpos := SetContains(soupNotify, kAppSymbol)       	do ArrayRemoveCount(soupNotify, rpos-1, 2); // added in viewSetupDoneScript       	:removeApp(all_Apps); // app views       	:removeMethods(userSources,true); // methods & userSources       	if cleanup       	then foreach sym in cleanup // views, tools, protos       		do begin       			if isFrame(fr := self.(sym)) and :ViewIsOpen(fr)       			then fr:?close();       			self.(sym) := NIL;	// rather than remove       			end;       	// cleanup "protos"??              if not kDebugOn       then       	foreach sym in '[       		all_Apps,all_ViewNames,all_Views,cleanup,defConstants,defCursor,       		dummyPopList,edited,_evalField,evalView,growView,       		inspector,librarySources,nextPopIndex,newtCursors,       		newtView,newt_Views,originalNotify,originalPopList,popLeft,popOffset,       		popTop,prefsCurrent,prefsEntry,prevPopIndex,protoPackage,protoProgress,       		samples,t_color,t_pen,t_visible,usersources,userSourceSoup,              		targetView,base,t_refresh,target,       		UnitsImport, UnitsMap,	// !!!b       		//labelsFilter,stepChildren       		//aboutNewt,(actionButton),base,evalButton,evalControls,evalField,       		//evalLog,(evalTitle),exprButton,folderTab,heapButton,       		//(kbdButton),(newtClose),para,(printCheck),reorienting,(saveButton),       		//scriptScroll,slotPicker,status,viewBounds,viewCObject,viewFlags,       		]       	do self.(sym) := NIL; //RemoveSlot(self,sym);       	self.errorCodes := self._proto.errorCodes;              	if kBuild20 or nos20 // note: we won't get msg       	then XmitSoupChange(newtSoupName, kAppSymbol, 'whatThe, NIL)       	else BroadcastSoupChange(newtSoupName);       	if kBuild20 or Functions.ClearUndoStacks       	then ClearUndoStacks();       	inherited:?viewQuitScript();       end,     appAll: "All newts",     defConstants: eFrame,     all_Apps: nil,     genericAppIcon: GetPictAsBits("runewt app icon", nil),     doObj:       func(cmd,ref)       if cmd='listOffset or cmd='list       then begin       	local appstr := SPrintObject(ref);       	local pos, pos2, appstr2 := clone(appstr), alen := StrLen(appstr);       	if pos := if kBuild20 then CharPos(appstr2,$+,0)       		else StrPos(appstr2,plusStr,0)       	then appstr2[pos] := $.       	else begin // find last .       		pos2 := -1;       		while pos := if kBuild20 then CharPos(appstr2,$.,pos2+1)       			else StrPos(appstr2,dotStr,pos2+1)       		do pos2 := pos;       		if pos2 > 0 then appstr2[pos2] := $+;       		end;              	local i, str, start, count;       	for i := kTemplateOffset to Length(userSources)-1       	do begin       		str := userSources[i].item;       		if (BeginsWith(str,appstr) or BeginsWith(str,appstr2))             	and (StrLen(str)=alen or str[alen]=$+ or str[alen]=$.)       		then (if not start then start := i)       		else (if start then break count := i - start);       		end;       	if start       	then begin       		if not count       		then count := length(userSources)-start;       		if cmd='listOffset             then [start,count]             else ArrayMunger([],0,nil, userSources,start,count);       		end       	else eArray;       	end              else if cmd='build or cmd='buildCO or cmd='buildI or isArray(ref)       then begin       	local refs, i, start:=0, len:=0, ocmd:=cmd, app, refi;       	if isArray(ref)       	then len := length(refs:=ref)       	else if Length(i := :doObj('listOffset,ref)) > 0       	then begin       		start := i[0];       		len := start + i[1];       		refs := userSources;       		cmd := 'add;       		end;              	for i:=start to len-1       	do :doObj(cmd, if isFrame(refi := refs[i]) then refi.item else refi);              	if ocmd='buildCO or ocmd = 'buildI       	and (app := if (if kBuild20 then IsSymbol(ref) else isInstance(ref,'symbol))       			then newtView.(ref)       			else if (if kBuild20 then IsString(ref) else isInstance(ref,'string))       			then newtView.(Intern(ref)))       	then begin       		app:close();	// *** will break for protoPicker???       		:removeFake(app._proto);       		if ocmd='buildI       		then :installApp(app,true)       		else app:open();       		end;       	end              else if (if kBuild20 then IsString(ref) else isInstance(ref,'string)) and StrLen(ref)>0       then begin       Print(ref);       	local path := [pathExpr: ], step, lastStep, spos:=0, epos, str, ch1, ch2;       	loop begin // find PATH       		epos := call kStrPosAny with (ref, kPathSeps, spos, true);       		str := call kFixDigitName with (call kSubstr with (ref,spos,epos));       		if lastStep       		then break step := str // wrong if stuff afterward???       		else begin       			ch1 := str[0]; ch2 := str[StrLen(str)-1];       			AddArraySlot(path, if ch1=$| and ch2=$|       				then Intern(SubStr(str,1,StrLen(str)-2))       				else if ch1=$( and ch2=$)       				then newtView:readEvalContext(:fixSource(str),nil)       				else Intern(str)       				);       				end;              		if epos       		then begin       			lastStep := ref[epos]=$+;       			spos:=epos+1;       			end       		else break;       		end;              //Print(path); print(step);              	// fix PATH, find OMETH, OSYM       	local pathlast := Length(path)-1, osym := path[pathlast], squote;       	local addarg := "\/\/^0"; // default is comment out 1st (name) line       	local ometh := cmd &     // addStep, removeSlot, etc.       		if step       		then if BeginsWith(step,kPage) and StrLen(step) > 4 and $0 <= step[4] and step[4] <= $9       			then begin // page instead of stepChild       				squote := addarg := "\"^0\""; // embed source (incl name) in "". quote \" when subst       				/*if pathlast=0       				then path[0] := 'evalView       				else SetLength(path,pathlast);*/ // cheat. send msg to 'parent' since no inher       				kPage;       				end       			else begin       				osym := if not EndsWith(step,tilda) then Intern(step);       				"Step";       				end       		else if pathlast=0       		then begin       			path[0] := 'evalView; // empty path not valid -- so cheat       			"App";       			end       		else begin       			if EndsWith(ref,tilda) then osym := NIL;       			SetLength(path,pathlast);       			"Slot";       			end;              //print(path); print(ometh); print(osym);       //ometh=string, osym=symbol              	// do the ADD or REMOVE       	if newtView.(path) exists // .run_Method       	then begin       		local obj := newtView.(path);              		if cmd='add       		then begin // try??? ***       			RemoveSlot(newtView,'add_temp); // in case still around       //			:errPerform(obj,'run_Method,       		 	if not HasVariable(obj, 'run_Method)       			then begin // add a dynamic parent link       				obj.(kFakeParent) := true;       				count := Length(path)-1;       				obj._parent :=       					if count=0       					then newtView       					else newtView.(ArrayMunger([pathExpr: ],0,nil,path,0,count));       				end;              			obj:run_Method(       				ref, "add_temp", eArray,       				"add_temp       func()       :" & ometh & $( & (if osym then "'|" & osym & $| else nilString) & $, & addarg & "\n)",       				squote);       			end /* onexception |evt.ex| do begin ***       				newtView:error('add && ref, currentException());       				Rethrow();       			end */               		else if cmd='remove       		then :errPerform(obj, Intern(ometh), [osym])              		else newtView:error(LocObj("not add/remove", 'notAddRemoveMsg), cmd);       		end       	else newtView:error(LocObj("invalid seg. in path expr", 'invalSegMsg) & $( & ometh & $), path);       	end              else begin // symbol or "" ??       	evalControls:newtPopup(:doObj('list,ref),kPopLeft,nil);       	evalControls.doObjCmd := cmd;       	end,     target: nil,     RemoveView:       func(psym)       begin       	local appframe := if isFrame(psym) then psym else GetRoot().(psym);       	if appframe       	then SetRemove(newt_views,appframe);       	all_Views := all_viewNames := originalPopList := nil;       end,     viewIsOpen: kViewIsOpenFunc,     newtView: nil,     newtPopup:       func(listOrView, first, top)       /* note: this is used by       newtView		overview (all_viewnames)       evalControls	doObj('list       evalButton		:RemovePackage(nil)       scriptScroll	selectLibrary       status			copySource       exprButton		samples       para			smartEdit menu       */       if first  // used by Expr, overviewList, doObj -- see slotPicker:update       then if Length(listOrView)=0       	then PlaySound(errSound)       	else begin       		if self.originalPopList <> listOrView       		then begin       			self.popOffset := 0;       			self.prevPopIndex := self.nextPopIndex := NIL;       			self.originalPopList := listOrView;       			end;       		self.popLeft := first;       		self.popTop := top;       		newtView:newtPopup(self,NIL,NIL); // recur with diff args       		end       else if self=newtView // called via :newtPopup       then begin       	local view := listOrView, viewTop := view.popTop;       	local strlist := view:realPopCommands(dummyPopList, view.originalPopList);       	local vtop := if viewTop then viewTop       			else max(20,newtView.viewBounds.bottom-20-Length(strlist)*kpopLineheight);       	if kBuild20 or nos20       	then begin       		view := view:PopupMenu(strlist, {left: view.popLeft, top: vtop});       		view.bounds := view.viewBounds;       		if listOrView.originalPopList = librarySources			// Copy Source?       		then view.viewFont := prefsCurrent.menuFont;       		view.pickMaxWidth := GetAppParams().appAreaWidth-10;              	view:?SyncView();       		end       	else DoPopup(strlist, view.popLeft, vtop, view);       	end       else newtView:newtPopup(listOrView,NIL,NIL) // called via from :realPopIndex       ,     setPreferenceI:       func(methsym,appSlot,val) // for setting values with Prefs       begin // used by Print?, newtFont, autoLoad; [NewtControls: Pen, Color, Newt?]       	if appSlot       	then nil //(if HasSlot(newtView,appSlot) then newtView.(appSlot) := val)       	else Perform(evalView,methsym,[val]);	// e.g., pen, visible, color              	prefsEntry.(methsym) := prefsCurrent.(methsym) := val;       	if kBuild20       	then EntryChangeXmit(prefsEntry,nil)       	else EntryChange(prefsEntry);       end,     lang: 'English,     addslot:       func(sym,obj)       begin       	local appTemplate := if _package exists then _package._parent._proto else self;       	local sym1, obj1;       	local selfproto :=       		if HasSlot(self,kFakeParent) or isReadOnly(self._proto)       		then self       		else self._proto;              	if sym and not (if kBuild20 then IsSymbol(sym) else isInstance(sym,'symbol))       	then newtView:error(kAddSlotExp,sym)              	else if isFrame(obj)       	then if sym       		then selfproto.(sym) := :fixFrame(obj)       		else foreach sym1,obj1 in :fixFrame(obj)       			do selfproto.(sym1) := obj1              	else selfproto.(sym) := obj;       end,     newtCursors: nil,     viewFlags: 37,     addapp:       func(nsym,appTemplate)       if isFrame(appTemplate)       then begin       	if all_Apps and HasSlot(newtView,nsym)       	then begin       		:removeApp(nsym);       		RefreshViews();       		end;       	appTemplate._package.newtSymbol := nsym;  // creates _package (if doesn't exist)       //print(appTemplate);       	appTemplate := :fixFrame(appTemplate);       	local pkgframe := appTemplate._package;       	local appView, vf, sig, aTitle := appTemplate.title, isbn := appTemplate.isbn;       	local asym := appTemplate.appSymbol;       	if not asym       	then begin       		sig := pkgframe.devSignature;       		asym := appTemplate.appSymbol :=       			Intern(nsym & $: & if sig then sig else kNewt);       		end;              	if isbn // book?       	then begin       		if call kFindBook with (isbn,nil)       		then return newtView:error('addApp, LocObj("existing book", 'existingBookMsg));       		try BookAvailable({book: appTemplate},0) // bus error in 2.0       		onexception |evt.ex| do Print(currentException());       		call kFindBook with (isbn,true).curPage := 1;       		appView := {book: appTemplate, title: atitle, isbn: isbn, open: kBookOpen};       		end              	else begin // regular app       		if not HasSlot(appTemplate,'viewBounds)       		then appTemplate.viewBounds := Clone(newtView.viewBounds);              		if not aTitle       		then appTemplate.title := SPrintObject(nsym);               		appTemplate.viewFlags := if (vf := appTemplate.viewFlags)       			then bor(vf,vClickable)       			else vApplication+vClickable;              		if prefsEntry.debugCompile       		then appTemplate.debug := nsym;              		appView := BuildContext(appTemplate);       		pkgframe.(kFakeParent) := TRUE;          		pkgframe._parent := appView;       		end;              	appView.(EnsureInternal('_parent)) := newtView; // for :addStep, overview, constants       	if all_Apps       	then AddArraySlot(all_Apps,nsym)       	else all_Apps := [nsym];       	all_ViewNames := all_Views := originalPopList := nil; // uncache, ref by menu       	newtView.(nsym) := appView;       	local psym := pkgframe.pkgSymbol;       	pkgframe.existingPackage :=       		call kFindPkg with (SPrintObject(if psym then psym else asym),nil);              	if pkgframe.requires       	then begin       		local gData	:=       			if kBuild20 or nos20       			then GetGlobalVar(kAppSymbol)       			else GetGlobals().(kAppSymbol);       		local sym, tsym, installed := gData.installed, constants := gData.constants;       		foreach sym in pkgframe.requires       		do if not ( // versions???       				((if kBuild20 then IsSymbol(sym) else isInstance(sym,'symbol)) and       					(installed.(sym) or constants.(sym) or       					installed.(tsym := Intern(sym & ksig)) or constants.(tsym)))       				or ((if kBuild20 then IsString(sym) else isInstance(sym,'string)) and       					newtView:readEvalPrintContext(sym,nil))       				)       			then newtView:error('requires,sym);       		end;              	if not pkgFrame.noOpen       	then begin       		:errPerform(appView,'open,eArray);       		appView:?dirty(); // to make sure it's visible (not def for book)       		end;          appView          end       else newtView:error(kAddAppExp,appTemplate),     realPopCommands:       func(dummy, original)       begin       	local INT len := Length(original), amax;       	prevPopIndex := nextPopIndex := NIL;       	if /*kBuild20 or*/ len <= lpmax+1 // short list, or "-2" version?       	then begin       		popOffset := 0;       		original; // result       		end       	else begin       		if dummy       		then SetLength(dummy,lpmax+1)       		else dummy := dummyPopList := Array(lpMax+1,NIL);              //print(popOffset);       		if popOffset=0 // only >NEXT       		then ArrayMunger(dummy,    0, nextPopIndex := lpmax,       						 original, 0, lpmax)       		else if (amax := len-popOffset) <= lpmax // only <PREV       		then ArrayMunger(SetLength(dummy,amax+1),(prevPopIndex:=0)+1,amax,       						 original,               popOffset,         amax)       		else // both <PREV and >NEXT       			 ArrayMunger(dummy,   (prevPopIndex:=0)+1,(nextPopIndex:=lpmax)-1,       			 			 original,popOffset,          lpmax-1);       		if prevPopIndex then dummy[prevPopIndex] := "<PREV<";       		if nextPopIndex then dummy[nextPopIndex] := ">NEXT>";       //print(prevPopIndex); print(nextPopIndex);       		dummy; // result       		end;       end,     GetUserConfig:       func(configSym)       if kBuild20 or Functions.GetUserConfig exists       then GetUserConfig(configSym)       else call kGetUserConfigFunc with (configSym),     selectLibrary:       func(target,targetView)       begin       	local sUnfiled := if kBuild20 or nos20 then GetFolderStr(nil) else kUnfiled;	// !!!k       	local val, sym, all := [call kMakeHeaderItem with (kNotesName,nil), sUnfiled];       	local lens := all[0].lengths := {};              	local gData	:=       		if kBuild20 or nos20       		then GetGlobalVar(kAppSymbol)       		else GetGlobals().(kAppSymbol);              	// Notes folders       	call kAppendPickList with (all,       		if kBuild20       		then foreach val in GetFolderList(kNotesSym,nil) collect GetFolderStr(val) // !!!k       		else foreach val in call kFolderList with (nil)  collect SPrintObject(val),       		nil);       	lens.folder := Length(all); // for pickActionScript              	// FolderLib       	AddArraySlot(all, call kMakeHeaderItem with (kFolderLib, nil));              	call kAppendPickList with (all,       		foreach sym,val in gData.libraries        		collect SPrintObject(sym), nil);       	lens.folderLib := Length(all);              	// Paperbacks       	AddArraySlot(all, call kMakeHeaderItem with (kPaperbackName, nil));       	local pbacks := [], root := GetRoot();       	foreach val in root       	do if isFrame(val) and HasVariable(val, kPaperbackSlot)       	then AddArraySlot(pbacks, SPrintObject(val.appSymbol));       	call kAppendPickList with (all, pbacks, nil);       	lens.paperBack := Length(all);              	if kBuild21	and root.(kNewtWorksSym) // !!!g       	then begin       		AddArraySlot(all, call kMakeHeaderItem with (kNewtWorksName, nil));       		AddArraySlot(all, sUnfiled);       		call kAppendPickList with (all,       			foreach val in GetFolderList(kNewtWorksSym, nil)       			collect GetFolderStr(val), nil);	// !!!k       		//lens.newtWorks := Length(all); // for pickActionScript       		end;       /* !!!c       	// Personal Media documents       	foreach store in GetStores()       	do begin       		AddArraySlot(all, call kMakeHeaderItem with (kPersonalMedia, store.name));       		if root.(kPersonalMediaSym)       		then // get blotters for each store       			call kAppendPickList with (all,       				call kGetHandlesFunc with (store, [], 'pt_protoBlotter),       				'item);       		end;       	lens.personalMedia := Length(all);       */       	scriptScroll:newtPopup(all, if kBuild20 then newtview.viewBounds.right-160 else kPopLeft, viewBounds.top);       end,     curPkg: nil,     revertNote:       func(fl)       if fl       then begin       	if target then EntryUndoChanges(target);          :editCode(target, userSources, target, nil);       	end,     DeclareUnit:       func(unitName, INT majorVersion, INT minorVersion, memberIndexes, pkgStr) // !!!b       if unitName       then begin       	local pos, entry := {name: unitName, major: majorVersion, minor: minorVersion};       	if UnitsImport       	then pos := LSearch(UnitsImport, unitName, 0, '|=|, 'name)       	else UnitsImport := [];       	if pos       	then UnitsImport[pos] := entry 			// replace       	else AddArraySlot(UnitsImport, entry);	// add              	if not UnitsMap       	then UnitsMap := {};       	UnitsMap.(unitName) := entry := {indexes: memberIndexes, objects: nil};              	// for UnitReference       	if pkgStr       	then begin       		local part, exportTable, store, pkgRef;       		foreach store in GetStores()       		do  if IsPackageActive(pkgRef := GetPkgRef(pkgStr, store))	// kFindPkg doesn't check active       			then begin       				foreach part in GetPkgRefInfo(pkgRef).parts       				do  if isFrame(part) and // !!!f       						isArray(exportTable := part._ExportTable) and       						exportTable[0].name = unitName // SymbolCompareLex?       					then break entry.objects := exportTable[0].objects;       				break;       				end;       		end;       	UnitsImport;	// !!!h. return value       	end       else UnitsImport := UnitsMap := nil,     setLanguage:       func(sym)       if (if kBuild20 then IsSymbol(sym) else isInstance(sym, 'symbol))       then newtView.lang := sym,     saveNotePara:       func(noteEntry,text,styles,tabs)       begin       	local tfont := prefsCurrent.newtFont;       	local ht := 2*FontHeight(tfont) + // add two lines       		if kBuild20 or nos20       		then TextBounds(text,tfont,RelBounds(0,0,noteWidth,0)).bottom       		else call kSimpleTextHeightFunc with (text,noteWidth,tfont);                 if isFrame(noteEntry) and isSoupEntry(noteEntry)          then begin       		//assumes text already stored       		noteEntry.(stylePath) := styles;       		noteEntry.height := noteEntry.data[0].viewBounds.bottom := ht;       		if kBuild20       		then EntryChangeXmit(noteEntry,nil)       		else EntryChange(noteEntry);       		end          else begin       		local para :=       			{viewStationery: 'para,       			viewBounds: RelBounds(noteLeft,noteTop,noteWidth,ht),       			text: text,       			};       		if styles       		then para.styles := styles       		else para.viewFont := tFont;       		if tabs then para.tabs := tabs;              		noteData := if isArray(noteEntry)       			then begin       				ht := noteHeight; // for entire note       				SetAdd(noteEntry,para,nil);       				end       			else [para];       		noteEntry := {       			viewStationery: kNotesSym,       			height: ht,       			data: noteData,       			timeStamp: Time(),       			};       		if labelsFilter and labelsFilter <> allsym       		then noteEntry.labels := labelsFilter;       		try if kBuild20 or nos20       			then begin       				noteEntry.class := kNotesSym;	//o. for NCU       				userSourceSoup:AddToDefaultStoreXmit(noteEntry,nil);       				end       			else userSourceSoup:AddToDefaultStore(noteEntry)       		onexception |evt.ex|       		do newtView:error('AddToDefaultStore, currentException());       		end;       	//BroadcastSoupChange(newtSoupName); // just do once when we quit       	noteEntry; // also serves as TRUE for save       end,     saveApp:       func(nsym)       begin       	local appView :=       		if (if kBuild20 then IsSymbol(nsym) else isInstance(nsym,'symbol))       		then GetSlot(newtView,nsym)       		else nsym;       	if isFrame(appView)       	then if protoPackage exists       		then begin       			local appTemplate := if appView.isbn then appView.book else appView._proto;       			curPkg := {       				_parent: self, // inherit :error       				_proto: protoPackage,       				//protoProgress: if protoProgress exists then protoProgress, // eventually not needed       				appTemplate: appTemplate,       				smallPackage: prefsCurrent.smallPackage or not (kBuild20 or nos20 or Functions.RestoreSegmentedPackage),       				};       			if appTemplate._package.existingPackage and prefsCurrent.doConfirm       			then begin       				local psym := appTemplate._package.pkgSymbol;       				:Confirm(       					title,       					kReplacePackage && (if psym then psym else appTemplate.appSymbol),       					self,       					'savePackageConfirm);       				end       			else :savePackageConfirm(true);       			end       		else newtView:error ('saveApp, noSaveErr);       	else newtView:error(kSaveAppErr, nsym);       end,     removeMethods:       func(userEntry, reset) // used by filterChanged, deleteNote, saveNote, help_save, savePackageConfirm       begin // also remove any temp_ ??, app, object, etc.??       	local kRemoveCode := func(str)       		if not (if kBuild20 then CharPos(str,$+,0) or CharPos(str,$.,0)       				else StrPos(str,plusStr,0) or StrPos(str,dotStr,0)) // call kStrPosAny with(str,kPathSeps,0,nil) // no + or .       		then begin       			local sym := Intern(str), val := newtView.(sym);       			if (if kBuild20       				then IsFunction(val)       				else isInstance(val,'_function) or isInstance(val,'CodeBlock))       			then RemoveSlot(newtView, sym);       			end;              	if userEntry = userSources       	then begin       		local INT i;       		for i := kTemplateOffset to Length(userSources)-1       		do call kRemoveCode with (userSources[i].item);       		if not isReadonly(defConstants)       		then ReplaceObject(defConstants,{});       		if reset then userSources := eArray;       		end       	else begin       		if IsSoupEntry(userEntry)	// for Delete, filingChanged       		then userEntry := :lookupSource(userSources, call kSubstr with (userEntry.(sourcePath),0,cr));       		if isFrame(userEntry)       		then begin       			call kRemoveCode with (userEntry.item);       			SetRemove(userSources, userEntry); // no sort required       			end;       		end;              	samples := exprButton.originalPopList := evalControls.originalPopList :=       		slotPicker.originalLabelCommands := dummyPopList := NIL;       end,     GetSound: func(soupname,str) :GetNamedResource(soupname,str,'sound),     newtBook:       func(isbn,first,other) // used by NewtATut, NewtTurT, NewtPFB,...       if :ViewIsOpen(self)       then self // already open       else begin       	local viewsym;       	:open();       	:addView(isbn);       	if other // for NewtTurT: [newtDrawing, newtControls]       	then foreach viewsym in other do self.(viewsym):open();              	local fnc := func(isbn)       		begin       			local viewer := GetRoot().(kBookReaderSymbol);       			viewer:close();       			viewer:openBook(isbn);       		end;       	if kBuild20 or nos20       	then AddDeferredCall(fnc,[isbn])       	else AddDeferredAction(fnc, [isbn]);       	first;       	end,     ReorientToScreen:       func()       begin       //print('reorienttoscreen_begin); Print(viewbounds);       	reorienting := TRUE;       	local nsym;       	if all_Apps       	then foreach nsym in all_Apps do self.(nsym):close();       	:SyncView();       	:RedoChildren();       	:editCode(defObjEntry, templateSources, nil, defObjSym);       	//slotPicker:updateText(call kSubstr with(para.text,0,cr));       	reorienting := NIL;       //print('reorienttoscreen_end); Print(viewbounds);       end,     Notify:       func(INT knum, msg1, msg2)       begin       	local nflag := prefsCurrent.notify;       	if ((evalLog exists and evalLog) or isFrame(inspector)) and nflag <= 1	// !!!j       	then begin       // a version to use Newt's error reporting via Eval Log & Inspector       		local epos, nmsg2 := msg2;       //Print(msg2);       		if (if kBuild20 then IsString(msg2) else isInstance(msg2,'string)) and       			BeginsWith(msg2,"Sorry, a") and       			(epos := if kBuild20 then CharPos(msg2,$(,16) else StrPos(msg2,"(",16)) and // skip a little       			(epos := try Floor(StringToNumber( // errornum embedded in parens at end of msg2       							call kSubStr with (msg2,epos+1,")")))       					onexception |evt.ex| do NIL)       		then nmsg2 := { // construct a pseudo-exception frame       				name: msg2,		// keep original       				error: epos,	// extract as a number so Newt can lookup       				};       		:error(['Notify, knum, msg1], nmsg2); // newtView might be nil. currentException() doesn't work here!       		end       	else nflag := 2;              	if nflag >= 1       	then GetRoot():originalNotify(knum, msg1, msg2);       end,     t_refresh: nil,     lookupSource:       func (sources,str)       begin       	if not sources       	then sources := userSources;              	if kBuild20       	then LFetch(sources, str, 0, '|str=|, 'item)       	else call kLFetch with (sources, str, 0, Functions.StrEqual, 'item);       //	local pos := ArrayPos(sources,str,0,func(key,entry) StrEqual(key,entry.item));       //	if pos then sources[pos];       end,     methodChanged:       func(fl, styles, pickerstr)       begin       	SetValue(slotPicker, 'text, if edited := fl then " " else "\uFC01"); // diamond       	if not fl or pickerstr = defNewSym	// Duplicate, Copy Source = "dirty"       	then begin       		if pickerstr       		then slotPicker:updateText(pickerstr);       		SetValue(para, 'styles, styles);       		end;       end,     t_color: vfBlack,     viewBounds: {top: 2, left: 0, right: 236, bottom: 334},     addPage:       func(sym,source) // e.g., 'page1, "PFB.helpBook+page1\n.subject 1\n..."       begin       	local bk := self.book;       	if bk       	then return bk:?addPage(sym,source);              	// see helpBookTemplate       	local subjstart := StrPos(source,cr,StrPos(source,".subject",0))+1;       	local subjend :=   if kBuild20 then CharPos(source,unicodeCR,subjstart) else StrPos(source,cr,subjstart);       	local storystart := (if kBuild20 then CharPos(source,unicodeCR,subjend+1) else StrPos(source,cr,subjend+1))+1;       	local storyend := StrLen(source);       	if source[storyend-1]=unicodeCR then storyend := storyend-1;              	//local subject := SubStr(source,subjstart, subjend-subjstart);       	//local story :=   SubStr(source,storystart, storyend-storystart);       //print(subject); print(story);              	// assumes helpBookTemplate has been deepcloned (or another frame supplied)       	// so arrays can be modified without read-only errors       	local c1 := {data: SubStr(source,subjstart,subjend-subjstart), // subject       					viewFont: styles[1], layout: 32};       	local c2 := {data: SubStr(source,storystart, storyend-storystart), // story       					viewFont: styles[0]};       	AddArraySlot(contents, c1); //book.contents       	AddArraySlot(contents, c2);       	AddArraySlot(self.(kTocPath), {item: c1});              	AddArraySlot(self.(kPagePath),       		{template: self.(kTemplatePath),       		blocks: [{bounds: pgb1, item: c1},       	 	   		{bounds: pgb2, item: c2},],       		});              	if c1 := self.(kHintPath) // page number refs for normal book?       	then AddArraySlot(c1,length(c1)+1);       end,     getSourceSoupEntry:       func(entry) // take userSources entry & return a soup entry       if not IsFrame(entry) or IsSoupEntry(entry)       then entry       else if kBuild20       then EntryFromObj(entry) // ResolveEntryAlias(entry._alias)       else newtCursors[if entry.cursor then entry.cursor else defCursor]:GoToKey(entry._alias)     ,     edited: nil,     appObject: kAppObject,     cleanup: nil,     revertNoteConfirm:       func(target,targetView)       if targetView.prefsCurrent.doConfirm       then targetView:Confirm(       		targetView.title,       		LocObj("Revert", 'revertItem) & $?,       		targetView,       		'revertNote)       else :revertNote(true),     filingChanged:       func()	// 1.x       if not target or edited       then PlaySound(errSound)       else if labelsFilter <> target.labels       then begin       //Print(labelsFilter);       //Print(target.labels);       	:removeMethods(target, true);       	EntryChange(target);       	:editCode(defObjEntry, templateSources, nil, defObjSym);       	end,     prefsCurrent:       {tag: kPackageName,       // these stored as slots in newtView       visible: 		true, 		//t_visible. used in NewtDraw       pen: 			1,			//t_pen. used in NewtDraw       color: 			vfBlack,	//t_color. used in NewtDraw       refresh:		nil,		//t_refresh. used in NewtDraw       labels: 		nil,		//labelsFilter              newtFont: 		userFont10,       print: 			nil,       autoLoad: 		true,       doConfirm: 		true,       smallPackage:	 nil,       askWords: 		nil,       closeConfirm: 	nil,       autoHeap: 		nil,       heapFreq: 		15000,       printRefresh: 	nil,       menuFont:		0x00102800,       debugCompile:	nil,       Ipaid:			nil,       //noLines:		nil,	// !!!d       notify:			0,       },     setInspector:       func(insp,resetfns)       begin       	local root := GetRoot();       	if insp       	then begin       		local orig := Functions.Print = Functions.originalPrint;       		Functions.(EnsureInternal('Print))  := kNewtPrintFunction;       		Functions.(EnsureInternal('Write))  := kNewtWriteFunction;       		self.originalNotify := GetSlot(root,'Notify); // in case AlarmPak or other patch       		root.(EnsureInternal('Notify)) := kNewtNotifyMethod;       		if insp<>true then inspector := insp; // existing (Sloup) inspector ok       		orig;       		end       	else begin       		inspector := NIL;       		if resetfns or not (newtview and :ViewIsOpen(newtview))       		then begin       			Functions.(EnsureInternal('Print))  := Functions.originalPrint;       			Functions.(EnsureInternal('Write))  := Functions.originalWrite;       			if originalNotify       			then root.(EnsureInternal('Notify)) := originalNotify // restore other patch       			else RemoveSlot(root,'Notify);       			true;       			end;       		end;       end,     newtText:       func(exprMeth,sd,se) // used by Delete(undo); NewtATut, NewtTurT       if exprMeth='expr       then begin       	SetValue(evalField, 'text, sd);       	:readEvalPrintContext(se, nil);       	end              else begin       	local slotstr := call kSubStr with (se, 0, cr);       	local entry := :lookupSource(nil, slotstr);       	if entry       	then :editCode(entry, nil, true, entry.item)       	else :editCode(nil, nil, nil, nil);       	SetValue(para, 'text, se);       	:saveNote(nil, self);              	if exprMeth='obj or exprMeth='objExpr       	then :doObj('add, slotstr);       	TRUE; // for undo       	end,     sortSources:       func(ARRAY sourceArray, INT offset) // e.g., userSources, librarySources.  used by collectEntries, saveNote       begin       	local INT i, len := Length(sourceArray)-offset;       	if len=0 then return sourceArray;              	local ARRAY objList := Array(len,NIL);       	local entry, str, dcount, dotproto := ".proto";       	for i:=offset to Length(sourceArray)-1       	do begin       		entry := sourceArray[i];       		str := Clone(entry.item);       		dcount :=        			if not (if kBuild20 then CharPos(str,$+,0) else StrPos(str,plusStr,0))       			then max(0, StrReplace(str,dotStr,dotStr,nil)-1); // count       		StrReplace(str,dotStr,dotTilda,dcount); // replace all for +, all except last for .       		StrReplace(str,".~proto", dotproto,1); // needed for embedded protos?       		if not dcount       		then StrReplace(str,plusStr,dotTilda,nil);       		StrReplace(str,dotproto,"+proto",1); // make protos sort 1st              		objList[i-offset] := [entry, str];       		end;              	Sort(objList, '|str<|, '[pathExpr: 1]);              	for i:=0 to len-1       	do sourceArray[i+offset] := objList[i][0];       	sourceArray;       end,     _proto: @179 /* protoFloater */,     samples: nil,     savePackageConfirm:       func(fl)       if fl       then begin       	local pkg := curPkg, appTemplate := pkg.appTemplate, newtPkg := appTemplate._package, t; // !!!b       	curPkg := nil;       	if newtPkg.existingPackage       	then :RemovePackage(if (t := newtPkg.pkgSymbol) then t else appTemplate.appSymbol);       	//if kBuild20 and isArray(t := newtPkg._ImportTable)	// !!!d,b       	//then newtPkg._ImportTable := TotalClone(t);			// make destructible       	:removeApp(newtPkg.newtSymbol);       	:removeMethods(userSources,NIL);	// !!!k       	if kBuild20       	then AddDeferredSend(pkg, 'savePackage, nil)		// !!!b       	else AddDeferredAction(Functions.Perform, [pkg, 'savePackage, '[]]);       	end       else curPkg := nil,     filterChanged:       func() // category changed. recompile, cache method info.  use NewFilingFilter???       begin       	if not kBuild20 then folderTab:?dirty(); //*** may not refresh properly       //	slotPicker:updateTextR("CheckingÉ");              	// for filing button, add filingChanged, folderChanged methods       	:setPreferenceI('labels, 'labels, labelsFilter);              	:removeMethods(userSources, true); // get rid of earlier methods & sources       	userSources := Clone(newArray);       	userSources[kTemplateOffset-1] := // replace 'pickSeparator for :lookupSource       		call kMakeHeaderItem with (       			if kBuild20 then GetFolderStr(labelsFilter)	// !!!k       			else if labelsFilter then labelsFilter else kUnfiled, nil);       	userSources := :collectEntries(userSources, 1, labelsFilter);              	:errPerform(evalView, 'init, eArray);       	:editCode(defObjEntry, templateSources, nil, defObjSym);       end,     labelsFilter: nil,     deleteNote:       func(target,targetView) // called by deleteNoteAnim       begin       	AddUndoAction('newtText, [nil, nil, para.text]);	// moved from end (target only). uses para              	if target       	then begin       		if edited	// in case header was changed       		then EntryUndoChanges(target);       		:removeMethods(target, true);       		if kBuild20       		then EntryRemoveFromSoupXmit(target,nil)       		else EntryRemoveFromSoup(target);       		:editCode(defObjEntry, templateSources, nil, defObjSym);       		end       	else //:revertNote(target,targetView)       		:editCode(target, userSources, target, nil);       end,     buildApp:       func(target,targetView) //'buildApp       if target       then try evalView:doObj('build, call kSubstr with (target,0,[plusStr,dotStr,cr]))       	onexception |evt.ex|       	do if kBuild20       		then AddDeferredSend(newtView, 'error, ["buildApp", currentException()])       		else AddDeferredAction(Functions.Perform,  [newtView, 'error, ["buildApp", currentException()]])     ,     error:       func(msg,val)       begin       	local spos, src, err, i, linenum;       	local tFont := if prefsCurrent then prefsCurrent.newtFont else kNewtFont;              	PlaySound(errSound);       	if isFrame(msg)       	then begin       		src := msg.source;       		msg := msg.message;       		end;       	// error message          :printVal(msg, printDepth, nil, call kMakeFace with (tFont,tsBold), nil, true, unicodeCR); // !!!d. print always              	// error code       	if isFrame(val)       	then begin       		if (err := val.error) or (val.data and err := val.data.errorCode)       		then :printVal(       			if (spos := SetContains(ROM_errorTable,err))       			then ROM_errorTable[spos+1]       			else if errorCodes and       				((spos := SetContains(errorCodes,err))       				or (spos := SetContains(errorCodes,val.name)))       			then errorCodes[spos+1]       			else if kBuild20 and err <= -60000 and GetGlobalFn('InetGetErrorString)       			then InetGetErrorString(err)       			else LocObj("no err msg avail", 'noErrMsg),       			printdepth, nil, call kMakeFace with (tFont,tsItalic), nil, true, unicodeCR);              		// source line       		if val.data.lineNumber exists // 2.0       		then linenum := val.data.lineNumber       	       		else if src and       			(if kBuild20 then IsString(val.message) else isInstance(val.message,'string)) and       			(spos := StrPos(val.message, "; Line ", 6)) // skip a little       		then linenum := Floor(StringToNumber(       			call kSubStr with (val.message, spos+7, " ")));              		if src and linenum       		then begin       			spos := -1;       			for i:=1 to linenum-1       			do if spos       				then spos := if kBuild20 then CharPos(src, unicodeCR, spos+1) else StrPos(src, cr, spos+1)       				else break;       			if spos       			then :printVal(       				call kSubStr with(src, spos+1,cr),       				printdepth, nil, tFont, nil, true, unicodeCR);       			end;       		end;              	// error value          :printVal(val, printDepth,true, nil, nil, true, unicodeCR);          NIL;       end,     viewOverviewScript:       func()       begin       	if not all_ViewNames // still cached?       	then begin          	local view;          	all_Views := if all_Apps       			then call kAppendList with(       				SetAdd(clone(newt_Views),nil,nil), // add only once       				foreach view in all_Apps // sym             		collect newtView.(view))       			else newt_Views;        		all_ViewNames :=       			foreach view in all_Views       			collect if view then view.title else 'pickSeparator;          	end;       	newtView:newtPopup(all_ViewNames,kPopLeft,nil);       end,     deleteNoteAnim:       func(target,targetView)       targetView:Delete('deleteNote, [target,targetView]),     SetLocalizationFrame:       func(fr)       if isFrame(fr)       then newtView.locFrame := fr,     addstep:       func(sym,template)       if sym and not (if kBuild20 then IsSymbol(sym) else isInstance(sym,'symbol))       then newtView:error(kAddStepExpSym,sym)              else if isFrame(template)       then begin       	local view, myTemplate, userproto := HasSlot(self, kFakeParent);       	local contextSlot := 'stepAllocateContext, childSlot := 'stepChildren;       	if userProto       	then begin       		if not (self.viewChildren and isReadOnly(self.viewChildren))       		then begin       			childSlot := 'viewChildren;       			contextSlot := 'allocateContext;       			end; // otherwise add to stepchildren (kludge)       		myTemplate := self;       		end       	else myTemplate := self._proto;              	local aContext := GetSlot(if isReadOnly(myTemplate) then self else myTemplate,contextSlot);       	if aContext and sym and SetContains(aContext,sym)       	then :removeStep(sym);              	template := :fixFrame(template);       	if isReadOnly(myTemplate) // e.g., newtView       	then begin // copy these (readonly) to view       		if not GetSlot(self,'stepChildren)       		then self.stepChildren :=       			if myTemplate.stepChildren exists       			then clone(stepChildren)       			else [stepChildren: ];       		if not aContext       		then self.stepAllocateContext := aContext :=        			if myTemplate.stepAllocateContext exists       			then clone(stepAllocateContext)       			else [];       		end       	else begin // things to do for user objects (not for adding to Newt)       		if not HasSlot(myTemplate,childSlot)          	then myTemplate.(childSlot) := SetClass([], childSlot); // e.g., [stepChildren: ]       		if sym       		then begin        			myTemplate.(sym) := NIL;       			if not aContext // set initially       			then aContext := myTemplate.(contextSlot) := [];       			end;       		end;              	if sym // named child. add more (both Newt & regular)       	then begin // see :fixFrame       		if prefsEntry.debugCompile       		then template.debug := sym;              		template.preallocatedContext := sym;       		AddArraySlot(aContext,sym);       		AddArraySlot(aContext,template);        		end;              	if userproto       	then begin       		AddArraySlot(myTemplate.(childSlot),template); // usually viewChildren       		if sym then self.(sym) := template;       		end       	else begin       		self:open(); // ***       		view := AddStepView(self, template);       		if sym       		then self.(sym) := view;       		view:dirty();       		end;          view          end       else newtView:error(kAddStepExpFrm,template),     appSymbol: kAppSymbol,     help_save:       func()       begin       	:removeMethods(userSources,NIL);       	if all_Apps       	then :removeApp(all_Apps)       	else all_Views := all_ViewNames := originalPopList := NIL;       	librarySources := prefsEntry := NIL;       	RemoveSlot(NewtView,'prefsCurrent);       	evalControls:close();       end,     inspector: nil,     RemoveSlot:       func(sym)       //if isArray(sym)       //then call PerformVals with (self,'removeSlot,sym) else       begin       	local myTemplate := if HasSlot(self,kFakeParent) then self else self._proto;       	if (if kBuild20 then IsSymbol(sym) else isInstance(sym,'symbol)) and       		HasSlot(myTemplate,sym)       	then RemoveSlot(myTemplate,sym)       	else newtView:error(kRemoveSlotErr, sym);       end,     viewJustify: 0,     copyFolderNewtworks:       constant kFirst0Last0 := '{first: 0, last: 0};              func(folderSym, titleStr, erase, multiple) // !!!i,g. erase=true,"app",nil; multiple=true,nil       if kBuild21 and GetRoot().(kNewtWorksSym)       then begin       	if erase       	then begin       		gc();       		local cursor := GetUnionSoupAlways(kNewtWorksSoupName):Query({       							validTest: func(e) call kLabelEqual with (folderSym, e.labels),       							});       		local entry := cursor:entry();       		while entry       		do begin       			if not IsString(erase) or BeginsWith(entry.title, erase)       			then EntryRemoveFromSoupXmit(entry,nil);       			entry := cursor:next();       			end;       		cursor := nil;       		end;              	local INT i, slen, nextFlush := kVBOFlush;       	// create a Newtworks doc       	local estr, str, textView := BuildContext(kDummyTx), newtworks := GetRoot().(kNewtWorksSym);       	textView:Open();       	if not multiple       	then begin	// create single VBO for all entries       		str := call kNewVBO with (nil, nil, unicodeCR & eline);       		slen := StrLen(str);       		end;              	// copy all Notes folder entries to a single/multiple NewtWorks docs       	for i := kTemplateOffset to Length(userSources)-1       	do begin       		estr := :getSourceSoupEntry(userSources[i]).(sourcePath);       		if multiple       		then begin       			textView:Replace(       				{first: 0, last: textView:GetCountCharacters()},       				{text: estr, styles: [StrLen(estr), kFixedFont]},       				nil);       			newtworks:AdoptEntryFromStationery({       				title: call kSubStr with (estr, 0, cr),       				labels: folderSym,       				saveData: textView:Externalize(),       				hiliteRange: kFirst0Last0,       				margins: kMargin32,       				summary: SubstituteChars(SubStr(estr,0,80), cr, " "),	// !!!i       				},       				'paper,       				GetDefaultStore());       			end       		else begin       			StrMunger(str, slen, 0,	estr, 0, nil);       			StrMunger(str, StrLen(str), 0, if EndsWith(estr,cr) then eline else unicodeCR & eline, 0, nil);       			slen := StrLen(str);       			if (slen*2) >= nextFlush       			then begin       				ClearVBOCache(str);       				nextFlush := nextFlush + kVBOFlush;       				end;       			end;       		end;              	if not multiple       	then begin       		ClearVBOCache(str);       		textView:Replace(       			kFirst0Last0,       			{text: str, styles: [slen, kFixedFont]},       			nil);       		newtworks:AdoptEntryFromStationery({	// add the data to Works       			title: Clone(titleStr),       			labels: folderSym,       			saveData: textView:Externalize(),       			hiliteRange: kFirst0Last0,       			margins: kMargin32,       			summary: SubstituteChars(SubStr(str,0,80), cr, " "),	// !!!i       			},       			'paper,       			GetDefaultStore());       		end;       	textView:Close();       end,     locFrame: {},     LocObj:       func(str, path)       if lang = 'English       then str       else if locFrame.(lang).(path) exists       then locFrame.(lang).(path)       else :error("LocObj for \"" & str & "\" in" && lang & ", no path", path),     realPopIndex:       func(cmd) // typically called from within labelActionScript or pickActionScript       begin       	local scroll, prevOff := if prevPopIndex then 1 else 0;       	if cmd = prevPopIndex       	then scroll := popOffset := if popOffset=lpmax then 0 else popOffset+1-lpmax       	else if cmd = nextPopIndex       	then scroll := popOffset := popOffset+lpmax-prevOff;       	if scroll       	then begin       		:newtPopup(self,NIL,NIL);       		NIL       // return NIL       		end       	else popOffset+cmd-prevOff; // return offset index       end,     title: kTitle,     matchNewtEntry:       func(entry) // used by collectEntries, Notes:getTitle       if entry and isArray(entry.data) and Length(entry.data) > 0       then call kIsNewtObj with (entry.(sourcePath)),     addObj:       func(target,targetView)       if target       then try evalView:doObj('add, call kSubstr with (target,0,cr)) // defer in case of error       	onexception |evt.ex|       	do if kBuild20       		then AddDeferredSend(newtView, 'error, ["addObj", currentException()])       		else AddDeferredAction(Functions.Perform,  [newtView, 'error, ["addObj", currentException()]])     ,     UnitReference:       func(unitName, memberName) // !!!b. see DeclareUnit       if unitName and UnitsMap and UnitsMap.(unitName)       then begin       	local objs  := UnitsMap.(unitName).objects;       	local index := UnitsMap.(unitName).indexes.(memberName);       	if objs and index       	then objs[index];       	end,     DefConst:       func(sym,val)       defConstants.(sym) := if isFrame(val) then :fixFrame(val) else val	// !!!i       ,     removeApp:       func(nsym) // inverse of addApp       if isArray(nsym)       then begin       	local val;       	foreach val in Clone(nsym)       	do :removeApp(val);       	end       else if nsym       then if ((if kBuild20 then IsSymbol(nsym) else isInstance(nsym,'symbol))       			or (isFrame(asym) and nsym := nsym._package.newtSymbol))       		and all_Apps and HasSlot(newtView,nsym)       	then begin       		local appView := newtView.(nsym);       		RemoveSlot(newtView,nsym);       		SetRemove(all_Apps,nsym);       		if Length(all_Apps)=0 then all_Apps := NIL;              		local isbn := appView.isbn;       		if isbn       		then begin       			GetRoot().(kBookReaderSymbol):close(); // just in case       			ReplaceObject(appView.book.data, {});       			BookRemoved(appView.book);       			end       		else begin       			if :ViewIsOpen(appView)       			then appView:close();       			:installApp(appView,nil);       			end;       		appView := all_Views := all_ViewNames := originalPopList := NIL; // uncache       		end       	else newtView:error(kRemoveAppErr,nsym),     RemovePackage:       func(psym)       // :removePackage('hello), :removePackage('|hello:Newt|)       // :removePackage(nil), :removePackage({id:...}) [evalButton:pickActionScript]       begin       	local pkg, nsym, aview;       	if isFrame(psym)       	then pkg := psym              	else if psym=nil       	then begin       /*       		local ARRAY pkgs := [];       		foreach pkg in GetPackages()       		do if not (kBuild20 or nos20) or pkg.store	// !!!c       			then begin       				pkg.item := pkg.title & $, && pkg.size && LocObj("bytes", 'bytesMsg);       				AddArraySlot(pkgs, pkg);       				end;       		Sort(pkgs,'|str<|,'title)       */       		// !!!c       		local ARRAY pkgs := [], stores := GetStores(), pkgStores := Array(Length(stores), nil);       		local INT storeNum;       		local store;       		foreach storeNum,store in stores       		do pkgStores[storeNum] := [];       		foreach pkg in GetPackages()       		do  if storeNum := SetContains(stores, pkg.store)       			then begin       				pkg.item := pkg.title & $, && pkg.size && LocObj("bytes", 'bytesMsg);       				AddArraySlot(pkgStores[storeNum], pkg);       				end;       		foreach storeNum,store in stores       		do begin       			if storeNum > 0       			then AddArraySlot(pkgs, 'pickSeparator);       			AddArraySlot(pkgs, call kMakeHeaderItem with ("Packages", store.name));       			ArrayMunger(pkgs, Length(pkgs), 0, Sort(pkgStores[storeNum], '|str<|, 'title), 0, nil);       			end;              		evalButton:newtPopup(pkgs, if kBuild20 then newtview.viewBounds.right-160 else kPopLeft, NIL);       		pkg := NIL; // pickActionScript may re-invoke :removePackage later       		end              	else begin       		if aview := newtView.(psym) // was it really a newtSymbol?       		then psym := aview._package.pkgSymbol;       		pkg := call kFindPkg with (SPrintObject(       				if psym then psym else aview.appSymbol),true);       		end;              	if pkg       	then begin       		psym := Intern(if kBuild20 then GetPkgRefInfo(pkg).title else pkg.title); // !!!b       		:removeView(psym); // in case in overview as pkg       		if all_Apps       		then foreach nsym in all_Apps       			do if newtView.(nsym).appSymbol = psym       					or newtView.(nsym)._package.pkgSymbol = psym       			then break newtView.(nsym)._package.existingPackage := NIL;       		if kBuild20 or nos20       		then SafeRemovePackage(pkg)       		else RemovePackage(pkg);       		end;       end,     editCode:       func(oldtarg, sourceFrame, newtarg, pickerstr)       begin       	if not (target := oldtarg)       	then begin       		target := defObjEntry;       		pickerstr := defObjSym;       		end;       	local slotSource := target.source; // templateSource, librarySources?              //Print(target);       	if slotSource       	then begin       		if target.dataOffset // e.g. PaperBack, Newtworks       		then slotSource := SubStr(slotSource,target.dataOffset,target.dataLen);       		end              	/*       	else if target.docHandle // !!!c. Personal Media       	then slotSource := target.docHandle:getTemplate():?exportText()       	*/              	else begin // target is a userSource entry or a soup entry       		target := :getSourceSoupEntry(target); // this coerces       		slotSource := target.(sourcePath);       		//styles := target.(stylePath);       		end;              	if not newtarg       	then begin       		target := NIL;       		slotSource := Clone(slotSource);       		end;                 edited := true; // to avoid triggering changes          SetValue(para, 'text, slotSource);          para:scroll(2000,2000);          :methodChanged(pickerstr = defNewSym,       		//if styles then styles else       		call kSourceStyles with (slotSource, nil, prefsCurrent.newtFont),       		pickerstr);       end,     evalView: nil,     run_method:       func(slotstr, methstr, args, slotSource, squote) // used by _methods. also by :doObj       begin       	local val, entry := :getSourceSoupEntry(:lookupSource(userSources, slotstr));       	local code := entry.(sourcePath), slotsym;       	if squote       	then StrReplace(code:=Clone(code), quoteStr,"\\\"", nil);       	StrReplace(slotSource, "^0", code, 1); // ParamStr doesn't work for BIG strings       	StrMunger(slotSource,0,if kBuild20 then CharPos(slotSource,unicodeCR,0) else StrPos(slotSource,cr,0),       			NIL,0,nil); // DELETE 1st line (methstr)       //Print([slotstr,methstr,slotsource]);       	entry := code := EntryUndoChanges(entry); // uncache. NIL       	if slotsym := :saveMethodCode(methstr, slotSource, 999)[1] // always compile methods       	then begin       		val := Perform(self, slotsym, args); // *** :errPerform(self,slotsym,args);       		RemoveSlot(newtView, slotsym);       		val // return value       		end       	else newtView:error(kRunMethodErr, slotstr);       end,     userSourcesoup: nil,     helpBookTemplate:       func()       { // content data structure for book.  see :addPage       help: TRUE,       contents: [],       styles: '[       	10240,   //{family: 'espy, face: 0, size: 10}, // used for text       	1058816, //{family: 'espy, face: 1, size: 10}, // used for headings       	],       browsers: [       	{name: "Contents",  list: []}],   // list of topics       templates: '[{// Page Templates 'Default'       	nColumns: 1,       	column: [{width: 12, type: 0}],       	scripts: [], //['viewClickScript, kNilFunc1],	// !!!f       	}],       rendering: [{       	pageSize: RelBounds(0,0,206,214),       	pages: [], 	// list of pages       	}, ],              // normally added via :doObj. but to access addPage directly, need to add explicitly       _MyParent_: true,	// removed via NewtPack later.       _parent: newtView,	// evalView??       },     collectEntries:       func(sources,comp,filter)       begin // used by filterChanged, selectLibrary(pickAction)       	local INT olen := Length(sources); // for sortSources (before additions via kMakeSourceEntry)       	local newtCursor, entry, slotSource, slotstr, slotsym, spos;       	local ispec := {       			type: 'index,       			validTest: func(e)       				call kLabelEqual with (filter, e.labels)};       	local soupList, icursor, soup, stores;              	if kBuild20       	then begin       		self.defCursor := NIL;       		soupList := [userSourceSoup];       		end       	else begin       		stores := GetStores();       		self.defCursor := SetContains(stores,       			if kBuild20 or Functions.GetDefaultStore exists       			then GetDefaultStore()       			else call kGetDefaultStoreFunc with ());              		newtCursors := Array(Length(stores),NIL);       //	gc();       		soupList := if nos20       			then userSourceSoup:GetSoupList()       			else userSourceSoup.soupList; // undoc!       		end;              	if isArray(soupList) then       	foreach soup in soupList       	do begin       		icursor := if not kBuild20 then SetContains(stores, soup:GetStore());       		newtCursor := if soup then       			if kBuild20 or nos20       			then soup:Query(ispec)       			else Query(soup,ispec);              		entry := newtCursor:?entry();       		while entry       		do begin       			if slotSource := :matchNewtEntry(entry)       			then begin  // valid entry. cache, check objects/compile methods       				spos := if kBuild20 then CharPos(slotSource,unicodeCR,0) else StrPos(slotSource,cr,0);       				slotstr := SubStr(slotSource, 0, spos);       				if comp > 0 then slotPicker:updateTextR(slotstr);       				if :lookupSource(sources, slotstr)       				then newtView:error(dupName, slotstr); // warn       //print([slotstr,stats()]);                		// store most recent even if dup       				call kMakeSourceEntry with(sources, entry, slotstr, iCursor, defCursor);       				entry := EntryUndoChanges(entry); // uncache(NIL)       				slotSource := SubStr(slotSource,spos,nil);       				:saveMethodCode(slotstr, slotSource, comp); // check name,ignore return result (don't store meth for libraryFolder)       				slotSource := nil; // uncache       				end;       			entry := newtCursor:next();                	end;              		newtCursor := NIL;       		if not kBuild20       		then newtCursors[icursor] :=       			if soup       			then if kBuild20 or nos20       				then soup:Query({})       				else Query(soup,'{type: index}); // need generic because of libraries       		end;              	:sortSources(sources, olen);       end,     printVal:       func(val, level, quote, font, refresh, winpr, suffix)       begin       	if evalLog exists and evalLog and (winpr or :ViewIsOpen(evalLog))	// print to Eval Log       	then evalLog:printVal(val, level, quote, font, refresh, suffix);              	if isFrame(inspector)			// print to serial stream...       	then :PrintObject(val, inspector, level, quote, "", suffix)       	else if suffix = unicodeCR 		// print to NTK inspector or ???       	then call Functions.originalPrint with(val)       	else call Functions.originalWrite with(val);       	val;       end,     saveMethodCode:       func(slotstr,slotSource,compmeth) // checks method name, compiles source       // returns array of slotstr & slotsym/nil       begin // THIS ASSUMES slotSource has slotstr stripped off       //write("saveMethodCode: "); Print(slotstr); //Print(slotSource);       	local epos := StrLen(slotstr);       	local pos1 := sub := 0, pos2, ch, err, dpos, ppos;              	// check (subparts of) slotstr name       	if compmeth <=1 // skip for run_method       	then repeat begin       		ppos := if kBuild20 then CharPos(slotstr, $+, pos1) else StrPos(slotstr, plusStr, pos1); // kStrPosAny ... kPathSeps       		dpos := if kBuild20 then CharPos(slotstr, $., pos1) else StrPos(slotstr, dotStr,  pos1);       		pos2 := if dpos or ppos       			then begin       				sub := sub+1;       				if dpos       					then if ppos and ppos < dpos then ppos else dpos       					else ppos;       				end       		else       			if sub > 0 and slotstr[epos-1] = $~       			then epos := epos-1       			else epos;              		err := if pos1 = pos2       		then LocObj("empty", 'emptyMsg)       		else if (pos2 - pos1) > 254       		then LocObj("too long", 'tooLongMsg)       		else if ((ch := slotstr[pos2-1])=$|  and slotstr[pos1]=$| ) or       					(ch = $) and slotstr[pos1]=$( )       		then nil       		else if ch := call kCheckSymbol with (slotstr,pos1,pos2)       		then LocObj("illegal char", 'illegalCharMsg) & $: &&ch;              		end until err or (pos1 := pos2+1) > epos;              //	local chPath := call kCheckPath with (slotstr), err, sub;       //	if Isinstance(chPath,'String) then err := chPath else sub := chPath;              	local slotsym := true;       	local len := StrLen(slotSource), meth, src;       	local mpos := call kStrPosAny with (slotSource,kStartFunc,0, NIL); // method: func(, func (, func native?       	local bpos := StrPos(slotSource,crbrace,0);	// object: {              	if err or BeginsWith(slotSource,crdot) or BeginsWith(slotSource,crspdot)	// .subject (book stuff)       	then nil   // no further checking       	else if sub>=compmeth or (if bpos and mpos then bpos < mpos else bpos)       	then try compile(slotSource)       		  onexception |evt.ex|               do slotsym := newtView:error(       				{message: [LocObj("checking", 'checkingMsg), slotstr], source: slotSource},       				currentException())       	else begin       //Print("intern"&&slotstr);       		slotsym :=  Intern(slotstr);       		err := if HasVariable(evalView, slotsym)       					and not :lookupSource(userSources, slotstr)       				then LocObj("existing system slot", 'existingSysSlotMsg)       				else if not mpos       				then LocObj("func not at start of line", 'funcLineMsg);       		local oldCompilerCompatibility := vars.CompilerCompatibility;       		if not kBuild20 and nos20       		then vars.(EnsureInternal('CompilerCompatibility)) := 0;       		if not err       		then try newtView.(slotsym) :=   // returns method          			begin // compile std method first for errors          				if slotsym = 'init	// !!!i          				then ReplaceObject(defConstants,{});          				src := :fixSource(slotSource); // comments ok...SubStr(slotSource,mpos,len-mpos));       //PRINT(['compile2,src]);               		meth := :fixFrame(call Compile(src) with ());       				if slotstr[0] = $_       				then begin // meth is 'args'       					meth := call kSubStr with (slotSource, StrPos(slotSource,lparen,mpos)+1, rparen);       					src := ParamStr("func(^0):run_method(\"^1\",\"^2\",[^3],\"!!4!!\",NIL)",       							[meth,slotstr,"temp_"&slotstr,meth]);       					StrReplace(src, "!!4!!", "temp_^0", 1); // ??? new ParamStr sub behavior       //PRINT(['compile3,src]);       					call Compile(src) with ();       					end       				else meth;       			end       			onexception |evt.ex|       			do slotsym := newtView:error(       				{message: [LocObj("compiling", 'compilingMsg), slotstr], source: src},       				currentException());              		if not kBuild20 and nos20       		then vars.CompilerCompatibility := oldCompilerCompatibility;       	end;              	if err       	then slotsym := newtView:error([LocObj("name err", 'nameErrMsg), err], slotstr);       	[slotstr,slotsym] // return values       end,     DefineUnit:       func(unitName, members) // !!!b. returns array or nil       if unitName and UnitsImport       then begin       	local entry := LFetch(UnitsImport, unitName, 0, '|=|, 'name);       	if entry       	then begin       		entry := TotalClone(entry);	// since it can be destroyed by NewtPack       		local objs := Array(Length(members), nil), sym, index;       		entry.objects := objs;              		UnitsMap.(unitName).objects := nil;	// these would be obsolete       		foreach sym,index in UnitsMap.(unitName).indexes       		do objs[index] := members.(sym);       		return [entry];       		end;       	end,     PrintObject:       func(val, str, INT level, squote, indent, suffix) // str is a string or stream (serial)       if isFrame(val) or isArray(val)       then begin // previously printArrayFrame       	local listStart := "[", nameSep, valSep := commaSp, listEnd := "]", s, v, root := GetRoot();       	if isFrame(val)       	then begin       		listStart := "{"; nameSep := slotSep; valSep := commaCr & indent; listEnd := "}";       		end;              	call kPrintStr with(str, listStart);       	if not nameSep and ClassOf(val) <> 'Array       	then :PrintObject(ClassOf(val), str, level, nil, indent, slotSep);              	local INT len := 0;       	if level >= 0       	then foreach s, v in val       		do begin       			if s = 'class then v := ClassOf(val);       			if nameSep       			then :PrintObject(s, str, level, nil, indent, nameSep); // print symbol w/ || if nec, but w/o '              			if v and (       				if v = val then v := "Self"       				else if IsMagicPtr(v) then v := $@ & RefOf(v) >> 2       				else if v = newtView then v := kNewt       				else if v = root then v := "Root"       				)       			then call kPrintStr with (str, if v[0]=$@ then v & valSep else kdeepStart & v & kdeepEnd & valSep)       			else :PrintObject(v, str, level-1, squote, indent & printIndent, valSep);              			if (kBuild20 or nos20) and printLength and (len := len+1) >= printLength       			then break call kPrintStr with (str, "É");       			end              	else if (len := Length(val)) > 0       	then call kPrintStr with(str, kdeepStart & kdeepLen & len & kdeepEnd);              	call kPrintStr with(str, listEnd);       	call kPrintStr with(str, suffix);       	end              else begin       	local sval := SPrintObject(val), num;       	call kPrintStr with(str,       		if (if kBuild20 then IsSymbol(val) else isInstance(val,'symbol))       		then if squote       			then $' &       				(if call kCheckSymbol with (sval, 0, StrLen(sval))       				then call kQuoteStr with (sval, vertBar)       				else sval)       			else sval       		else if (if kBuild20 then IsString(val) and not IsRichString(val) else isInstance(val, 'string))       		then if squote       			then call kQuoteStr with (val, quoteStr) // unicode ???       			else val       		else if val = nil       		then NILstring       		else if val = true       		then "TRUE"       		else if (if kBuild20 then IsCharacter(val) else isInstance(val,'Char))       		then if squote       			then if (num := Ord(val)) < 32 or num > 127       				then begin       					local i, hex := "0123456789ABCDEF";       					sval := Clone("$\\u0000");       					for i:= 3 to 6       					do sval[i] := hex[Band(num >> ((6-i) *4), 0xF)]; // 1st mask 0x3??       					sval;       					end       				else if val=$\\       				then "$\\"       				else $$ & val       			else sval       		else if StrFilled(sval)  // number, ???       		then sval       		else if val= call Functions.Ref with(0xEEEE2)       		then "<<weak array>>"       		else if isBinary(val)       		then kdeepStart & ClassOf(val) & $: & kdeepLen & Length(val) & kdeepEnd       		else "???");       	call kPrintStr with(str, suffix);       	end,     removePackageConfirm:       func(target,targetView) targetView:removePackage(nil) // prompt       ,     errorCodes: [],     installApp:       func(appView,install)       // to test de/install mechanism at Newt development time, separately from RUNewt       begin       	local appTemplate := appView._proto;       	local newtPkg := appTemplate._package;       	local psym := newtPkg.pkgSymbol;       	if not psym       	then psym := appTemplate.appSymbol;              	if newtpkg.existingPackage       	then return if install then newtView:error(['installApp, LocObj("existing package", 'existingPkgMsg)], psym);              	local rFrame := newtPkg.rFrame; // cached from earlier install?       	if rFrame       	then begin       		:errPerform(newtPkg, 'removeScript, [rFrame]);       		newtPkg.rFrame := nil;       		end;              	if newtpkg.partData       	then begin       		if install       		then newtpkg:installScript(newtPkg, newtPkg.rFrame := {});	// partData & any partFrame slots       		end       	else begin       		local root := GetRoot();       		//root.(kExtrasSymbol):dropIcon(partFrame);       		appView:close();              		if install       		then begin       			local icon := newtPkg.icon, eTitle := newtPkg.shortTitle;       			local partFrame := {       				app: psym,       				icon: if icon then icon else genericAppIcon,       				text: if eTitle then eTitle else appTemplate.title,       				theForm: appTemplate,       				};              			root.(psym) := appView;       			//root.(kExtrasSymbol):addIcon(partFrame);       			appView._parent := root;       			newtpkg:?installScript(newtPkg.rFrame := partFrame);       			appView:open();       			end       		else begin       			RemoveSlot(root, psym);       			appView._parent := newtView;       			end;       		end;       end,     t_visible: true,     setText:       func(txt)	// for 1.x undo       begin       	SetValue(para, 'text, txt);       	TRUE;       end,     declareSelf: 'base,     buildFolderLib:       func(asym) // asym can be _package frame       if protoPackage exists       then begin   // kPackageStr = "|NewtDevEnv:TKnollSys"              	local libstr, pkgFrame;       	if isFrame(pkgFrame := asym)       	then begin       		asym := pkgFrame.newtSymbol;       		RemoveSlot(pkgFrame, 'newtSymbol);	// thwart removeApp       		end       	else pkgFrame := {};              	if not StrFilled(libstr := SPrintObject(asym))       	then return;              	local libstrSrc := libstr & $: & if pkgFrame.devSignature then pkgFrame.devSignature else "Source";       	libstr := $| & libstr & $|;		// !!!a       	pkgFrame.partData := {};   		// {Foo: []}       	pkgFrame.existingPackage := call kFindPkg with (libstrSrc,nil);       	if not HasSlot(pkgFrame, 'compressed)       	then pkgFrame.compressed := true;                     /* we want to create a plug-in with behavior like this:       GetGlobals().|NewtDevEnv:TKnollSys|.libraries.Foo :=        	[{item: "item1", source: "item1\n...",},       	];       */              	local iscript := ParamStr(       if kBuild20       then       "func(p,r)begin       local g:=GetGlobalVar('^0);if not g then DefGlobalVar('^0,       g:=EnsureInternal({constants:{},libraries:{},protos:{},tools:{},views:{},installed:{}}));       g.libraries.(EnsureInternal('^1)):=p.partData.^1;end"              else        "func(p,r)begin       local s:='^0,x1:=Functions.GetGlobals exists;       local g:=if x1 then GetGlobals().(s)else GetGlobalVar(s);       if not g then begin       g:=EnsureInternal({constants:{},libraries:{},protos:{},tools:{},views:{},installed:{}});       if x1 then GetGlobals().(EnsureInternal(s)):=g else DefGlobalVar(s,g);       end;g.libraries.(EnsureInternal('^1)):=p.partData.^1;end",              [kPackageStr, libstr]);                     	local rscript := ParamStr(       if kBuild20       then       "func(r)RemoveSlot(GetGlobalVar('^0).libraries,'^1)"              else       "func(r)RemoveSlot(if Functions.GetGlobals exists       then GetGlobals().^0.libraries       else GetGlobalVar('^0).libraries,'^1)",              [kPackageStr, libstr]);                     //Print(iscript); Print(rscript);              	local oldCompilerCompatibility := vars.CompilerCompatibility;       	if not kBuild20 and nos20       	then vars.(EnsureInternal('CompilerCompatibility)) := 0;              	pkgFrame.installScript := :fixFrame(call Compile(iscript) with ());	// fix argFrame       	pkgFrame.removeScript  := :fixFrame(call Compile(rscript) with ());              	if not kBuild20 and nos20       	then vars.CompilerCompatibility := oldCompilerCompatibility;              	local INT i, len := Length(userSources) - kTemplateOffset;       	local entry;       	local ARRAY sourceArray := Array(len+1, NIL);       	pkgFrame.partData.(asym) := sourceArray;              	local ifunc := func(entry)       		Clone(newtView:getSourceSoupEntry(entry).(sourcePath));              	sourceArray[0] := call kMakeHeaderItem with (kFolderLib, asym);              	for i:=0 to len-1       	do begin       		entry := userSources[i+kTemplateOffset];       		sourceArray[i+1] :=       			{item: 	Clone(entry.item),       			source: :deferredPackageObject(ifunc, [entry]), // accessed later       			};       		end;              	:saveApp(       		{_proto:       			{appSymbol: Intern(libstrSrc), // pkg symbol: '|Foo:Source|       			_package: 	pkgFrame,       			},       		});       	end,     reloadFolder:       func(target,targetView)       GetRoot().(kAppSymbol):filterChanged(),     viewSetupFormScript:       func()       begin       	target := NIL;       	nos20 := kBuild20 or Functions.isVBO exists;              	local ap := GetAppParams(); // bounds of current screen       	local INT aWid := ap.AppAreaWidth, aHt := ap.AppAreaHeight;       	if aWid < kAppWidth or aHt < kAppHeight // screen too small       	then begin       		:Notify(3, EnsureInternal(title), LocObj("Screen smaller than", 'screenSmallErr) && kAppWidth & $x & kAppHeight);       		return self:close();       		end;              	self.lpmax :=	// for scrolling popup. moved from viewSetupDoneScript       		if kBuild20 or nos20       		then (aHt div 13) - (if GlobalFnExists('PackRGB) then 1 else 4) // adjust #: portrait/landscape/2.1       		else 23;              	if not reorienting       	then begin       		newtView := self.growView := self.targetView := self;       		//self.targetView := {_proto: self, appSymbol: kNotesSym}; // for foldertab?       		//self.newtCursors := self.userSourceSoup := samples := curPathObjects := nil;       		userSources := librarySources := eArray;              		if kBuild20 or nos20       		then begin       			self.prefsEntry := GetAppPrefs(kAppSymbol, {});       			// make local folders same as Notes       			local sym, notelocal :=       				try GetFolderList(kNotesSym, true)       				onexception |evt.ex| do '[];       			local newtlocal :=	// breaks with MoreFolders?       				try GetFolderList(kAppSymbol, true)       				onexception |evt.ex| do NIL;              			if Length(notelocal)=0 or not newtlocal       			then begin       				RemoveAppFolders(kAppSymbol);       				newtlocal := '[];       				end;              			foreach sym in newtlocal       			do  if not SetContains(notelocal,sym)       				then RemoveFolder(sym, kAppSymbol);       			foreach sym in notelocal       			do  if not SetContains(newtlocal,sym)       				then AddFolder(SPrintObject(sym), kAppSymbol);       /*       			if not (notelocal and newtlocal and Length(notelocal) = Length(newtlocal)       				and Length(notelocal) = Length(SetUnion(notelocal,newtlocal,true)))       			then begin       				RemoveAppFolders(kAppSymbol);       				if notelocal       				then foreach sym in notelocal       					do AddFolder(SPrintObject(sym), kAppSymbol);       				end;       */       /*	// broke for ?? plus undocumented       			local localFolders := GetUserConfig('userFolderGroups);	// MoreFolders workaround?       			localFolders.(kAppSymbol) := if isArray(notelocal) then notelocal else [];       			SetUserConfig('userFolderGroups, localFolders);       */       			end              		else begin       			local sysSoup := GetStores()[0]:GetSoup(sysSoupName);       			self.prefsEntry := Query(sysSoup,       				{type:'index,       				indexPath: 'tag,       				startKey: kPackageName,       				//endTest: func(e) not StrEqual(e.tag,kPackageName),       				}):entry();       			if not prefsEntry or not StrEqual(prefsEntry.tag,kPackageName)       			then prefsEntry := sysSoup:Add({tag: kPackageName});       			if prefsEntry.askWords exists // only if set (for 1.x)       			then GetRoot().(kKbdSymbol).(EnsureInternal('askWords)) := prefsEntry.askWords;       			end;              		prefsCurrent := Clone(prefsEntry);       		prefsCurrent._proto := self._proto.prefsCurrent;              		t_pen 	:= prefsCurrent.pen; // for NewtDraw       		t_visible:= prefsCurrent.visible;       		t_color	:= prefsCurrent.color;       		t_refresh := prefsCurrent.refresh;              		local plab := prefsCurrent.labels;       		if startFolder exists // set via Notes:routeScript       		then plab := startFolder;              		// if unknown folder, set to Unfiled(nil)       		if plab and plab <> allsym and       			not (if kBuild20 or nos20       				then SetContains(GetFolderList(kNotesSym,nil),plab)       				else call kFolderList with (plab))       		then plab := NIL;       		:setPreferenceI('labels, 'labels, labelsFilter := plab);       		end;              	if kBuild20 and prefsEntry.viewSize = 'portrait	// ?? kBuild1x or        	then begin       		aWid := min(aWid, 240);       		aHt  := min(aHt,  320);       		end;       	self.viewBounds := RelBounds(       			ap.AppAreaLeft, ap.AppAreaTop, aWid, aHt);       //Print(ap);       //Print(viewbounds);       //	inherited:?viewSetupFormScript();	// this messes up w/ protoDragger       //Print(viewbounds);       end,     fixObjectConst:       func(fn, osyms)	// !!!h       begin       	local slot, val, literals := fn.literals, i;       	if not literals       	then return;              	if not osyms       	then begin       		osyms := [];       		foreach slot,val in defConstants       		do  if call kObjectConst with (val)       			then AddArraySlot(osyms,slot);       		end;              	if Length(osyms) > 0       	then foreach i,val in literals       		 do if (if kBuild20 then IsSymbol(val) else isInstance(val, 'symbol)) and SetContains(osyms,val)       			then literals[i] := defConstants.(val)       			else if (if kBuild20              				then IsFunction(val)              				else isInstance(val,' _function)		// 2.x              					or isInstance(val, 'CodeBlock)) 	// 1.x              			and not isReadonly(val)              		then :fixObjectConst(val, osyms);       end,     routeScripts:       {saveNote:       	{title: LocObj("Save Source", 'saveItem),       	routeScript: 'saveNote},              revertNote:       	{title: LocObj("Revert", 'revertItem),       	routeScript: 'revertNoteConfirm},              divider1: NIL,              addObj:       	{title: LocObj("Add(Obj)", 'addObjItem),       	routeScript: 'addObj},              buildApp:       	{title: LocObj("Build(App)", 'buildAppItem),       	routeScript: 'buildApp},              divider2: NIL,              duplicateNote:       	{title: LocObj("Duplicate", 'duplicateItem),       	icon: if kBuild20 then ROM_routeDuplicateIcon,	// !!!h       	routeScript: 'duplicateNote},              deleteNoteAnim:       	{title: LocObj("Delete", 'deleteItem),       	icon: if kBuild20 then ROM_routeDeleteIcon,		// !!!h       	routeScript: 'deleteNoteAnim},                    deleteAllConfirm:       	{title: kDeleteAll,       	routeScript: 'deleteAllConfirm},                    divider3: NIL,              reloadFolder:       	{title: LocObj("Reload Folder", 'reloadFolderItem),       	routeScript: 'reloadFolder},              selectLibrary:       	{title: LocObj("Select Library", 'selectLibraryItem) & "É",       	routeScript: 'selectLibrary},             	       copySource:       	{title: LocObj("Copy Source", 'copySourceItem) & "É",       	routeScript: 'copySource},              copyAllConfirm:       	{title: kCopyAll,       	routeScript: 'copyAllConfirm},              divider4: NIL,              selectAll:       	{title: LocObj("Select All", 'selectAllitem),       	routeScript: 'selectAll},              writeText:       	{title: LocObj("Write", 'writeItem) & "()",       	routeScript: 'writeText},              divider5: NIL,              removePackageConfirm:       	{title: LocObj("Remove Package", 'removePkgMsg) & "É",       	routeScript: 'removePackageConfirm},       },     readEvalContext:       func(source, context)       begin       	local val, oldCompilerCompatibility := vars.CompilerCompatibility;       	if not kBuild20 and nos20       	then vars.(EnsureInternal('CompilerCompatibility)) := 0;              	if kBuild20       	then call kShowBusyBoxFunc with (nil);              	try begin       		(if context       		then context       		else self)._evalField := val := Compile(source); // read&compile expr              		:fixObjectConst(val,nil);	// !!!h              		val := (       			if context then context       			else if evalView then evalView       			else self):_evalField();     			// eval in newtView or drawView context       		end       	onexception |evt.ex|								// error?       	do newtView:error({message: 'readEvalContext, source: source}, currentException());              	if not kBuild20 and nos20       	then vars.CompilerCompatibility := oldCompilerCompatibility;       	val;       end,     GetNamedResource:       func(soupname, str, field) // for accessing bitmap, sound, icons; assumes a name (or URL) slot       begin       	local soup := GetUnionSoup(soupname);       	if soup       	then begin       		local soupList :=       			if kBuild20 or nos20       			then soup:GetSoupList()       			else soup.soupList; // undocumented       		if not isArray(soupList) or Length(soupList)=0       		then return NIL;              //{structure: 'slot, path: 'URL, type: 'string}       		local resourceSlot := 'name, resourceSymbol, entry;       		local ARRAY ixs := soupList[0]:getIndexes();       		if (kBuild20 or nos20)       			and LSearch(ixs, 'URL, 0, '|=|, 'path)       		then resourceSlot := 'URL	// resourceSymbol=nil. e.g., ImageCache:NewtsCape              		else if not (entry := if kBuild20 or nos20	 // index entry       				then LFetch(ixs, 'name, 0, '|=|, 'path)       				else call kLFetch with (ixs, 'name, 0, Functions.|=|, 'path))       			or not ((resourceSymbol := entry.type='symbol) or entry.type = 'string) // is resource a symbol or string?       		then return NIL;              		local cursor :=       			if kBuild20 or nos20       			then soup:Query({indexPath: resourceSlot})       			else Query(soup, {type: 'index, indexPath: resourceSlot});       		local key, efield, ekey, many := isArray(str);       		local res :=       			foreach key in (if many then str else [str])       			collect       				if (if kBuild20 then IsString(key) else isInstance(key,'string))       				then begin       					if resourceSymbol then key := Intern(key);       					entry := cursor:GoToKey(key);       					if entry and (ekey := entry.(resourceSlot)) and       						(if resourceSymbol then ekey = key else StrEqual(ekey, key))       					then if (efield := entry.(field))       						then begin EntryUndoChanges(entry); efield; end       						else newtView:error(kFieldErr, field)       					else newtView:error(kResourceErr, key);       					end       				else if many then NIL else newtView:error(kResourceExp, key);              		return if many then res else res[0];       		end       	else newtView:error(kSoupErr, soupname);       end,     copyAll:       func(fl)       if fl       then begin       	slotPicker:updateTextR(kCopyAll);       	local entry;       	foreach entry in librarySources       	do if not HasSlot(entry,'pickable)       	then :saveNotePara(       		nil,       		if entry.source       		then if entry.dataOffset  // PaperBack, Newetworks       			then SubStr(entry.source,entry.dataOffset,entry.dataLen)       			else entry.source 	// library       		/*       		else if entry.docHandle // Personal Media	// !!!c       		then entry.docHandle:getTemplate():exportText()       		*/       		       		else :getSourceSoupEntry(entry).(sourcePath), // another folder       		nil,nil);              	// runs :soupChanged & :filterChanged       	if kBuild20 or nos20       	then XmitSoupChange(newtSoupName, kAppSymbol, 'whatThe, NIL)       	else BroadcastSoupChange(newtSoupName);       	end,     duplicateNote:       func(target,targetView)       if target and not targetView.edited       then targetView:editCode(target, targetView.userSources, nil, Clone(defNewSym)) // kludge for now to trick Copy Source dirty       //else PlaySound(errSound)       ,     readEvalPrint:       func(s) // used internally, and by NewtonBooks       :readEvalPrintContext(s,nil),     FileThis:       func(target,labelsChanged,newLabels,storeChanged,newStore)	// 2.x. store stuff doesn't appear?       if not target or edited       then PlaySound(errSound)       else if labelsChanged or storeChanged       then if labelsChanged and target.labels <> newLabels       	then begin       		:removeMethods(target, true);       		target.labels := newLabels;       		if storeChanged       		then :moveTarget(target,newStore)       		else EntryChangeXmit(target,nil);       		:editCode(defObjEntry, templateSources, nil, defObjSym);       		end              	else if storeChanged and EntryStore(target) <> newStore       	then begin       		:moveTarget(target, newStore);       		local entry := :lookupSource(userSources, call kSubstr with (target.(sourcePath),0,cr));       		if entry       		then entry._alias := MakeEntryAlias(target);	// replace. see kMakeSourceEntry       		end              /*       not sure what to do about "folderChanged", i.e., if user adds/renames/removes a folder,       would have to update list of folders, and update current entries?       compatibility with MoreFolders, etc.       */,     pickActionScript:       func(i)       if i := :realPopIndex(i)       then begin       	local view := all_Views[i];       	try begin       		if :ViewIsOpen(view)       		then view:hide();       		view:open();       		end       	onexception |evt.ex|       	do :error("open view", currentException());	              	if kBuild21 and view = GetRoot().(kNewtWorksSym) and prefsEntry.viewSize = 'portrait       	then begin       		self:hide();       		self:show();       		end;       	end,     removeStep:       func(sym)       //if isArray(sym)       //then call PerformVals with(self,'removeStep,sym) //clone(sym)) else       if sym and (HasSlot(self,sym) or HasSlot(self,kFakeParent))       then begin       	local vw, iv, aContext, sChildren;       	local userProto := HasSlot(self,kFakeParent);       	if not userProto and       		(vw := self.(sym)) and :ViewIsOpen(vw)       	then RemoveStepView(self,vw);          RemoveSlot(self,sym);              	if isReadonly(self._proto) // e.g., newtView       	then begin       		sChildren := stepChildren;       		aContext := stepAllocateContext;       		end       	else if self.viewChildren exists and not isReadonly(viewChildren)       	then begin       		sChildren := self.viewChildren;       		aContext := self.allocateContext;       		end       	else begin       		sChildren := self._proto.stepChildren;       		aContext := self._proto.stepAllocateContext;       		end;       	if iv := SetContains(aContext,sym)       	then begin       		SetRemove(sChildren,aContext[iv+1]); // not nec in 2.0?       		ArrayRemoveCount(aContext,iv,2);       		end       	else newtView:error(kRemoveStepChild,sym);       	//:redoChildren(); ???       	end       else newtView:error(kRemoveStepErr, sym),     usersources: eArray,     saveNote:       func(targ, targetView)       if edited       then begin       	local slotSource := para.text; // don't clone.       	local spos := if kBuild20 then CharPos(slotSource,unicodeCR,0) else StrPos(slotSource,cr,0);       	local slotstr := SubStr(slotSource, 0, spos), slotsym;       	local userEntry := :lookupSource(userSources, slotstr); // existing cache entry?       	local tcursor, tid;       	if target       	then if kBuild20       		then tid := MakeEntryAlias(target)       		else begin       			tcursor := SetContains(GetStores(), EntryStore(target));       			if tcursor = defCursor then tcursor := NIL;       			tid := EntryUniqueId(target);       			end;              	samples := evalControls.originalPopList := exprButton.originalPopList := NIL; // *** uncache       	if userEntry       		and (not target or       			  not (if kBuild20       				then IsSameEntry(userEntry._alias, tid)       				else userEntry._alias = tid and userEntry.cursor = tcursor))       		then newtView:error(dupName,slotstr)                 else if slotsym := :saveMethodCode(slotstr,SubStr(slotSource,spos,nil),1)[1] // successfully compiled?          then begin       		//slotSource := Clone(slotSource);       		local val, styles := call kSourceStyles with (slotSource, spos, prefsCurrent.newtFont);       		if target       		then begin       			target.(sourcePath) := slotSource;  // since not cloned...       			target.(stylePath) := styles;       			:saveNotePara(target, slotSource, styles, nil);       			if not userEntry // entry was probably renamed       			then foreach val in userSources       				do if isFrame(val) and       						(if kBuild20       						then IsSameEntry(val._alias, tid)       						else val._alias = tid and val.cursor = tcursor)       					then break :removeMethods(val, true); // updates list       			end       		else begin       			target := :saveNotePara(nil, slotSource, styles, kTabs);       			//***slotPicker.originalLabelCommands := NIL; // uncache       			end;       		if not userEntry       		then begin // new or renamed entry       			if call kMakeSourceEntry with (userSources, target, slotstr, defCursor, defCursor)       			then :sortSources(userSources, kTemplateOffset)       			else return NIL; // re-scan occurred       			end;              		:methodChanged(nil,styles,slotstr);             end;          end,     copyAllConfirm:       func(target,targetView)       begin       	local lib := targetView.librarySources;       	if targetView.edited or Length(lib)=0       	then PlaySound(errSound)              	else if targetView.prefsCurrent.doConfirm       	then targetView:Confirm(       		targetView.title,       		ParamStr(LocObj("Copy all [^0] sources in ^1", 'copyAllMsg),       			[SPrintObject(Length(lib)-1), lib[0].item]),       		targetView,       		'copyAll)              	else targetView:copyAll(true);       end,     nos20: nil,     AddView:       //:addView('|PicoFermiBagels:TKnollSys|) // app symbol (unique)       //:addView("NewtATut")			// book isbn (unique as isbn)       func(sym)       // adds an app/book to the view menu by symbol, isbn       // does not check if already in menu; no current provision for remove       begin       	local appView, bk;       	if isFrame(sym)       	then appView := sym              	else if (if kBuild20 then IsSymbol(sym) else isInstance(sym,'symbol))       	then appView := GetRoot().(sym)              	else if (if kBuild20 then IsString(sym) else isInstance(sym,'string))       		and bk := call kFindBook with (sym,nil) // isbn       	then appView := {book: bk, title: bk.title, isbn: sym, open: kBookOpen};                 if appView           then begin       		if not appView.title       		then appView.(EnsureInternal('title)) := SprintObject(sym); // for :viewList       		//if not ArrayPos(newt_views,appView.title,0,func(t,v) isFrame(v) and StrEqual(t,v.title)) then       			begin             	all_viewNames := all_Views := originalPopList := nil;       			SetAdd(newt_views,nil,true); // add sep if not there yet       			SetAdd(newt_views,appView,nil);       			end;             end;       	appView; // appView or nil returned       end,     GetPictAsBits: func(soupname,str) :GetNamedResource(soupname,str,'bitmap),     reorienting: nil,     version:       func(sym)       begin       	local gData :=       		if kBuild1x and Functions.GetGlobals exists       		then GetGlobals().(kAppSymbol)       		else GetGlobalVar(kAppSymbol);              	local installed := gData.installed, str, spos;              	if (if kBuild20 then IsSymbol(sym) else isInstance(sym,'symbol))       	then // lookup single sym       		if (str := installed.(sym)) or str := installed.(Intern(sym & ksig))       		then if (spos := if kBuild20 then CharPos(str,$ ,0) else StrPos(str," ",0))       			then SubStr(str,spos+1,nil)       			else str       		else eString              	else begin       		// force EvalLog open       		newtView:printVal("Version Information", printdepth, nil, nil, true, true, unicodeCR);       		local s, v;       		foreach s,v in installed       		do Print(       			if s='|protErr1:TKnollSys| or (kBuild20 and s='|protNOS2:TKnollSys|)       			then v && s & $: && LocObj("not needed by", 'notNeededMsg) && kTitle       			else if not kBuild20 and EndsWith(v,"-2") and s<>kSloupSymbol and s<>kSlurpeeSymbol       			then v && s & $: && LocObj("potential 1.x incompatibility", 'potential1xMsg)       			else v       			);       		end       end,     t_pen: 1,     soupChanged:       func(soupName)       if StrEqual(soupName,newtSoupName) and :viewIsOpen(self)       then :filterChanged(),     deleteAll:       func() // called by deleteAllAnim       begin       	slotPicker:updateTextR(kDeleteAll);       	local newtCursor, entry;              	foreach newtCursor in (       		if kBuild20       		then [GetUnionSoup(newtSoupName):Query({       			type: 'index,       			validTest: func(e)       				call kLabelEqual with (labelsFilter, e.labels)})]       		else newtCursors)       	do if newtCursor       	then begin       		entry := newtCursor:reset();       		while entry       		do begin       			if call kLabelEqual with (labelsFilter, entry.labels) // doublecheck for generic cursor       			then if kBuild20       				then EntryRemoveFromSoupXmit(entry,nil)       				else EntryRemoveFromSoup(entry);       			entry := newtCursor:next();       			end;       		end;       	// runs :soupChanged & :filterChanged       	if kBuild20 or nos20       	then XmitSoupChange(newtSoupName, kAppSymbol, 'whatThe, NIL)       	else BroadcastSoupChange(newtSoupName);       end,     removeFake:       func(fr)       begin       	local s,v;       	foreach s,v in fr       	do if isFrame(v) and HasSlot(v,kFakeParent) and s<>'_package       		then begin       			RemoveSlot(v,kFakeParent);       			RemoveSlot(v,'_parent);       			:removeFake(v);       			end;       end,     writeText:       func(targ,tview)       begin       	local offset := GetHiliteOffsets();       	Write(if offset and (offset:=offset[0])       		then SubStr(offset[0].text, offset[1], offset[2]-offset[1])       		else GetView('viewFrontKey).text);       end,     SelectAll:       func(targ, tview)       begin       	local view := GetView('viewFrontKey), txt;       	if txt := view.text       	then view:SetHilite(0, StrLen(txt) ,true);       end,     deferredPackageObject:       func(meth,args) [deferredPackageObject: meth, if Length(args)=1 then args[0] else args]    };folderTab := {viewFlags: 33, _proto: @211 /* clView */};AddStepForm(newtView, folderTab);StepDeclare(newtView, folderTab, 'folderTab);// After Script for folderTabthisView := folderTab;if kBuild20then thisView._proto := protoClockFolderTabelse thisView._proto := protoFolderTab/*	viewSetupFormScript: func() beginif Functions.isVBO exists	then begin		local ptemp := clone(self._proto);		ptemp._proto := protoClockFolderTab;print(ptemp);		self._proto := ptemp;		end;	inherited:?viewSetupFormScript();*/slotPicker :=    {viewBounds: {left: 0, top: 14, right: 223, bottom: 27},     labelActionScript:       func(i) // edit existing (or new=0) method       if i := :realPopIndex(i)       then begin       	local entry := originalLabelCommands[i];       	:editCode(entry, userSources, i >= kTemplateOffset, entry.item);       	end,     pickerSetup:       DefineGlobalConstant('kWidePicker, func(menuFont)       begin       	local INT i;       	local ARRAY children := GetRoot():childViewFrames();       	local pp;       	for i := Length(children)-1 to 0 by -1       	do  if (pp := children[i]).pickItems       		then begin       			pp.bounds := pp.viewBounds;       			pp.pickMaxWidth := GetAppParams().appAreaWidth-10;       			pp.viewFont := menuFont;              		return pp:?SyncView(); // SetValue(clast, 'viewFont, ROM_fontSystem9);       			end;       end);              func()       if edited       then begin	// !!!h       	:Hilite(nil);       	NIL;       	end       else begin       	self.oldText := entryLine.text;       	if not originalLabelCommands then :update(nil);       	if kBuild20 or nos20	// !!!a. allow in 1.x version       	then AddDeferredCall(kWidePicker, [prefsCurrent.menuFont]);	// use wider menu, smaller font       	labelCommands := :realPopCommands(dummyPopList,originalLabelCommands);       	end,     Update:       func(str) // set label commands. init, also scriptView:update       begin       	self.popOffset := 0;       	self.prevPopIndex := self.nextPopIndex := NIL;       	//self.dummyPopList := Array(lpmax+1,NIL); // alloc if nec in :realPopCommands       	self.originalLabelCommands := self.labelCommands := userSources;       	//if str then :updateText(str);       end,     viewSetupFormScript:       func()       begin       	self.viewBounds := Clone(viewBounds);       	viewBounds.right := newtView.viewBounds.right - 19;	// for action button. !!!h was -17          :update(nil);          inherited:?viewSetupFormScript();       end,     textSetup: func() eString,     newtPopup:       func(arg1,arg2,arg3) // called from :realPopIndex. overrides newtView (DoPopup) version       begin // ignore args       	:UpdateText(oldText);       	:popit(indent-2);       end,     updateTextR:       func(str)       if :viewIsOpen(self)       then begin       	:updateText($< & str & $>);       	RefreshViews();       	end,     viewJustify: 8388608,     _proto: @190 /* protoLabelPicker */    };AddStepForm(newtView, slotPicker);StepDeclare(newtView, slotPicker, 'slotPicker);// After Script for slotPickerthisView := slotPicker;begin	//viewBounds.right 0(full); now back to 223(left)	//RemoveSlot(thisView, 'viewSetupFormScript);	// update called in pickerSetup	//thisView.labelCommands := eArray;	//thisView.originalLabelCommands := nil;	if kBuild20	then thisView.alwaysCallPickActionScript := true;endfilingButton :=    {viewBounds: {left: -32, top: 14, right: -16, bottom: 26},     viewJustify: 38,     viewFormat: 0,     _proto: @176 /* protoFilingButton */    };AddStepForm(newtView, filingButton);actionButton :=    {viewBounds: {top: 14, left: -16, right: 0, bottom: 26},     viewFormat: 0,     _proto: @209 /* protoActionButton */    };AddStepForm(newtView, actionButton);scriptScroll :=    {     pickActionScript:       DefineGlobalConstant('kParseSloup, func(str, librarySources)       begin       	local spos, ipos, dpos, epos := if str then StrPos(str,bline,0);       	while epos and (spos := StrPos(str,eline,epos))       	do begin       		spos := spos + StrLen(eline);       		ipos := if kBuild20 then CharPos(str,unicodeCR,spos) else StrPos(str,cr,spos);       		epos := if ipos then StrPos(str,bline,ipos);       		if epos and ipos > spos and epos > ipos and       			(dpos := call kStrPosAny with (str, kStartDefs, ipos, true)) and       			dpos < epos       		then AddArraySlot(librarySources, {       			item: SubStr(str, spos, ipos-spos),       			source: str,       			dataOffset: spos,       			dataLen: epos - spos,       			});       		end;       end);              DefineGlobalConstant('kAddNewtworksItems, func(entry, librarySources)       begin       	local str := call kNewtWorksGetDoc with (entry), pos; // a VBO           if StrPos(str, bline, 0)       	then call kParseSloup with (str, librarySources) // ---- delimited       	else if call kIsNewtObj with (str) and (pos := CharPos(str,unicodeCR,0))       	then AddArraySlot(librarySources, {item: SubStr(str,0,pos), source: str});       end);              func(i)       if i := :realPopIndex(i)       then begin       /*       folders       --- (flen)       package libraries       --- (glen)       paperbacks       ---- (plen)       Newtworks       */       	local lens := originalPopList[0].lengths;       	local currentItem := originalPopList[i], root := GetRoot();              	if kBuild21 and not lens	// !!!h. Newtworks doc       	then begin       		librarySources := [call kMakeHeaderItem with (kNewtWorksName, currentItem.item)]; //(if entry.label then entry.label else kUnfiled) & $: &        		return call kAddNewtworksItems with (EntryFromObj(currentItem.value), librarySources);       		end;              	local currentSym :=       		if i <> 1 and (not kBuild21 or i <> lens.paperBack+1)	// !!!g,c       		then Intern(currentItem); // Notes(Unfiled=1), FolderLib, PaperBack, Newtworks(Unfiled=pb+1)              	if i < lens.folder       	then :collectEntries(librarySources :=       		[call kMakeHeaderItem with (kNotesName,       			if kBuild20 then GetFolderStr(if i<>1 then currentSym) // !!!k       			else if i=1 then kUnfiled else currentSym)],       		0,currentSym); // Notes folder              	else if i < lens.folderLib       	then begin       		local gData :=       			if kBuild20 or nos20       			then GetGlobalVar(kAppSymbol)       			else GetGlobals().(kAppSymbol);       		librarySources := gData.libraries.(currentSym); // package       		end              	else if i < lens.paperBack       	then begin       		librarySources := [call kMakeHeaderItem with (kPaperbackName, currentItem)];       		local pb := root.(currentSym);       		local pbtext :=       			if pb.book       			then begin       				if pb.(kPaperbackSlot) < 2100 or not pb.book.talps       				then pb.book.text;       				end       			else pb.text;              		/* local pbver := pb.(kPaperbackSlot);       			if isInstance(pbver,'string) or pbver < 2000       			then pb.text       			else if pbver < 2100 or not pb.book.talps       			then pb.book.text; */       		call kParseSloup with (pbtext, librarySources);	// !!!g       		end              	else if kBuild21 and root.(kNewtWorksSym) // !!!g       	then begin       		librarySources := [call kMakeHeaderItem with (kNewtWorksName, currentItem)];       		gc();       		local cursor := GetUnionSoupAlways(kNewtWorksSoupName):Query({              			validTest: func(e)              				call kLabelEqual with (currentSym, e.labels),              			});              	local entry := cursor:entry();              	while entry              	do begin              		if prefsCurrent.docLevel	// !!!h              		then AddArraySlot(librarySources, {item: entry.title, value: MakeEntryAlias(entry)})              		else call kAddNewtworksItems with (entry, librarySources);       			entry := nil;       			entry := cursor:next();       			end;       		if prefsCurrent.docLevel       		then :newtPopup(librarySources, newtview.viewBounds.right-160, viewBounds.top); // ??       		end              /* !!!c       	else //if i < lens.personalMedia then       		begin // Personal Media       		// include all docs (w/o checking), sort by name       		librarySources := [call kMakeHeaderItem with (kPersonalMedia, currentItem.item)];       		// get docs       		call kAppendPickList with (librarySources,       			call kGetHandlesFunc with (currentItem.docHandle, [], '[pt_protoTextDoc, pt_protoEditPad]),              		'item);       		end       */              //originalPopList := para.originalPopList := NIL ??       	end,     viewSetupFormScript:       func()       self.viewBounds := call kNewBounds with(newtView,1,subTop,-1,-20,nil,kEditSpacing)     ,     _proto: _v74_0    };AddStepForm(newtView, scriptScroll);StepDeclare(newtView, scriptScroll, 'scriptScroll);para :=    {     viewChangedScript:       func(slot, view)       if slot='text and not edited       then :methodChanged(true,nil,nil),     viewLineSpacing: kEditSpacing,     _proto: _v81_0    };AddStepForm(scriptScroll, para);StepDeclare(newtView, para, 'para);// After Script for parathisView := para;begin // !!!iif kBuild20then begin	thisView.viewSetupFormScript:= kMetaDotSetupFunc; 	thisView.viewQuitScript 	:= kMetaDotQuitFunc;	thisView._keyMetaDot 		:= kMetaDotKeyFunc;	endelse begin	thisView.setEdit := kMetaDotSetEditFunc;	end;	thisView.viewGestureScript 	:= kMetaDotGestureFunc;thisView.pickActionScript 	:= kMetaDotPickFunc;endevalControls :=    {viewBounds: {top: 247, left: 4, right: 210, bottom: 316},     title: kEvalTitle,     pickActionScript:       func(i)       if i := :realPopIndex(i)       then :errPerform(evalView,'doObj,[doObjCmd,originalPopList[i].item]) // ***       ,     viewSetupFormScript:       func()       begin       	self.growView := self;       	self.viewBounds := call knewBounds with(newtView,47,-93,-26,-4,nil,nil);       end       ,     viewFlags: 609,     _proto: _v180_0    };AddStepForm(newtView, evalControls);StepDeclare(newtView, evalControls, 'evalControls);evalField :=    {viewBounds: {left: 0, top: 0, right: 203, bottom: 36},     viewFlags: 145921,     viewLineSpacing: 18,     viewSetupFormScript:       func()       begin       	self.viewFont := prefsCurrent.newtFont;       	//self.viewLineSpacing := FontHeight(viewFont) + 4;       	self.viewBounds := call kNewBounds with(evalControls,2,2,0,-30,nil,viewLineSpacing);       	if kBuild20       	then :?AddKeyCommand(kMetaDotKeyFrame);	// !!!i       	inherited:?viewSetupFormScript();       end,     textFlags:       1<<10 //vSingleKeyStrokes       ,     _proto: @185 /* protoInputLine */    };AddStepForm(evalControls, evalField);StepDeclare(newtView, evalField, 'evalField);// After Script for evalFieldthisView := evalField;beginif kBuild20then begin	//thisView.viewSetupFormScript := kMetaDotSetupFunc; 	thisView.viewQuitScript 	:= kMetaDotQuitFunc;	thisView._keyMetaDot 		:= kMetaDotKeyFunc;	endelse begin	thisView.setEdit := kMetaDotSetEditFunc;	end;	thisView.viewGestureScript 	:= kMetaDotGestureFunc;thisView.pickActionScript 	:= kMetaDotPickFunc;//thisView.viewBounds := NILRemoveSlot(thisView,'viewBounds);endexprButton :=    {text: "Expr",     buttonClickScript:       func()  // return list of sample expressions       begin       	if not (samples // cached (no edits)          			or (samples := :errPerform(evalView,'userSamples,eArray)))       	then begin          	local i, slotSource, len, fpos, fpos2, entry; // slotsym, slotstr       		samples := [];       		for i:=kTemplateOffset to length(userSources)-1          	do begin             	entry := :getSourceSoupEntry(userSources[i]);             	slotSource := entry.(sourcePath);             	entry := EntryUndoChanges(entry); // uncache             	len := StrLen(slotSource);             	fpos := if kBuild20 then CharPos(slotSource,unicodeCR,0) else StrPos(slotSource,cr,0); // end of methodname             	while fpos and (fpos := fpos+3) < len and              	  slotSource[fpos-2]=slash and slotSource[fpos-1]=slash              	do begin       				fpos2 := if kBuild20 then CharPos(slotSource,unicodeCR,fpos) else StrPos(slotSource,cr,fpos);       				AddArraySlot(samples,       					if fpos=fpos2 then 'pickSeparator       					else SubStr(slotSource,fpos,fpos2-fpos));                	fpos := fpos2;                	end;             	end;          	end;       	:newtPopup(samples,0,NIL);       end,     viewBounds: {top: -27, left: 2, right: 28, bottom: -17},     pickActionScript:       func(i)       if i := :realPopIndex(i)       then SetValue(evalField, 'text, Clone(samples[i])),     viewJustify: 8388742,     _proto: @226 /* protoTextButton */    };AddStepForm(evalControls, exprButton);StepDeclare(newtView, exprButton, 'exprButton);// After Script for exprButtonthisView := exprButton;begin	thisView.text := LocObj("Expr", 'exprLabel);endkbdButton :=    {viewBounds: {top: -32, left: 34, right: 65, bottom: -17},     icon: nil,     viewJustify: 134,     buttonClickScript:       func()       GetRoot().(kKbdSymbol):toggle() //newtAlphaKeyboard:toggle();       ,     viewSetupFormScript:       func()	// 2.x only       begin       	if KeyboardConnected()       	then viewFlags := 0;       	inherited:?viewSetupFormScript();       end,     _proto: @198 /* protoPictureButton */    };AddStepForm(evalControls, kbdButton);// After Script for kbdButtonthisView := kbdButton;if kBuild20then begin	thisView._proto := protoKeyboardButton;	thisView.viewBounds := RelBounds(36,-30,23,13);	RemoveSlot(thisView,'buttonClickScript);	RemoveSlot(thisView,'icon);	endelse begin	RemoveSlot(thisView, 'viewSetupFormScript);	thisView.viewFormat := 0;	thisView.icon := ROM_keybuttbitmap;endevalButton :=    {     buttonClickScript:       func()       if evalMode       then begin          local view := HiliteOwner(), offset;          newtView:readEvalPrintContext(       		if view and view.text and (offset := GetHiliteOffsets()[0])       			and offset[2]-offset[1] > 1             then call kSubStr with (view.text,offset[1],offset[2]);             else evalField.text, nil);          end       else :setMode(true,0,0),     viewBounds: {top: -27, left: 71, right: 97, bottom: -17},     evalMode: true,     viewJustify: 8388742,     setMode:       func(mode,count,delay)       if newtDrawing exists       then begin       	if count then newtDrawing.delayCount := count;       	if delay then newtDrawing:setupIdle(delay);       	SetValue(self,'text,if evalMode := mode then kEval else LocObj("Stop", 'stopLabel));       	end,     text: kEval,     pickActionScript:       func(i) // see newtView:removePackage       if i=true or not i       then begin       	if i       	then :RemovePackage(selectedPackage); // also does removeView       	originalPopList := selectedPackage := NIL;       	end       else if i := :realPopIndex(i)       then begin       	self.selectedPackage := originalPopList[i];       	if prefsCurrent.doConfirm       	then :Confirm(       			title,       			kRemovePackage && selectedPackage.item,       			self,       			'pickActionScript)       	else :pickActionScript(true);       	end,     pickCancelledScript: func() originalPopList := NIL,     _proto: @226 /* protoTextButton */    };AddStepForm(evalControls, evalButton);StepDeclare(newtView, evalButton, 'evalButton);// After Script for evalButtonthisView := evalButton;if kBuild20then begin	thisView.viewBounds.left := thisView.viewBounds.left - 4;	thisView.viewBounds.right := thisView.viewBounds.right - 4;	end// Before Script for printPickerbegin	constant kPrintDepthsLen := 4;	// 0-3	constant kLenOffset := 2 + kPrintDepthsLen + 1; 	// kPrintTitle, pickSep, 0-3, pickSep; start of len	constant kPrintLengths := '[nil,16,32,64,128];	DefineGlobalConstant('kPrintLengthsLen, Length(kPrintLengths));endprintPicker :=    {text: "Print",     viewBounds: {top: -30, left: 102, right: 202, bottom: -16},     viewJustify: 132,     prefSym: 'print,     labelCommands:       [kPrintTitle,       'pickSeparator,       "0 (printDepth)", "1", "2", "3",					//kPrintDepthsLen       'pickSeparator,       "\u221E\u (printLength)", "16", "32", "64", "128",	// kPrintLengths       ],     textSetup:       func()       if prefsCurrent.(prefSym)       then kPrintTitle // labelCommands[0]       else "",     labelActionScript:       func(INT cmd)       begin       	if cmd=0       	then :setPreference(prefSym, not prefsCurrent.(prefSym))	// toggle EvalLog              	else if cmd <= kLenOffset-2									// kEvalTitle, pickSep, 0-3       	then printDepth := cmd-2									// set printDepth              	else if (kBuild20 or nos20) and cmd >= lenOffset and cmd <= lenOffset + kPrintLengthsLen - 1       	then printLength := kPrintLengths[cmd-lenOffset];			// set printLength              	:updateText(:textSetup());									// update selection       end,     pickerSetup:       func()       begin       	local i, off := kLenOffset; // off = 2 + kPrintDepthsLen +1 = [printTitle, pickSep], [0-3], [pickSep]       	labelCommands := Clone(_proto.labelCommands); // original list              	// Eval Log       	if prefsCurrent.(prefSym)       	then labelCommands[0] := {item: kPrintTitle, mark: kCheckMarkChar};              	// printDepth       	local item := {       		item: if printDepth=0 then labelCommands[2] else SPrintObject(printDepth), // 0 (printDepth) or #       		mark: kCheckMarkChar};       	if printDepth >= 0 and printDepth <= kPrintDepthsLen-1       	then labelCommands[printDepth+2] := item       	else if kBuild20 or nos20  // add before 2nd pickSep       		then ArrayInsert(labelCommands, item, (off := kLenOffset+1) - 2)       		else labelCommands[(off := kLenOffset+1) - 2] := item; // replace pickSep              	// printLength       	if kBuild20 or nos20       	then begin       		item := {       			item: if printLength then SPrintObject(printLength) else labelCommands[off],	// # or 'none'       			mark: kCheckMarkChar};       		if i := SetContains(kPrintLengths, printLength)       		then labelCommands[i + off] := item       		else AddArraySlot(labelCommands, item);       		end       	else SetLength(labelCommands, off-1);	// omit pickSep and lens              	self.lenOffset := off;              	TRUE;		// the popup should happen       end,     _proto: @190 /* protoLabelPicker */    };AddStepForm(evalControls, printPicker);// After Script for printPickerthisView := printPicker;begin	thisView.text := LocObj("Print", 'printLabel);	if kBuild20	then begin		thisView.viewBounds.left := thisView.viewBounds.left - 4;		thisview.alwaysCallPickActionScript := true;		end;endheapButton :=    {     buttonClickScript:       func()       begin       	running := true;       	gc();       	:SetupIdle(10);       end,     text: kHeap,     viewBounds: {top: -12, left: 2, right: 45, bottom: -2},     viewJustify: 8388742,     viewSetupFormScript:       func()       if (self.running := prefsCurrent.autoHeap)       then :setupIdle(500)       else text := kHeap,     Update:       func()       begin       	if running       	then SetValue(self, 'text, SPrintObject(stats()));       	prefsCurrent.heapFreq;       end,     _proto: @226 /* protoTextButton */    };AddStepForm(evalControls, heapButton);StepDeclare(newtView, heapButton, 'heapButton);// After Script for heapButtonthisView := heapButton;thisView.viewIdleScript := thisView.update // shareevalTitle := {text: kEvalTitle, _proto: _v218_0};AddStepForm(evalControls, evalTitle);saveButton :=    {     buttonClickScript:       func()       begin          local view := GetView('viewFrontMost);          if view=newtView       	then view:saveNote(target,targetView)       	else if SetContains(newt_Views,view)          then view:?save() // About, Newt Drawing, Eval Log          else begin       		if view.roll=view       		then view := view._parent;       		if view := GetVariable(view, '_package)       		then :errPerform(newtView,'saveApp,[view._parent])  // (current) user application       	   else PlaySound(errSound);       		end;       end,     viewBounds: {top: -12, left: -44, right: -18, bottom: -2},     viewJustify: 8388774,     text: kSave,     _proto: @226 /* protoTextButton */    };AddStepForm(evalControls, saveButton);// After Script for evalControlsthisView := evalControls;//not really needed now.  but eventually when grow implemented???//thisView.viewClickScript := kChangeBoundsRemoveSlot(thisView,'viewBounds)status :=    {     pickActionScript:       func(i) // Copy Source. edit proto.  arbitrarily stick this here...       if i := :realPopIndex(i)       then :editCode(librarySources[i], librarySources, nil, defNewSym),     _proto: @220 /* protoStatusBar */    };AddStepForm(newtView, status);StepDeclare(newtView, status, 'status);status_v0_0 :=    {DoInfoAbout: func() AboutNewt:open(),     DoInfoPrefs: func() _PrefsView:open(),     viewBounds: {left: 6, top: 2, right: 19, bottom: 15},     _proto: _v76_0    };AddStepForm(status, status_v0_0);// After Script for status_v0_0thisView := status_v0_0;if kBuild20then thisView._proto := protoInfoButtonelse call kFixupInfoItems with (thisView)// After Script for statusthisView := status;begin	if kBuild20	then begin		thisView._proto := newtStatusBarNoClose;		thisView.menuLeftButtons := [thisView.stepChildren[0], protoSmallKeyboardButton];		ArrayRemoveCount(thisView.stepChildren,0,1);		end;endnewtClose :=    {     buttonClickScript:       func()       if prefsCurrent.closeConfirm='alwaysConfirm       	or (edited and prefsCurrent.closeConfirm='editedConfirm)       then :Confirm(title, LocObj("Really quit Newt?", 'reallyQuitMsg), newtView, 'reallyQuit)       else inherited:buttonClickScript(),     viewBounds: {left: -19, top: -16, right: -6, bottom: -3},     _proto: @163 /* protoLargeClosebox */    };AddStepForm(newtView, newtClose);aboutNewt := LinkedSubview(aboutView,    {viewBounds: {left: 48, top: 192, right: 96, bottom: 208}});AddStepForm(newtView, aboutNewt);StepDeclare(newtView, aboutNewt, 'aboutNewt);evalLog := LinkedSubview(printView,    {viewBounds: {left: 112, top: 192, right: 160, bottom: 208}});AddStepForm(newtView, evalLog);StepDeclare(newtView, evalLog, 'evalLog);_prefsView := LinkedSubview(PrefsLayout,    {viewBounds: {left: 77, top: 213, right: 125, bottom: 229}});AddStepForm(newtView, _prefsView);StepDeclare(newtView, _prefsView, '_prefsView);// After Script for newtViewthisView := newtView;begin	thisView.viewScrollUpScript 	:= kScrollUp;	thisView.viewScrollDownScript	:=  kScrollDown;	//thisView.viewOverviewScript	:= kOverviewScript;	//thisView.viewBounds 			:= NIL;	thisView.(kProtoDict)  			:= kProtoDictFrame; 	// defined in proterr1	thisView.(kErrorCodes) 			:= kErrorCodesArray;	// then referenced in installscript	thisView.(kEvalContextSym)		:= kEvalContextFunc;	RemoveSlot(thisView,'viewBounds); // set in viewSetupFormScript	thisView.appAll := LocObj("All", 'allitem) && "newts";	local children := thisView.stepChildren, len := Length(children);	ArrayRemoveCount(children,2,1);	// remove filing button. why no diamond, or stores?	RemoveSlot(thisView, 'filingChanged);	RemoveSlot(thisView, 'fileThis);	//folderChanged?	if kBuild20	then begin		local sym;		//thisView._proto := protoDragger;		thisView.viewFormat := Bor(thisView.viewFormat, 208); //vfFrameDragger);		thisView.viewFlags := Bor(thisView.viewFlags, vClickable);		thisView.(kProtoDict2)	:= kProtoDictFrame2; // defined in protnos2		foreach sym in '[			// saveNote, deleteNote, addObj, buildApp, selectLibrary,			duplicateNote, deleteNoteAnim, deleteAllConfirm, copySource,			copyAllConfirm, selectAll, writeText, removePackageConfirm,]		do begin			thisView.routeScripts.(sym).routeScript := thisView.(sym);	// !!!h			RemoveSlot(thisView,sym);			end;		RemoveSlot(thisView, 'setText);		// move close button to newtStatusBarNoClose		//children[len-5].menuRightButtons := [children[len-4]];		//ArrayRemoveCount(children,len-4,1);		//RemoveSlot(thisView, 'filingChanged);		thisView.UR := thisView.UnitReference;		thisView.UnitsImport := thisView.UnitsMap := NIL;		end	else begin		//RemoveSlot(thisView, 'fileThis);		RemoveSlot(thisView, 'DeclareUnit);		// !!!b		RemoveSlot(thisView, 'DefineUnit);		// !!!b		RemoveSlot(thisView, 'UnitReference);	// !!!b		RemoveSlot(thisView, 'copyFolderNewtworks);	// !!!g		end;	// para.viewClickScript/pickActionScript (see MetaDot plugin)	thisView.MetaDot := {		popupMeta:	func(para, x1, y1) NIL,		pickMeta:	func(para, i) NIL,		delay:		if kBuild20 then 100 else 400,		};endconstant |layout_Main Newt| := newtView;// End of file Main Newt