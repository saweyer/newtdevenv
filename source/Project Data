// Newt 3.5// Copyright 1993-2000. S. Weyer. All Rights Reserved Worldwide/*use GetFolderStr instead of SPrintObject or & (search for label,folder):2 GetFolderListselectLibrary:pickActionScript (or makeheaderitem)?*/// GLOBALconstant kNewt			:= "Newt";constant kNewtDevEnv	:= "NewtDevEnv";constant kVersionNum  	:= "3.5";constant kVersionInt	:= 35;constant kBetaVersion 	:= "k";DefineGlobalConstant('kVersionString,	kVersionNum & kBetaVersion &	(if kDebugOn then $D) &	(if kProfileOn then $P) &	(if not kIgnoreNativeKeyword then $N) &	(if kBuild20 then "-2") &	(if language<>'english then $~ & Upcase(SPrintObject(language))[0]));DefineGlobalConstant('kTitle, kNewt && kVersionString);DefineGlobalConstant('kVersion, if kDebugOn then kTitle && DateNTime(Time()) else kTitle);DefineGlobalConstant('kBuild21, kBuild20 and TRUE);Print(kVersion && DateNTime(time()));Print("newt" & kVersionInt & kBetaVersion &	(if not kIgnoreNativeKeyword then $N	else if kBuild20	then if language='English		then $2		else Upcase(SPrintObject(language))[0]	)	& ".pkg");Print(kAppSymbol);DeclareGlobalFn('DeclareGlobalFn, 2);DeclareGlobalFn('DefineGlobalConstant,2);DeclareGlobalFn('IsGlobalConstant,1);if not IsGlobalConstant('kBuild20)then DefineGlobalConstant('kBuild20,		platformVersion.platformFile = '|Newton 2.0| or		platformVersion.platformFile = '|MessagePad2.1|);	// ???if not IsGlobalConstant('kBuild1x)then DefineGlobalConstant('kBuild1x, not kBuild20);SetLocalizationFrame({ // use with LocObj(defaultStr, 'symbol)	/*notes: ...Item: and ...Title: generally appear in menus, so can be a little longer	...Msg: appear in dialogs, so can be a little longer.	...Label and other strings should be same length if possible (or shorter)	it may not make sense to translate certain acronyms (HTML, ISBN, ADSP, URL,...)?	some items have have colon or question mark appended by Newt's Cape (is this ok?)	errors: would it be possible to use a single word to indicate error, precededor succeeded by status message?	*/English: {// info buttonaboutItem: 			"About",helpItem:			"Help",prefsItem:			"Prefs",aboutText:			"Newt is an environment for developingapplications using NewtonScript,and saving as packages on your Newton.Newt is shareware \u00A9\u 1993-2000, S. Weyer.After several days of trial use, pleaseregister your copy -- tap Save for Notepadform, tap $ for Kagi, or see register.htm",noteString: 		"download, or Mac or DOS floppies?",shareRegMsg:		"Shareware Registration",newMethod:			"newMethod",newObject:			"newObject",newPage:			"newPage",new:				"new",// action menusaveItem:			"Save Source",revertItem:			"Revert",addObjItem:			"Add(Obj)",buildAppItem:		"Build(App)",duplicateItem:		"Duplicate",deleteItem:			"Delete",deleteAllitem:		"Delete All",deleteAllNotesMsg:	"Delete all Notes in folder",reloadFolderItem:	"Reload Folder",selectLibraryItem:	"Select Library",copyAllitem:		"Copy All",copySourceItem:		"Copy Source",copyAllMsg:			"Copy all [^0] sources in ^1",selectAllitem:		"Select All",writeItem:			"Write",allitem:			"All",personalMediaItem:	"Personal Media",paperbackItem:		"Paperback",folderLibItem:		"FolderLib",newtworksItem:		"NewtWorks",unfiledLabel:		"Unfiled",removePkgMsg:		"Remove Package",replacePkgMsg:		"Replace Package",existingPkgMsg:		"existing package",// Eval ControlsexprLabel:			"Expr",evalLabel:			"Eval",stopLabel:			"Stop",heapLabel:			"Heap",saveLabel:			"Save",printLabel:			"Print",//PrefsaskWordsLabel:		"Ask Words",autoLoadLabel:		"Auto Load",viewSizeLabel:		"viewSize",			//"full", "portrait" ???doConfirmLabel:		"Do Confirm",closeLabel:			"Close",			//"noConfirm", "editedConfirm", "alwaysConfirm" ??reallyQuitMsg:		"Really quit Newt?",autoHeapLabel:		"Auto Heap",heapFreqLabel:		"Heap Freq",noneItem:			"none",printRefreshLabel:	"Print Refresh",newtFontLabel:		"newtFont",versionLabel:		"Version",menuFontLabel:		"menuFont",IpaidLabel:			"I Paid",smartEditLabel:		"Smart Edit",evalLogTitle:		"Eval Log",evalControlsTitle:	"Eval Controls",pageLabel:			"Page",addLabel:			"Add",// errors/messagesnoAppMsg:			"no app",noNewtPackMsg:		"no NewtPack",slotMsg:			"existing slot",noSlotMsg:			"not a slot/method",dupNameMsg:			"duplicate name",notFoundMsg:		"not found",missingMsg:			"missing",emptyMsg:			"empty",tooLongMsg:			"too long",illegalCharMsg:		"illegal char",notAddRemoveMsg:	"not add/remove",invalSegMsg:		"invalid seg. in path expr",existingBookMsg:	"existing book",noErrMsg:			"no err msg avail",bytesMsg:			"bytes",checkingMsg:		"checking",existingSysSlotMsg:	"existing system slot",funcLineMsg:		"func not at start of line",compilingMsg:		"compiling",nameErrMsg:			"name err",screenSmallErr:		"Screen smaller than",notNeededMsg:		"not needed by",potential1xMsg:		"potential 1.x incompatibility",},});DeclareGlobalFn('AddFolder,2);if kBuild20then begin	// so we can use same names	//DefineGlobalConstant('kGetUserConfigFunc, kGetUserConfigDeprecatedFunc);	//DefineGlobalConstant('kGetDefaultStoreFunc, kGetDefaultStoreDeprecatedFunc);	DeclareGlobalFn('Query,2);	DeclareGlobalFn('ClearVBOCache, 1);	endelse begin	DeclareGlobalFn('XmitSoupChange,4);	DeclareGlobalFn('GetAppPrefs,2);	DeclareGlobalFn('AsyncConfirm,3);	DeclareGlobalFn('IsRichString,1);	DeclareGlobalFn('LSearch,5);	DeclareGlobalFn('LFetch,5);	DeclareGlobalFn('GetGlobalVar,1);	DeclareGlobalFn('AddDeferredSend,3);	DeclareGlobalFn('DefGlobalVar,2);	DeclareGlobalFn('GetUserConfig,1);	DeclareGlobalFn('SetUserConfig,2);	DeclareGlobalFn('AddDeferredCall,2);	DeclareGlobalFn('GetDefaultStore,0);	DeclareGlobalFn('IsFunction,1);	DeclareGlobalFn('KeyboardConnected, 0);	DeclareGlobalFn('IsSymbol,1);	DeclareGlobalFn('IsString,1);	DeclareGlobalFn('ArrayInsert,3);	DeclareGlobalFn('GlobalFnExists, 1);	DeclareGlobalFn('GetGlobalFn, 1);	DeclareGlobalFn('AddUndoCall, 2);	DeclareGlobalFn('AddDelayedSend, 4);	DeclareGlobalFn('EntryChangeXmit, 2);	DeclareGlobalFn('MakeEntryAlias, 1);		DeclareGlobalFn('GetPkgRef, 2);	DeclareGlobalFn('IsPackageActive, 1);	DeclareGlobalFn('GetPkgRefInfo, 1);		DeclareGlobalFn('GetFolderStr, 1);	end;DeclareGlobalFn('CharPos,3);DeclareGlobalFn('GetFolderList,2);DeclareGlobalFn('RemoveAppFolders, 1);DeclareGlobalFn('RemoveFolder,2);DeclareGlobalFn('BookAvailable,2);DeclareGlobalFn('SafeRemovePackage,1);DeclareGlobalFn('InetGetErrorString, 1);constant screenhtdiff := 0; // for testing different screen heights(100 vs. 110) in newtView:viewSetupFormScriptconstant kAppWidth  := 240;constant kAppHeight := 240;constant cr := "\n";constant cr2 := "\n\n";// aboutNewtDefineGlobalConstant('kAboutText, LocObj("Newt is an environment for developingapplications using NewtonScript,and saving as packages on your Newton.Newt is shareware \u00A9\u 1993-2000, S. Weyer.After several days of trial use, pleaseregister your copy -- tap Save for Notepadform, tap $ for Kagi, or see register.htm", 'aboutText) &"Steve Weyer17 Timber Knoll Dr.Washington Crossing, PA 18977-1052Internet: <A HREF=\"mailto:weyer@kagi.com\">weyer@kagi.com</A>AOL, CIS: SteveWeyer<A HREF=\"http://members.bellatlantic.net/~sweyer/newton/index.htm\">http://members.bellatlantic.net/~sweyer/newton/index.htm</A>");DefineGlobalConstant('kNoteString,LocObj("download, or Mac or DOS floppies?", 'noteString));DefineGlobalConstant('kRegistrationText,"Registration: ^0" & cr & // version"Date: ^1" & cr2 & // today's date"To:" & cr &"^2" & cr2 &  // kAuthor"From:" & cr &"^3" & cr &   // name"^4" & cr &   // company"^5 "& cr &   // address"^6" & cr &   // city,zip"^7" & cr2 &  // country"^8" & cr2 &  // kNoteString"Email:" & cr &"$45 enclosed." & cr &"Comments:");constant ksig				:= ":TKnollSys";//constant kPackageName		:= "NewtDevEnv:TKnollSys";constant kPackageStr		:= "|NewtDevEnv:TKnollSys|";//DefineGlobalConstant ('kAppSymbol,intern(kPackageName));//constant kRUNewtSymbol	:= '|RunNewtRun:TKnollSys|;constant kSlurpeeSymbol		:= '|Slurpee:TKnollSys|;constant kSloupSymbol		:= '|Sloup:TKnollSys|;DefineGlobalConstant ('kAppObject,[kNewt, "Newts"]);constant kBookReaderSymbol	:= 'Copperfield;constant kKbdSymbol			:= 'alphaKeyboard;constant kNTKsymbol			:= 'newToolsPro;constant kExtrasSymbol		:= 'extrasDrawer;constant kNotesName 		:= ROM_paperrollsoupname;constant newtSoupName 		:= ROM_paperrollsoupname;constant kNotesSym 			:= 'paperroll;/*DefineGlobalConstant('kPersonalMedia, 	LocObj("Personal Media", 'personalMediaLabel));constant kPMSoupName 		:= "DocDir:Gaia";constant kPersonalMediaSym	:= '|Personal Media:Gaia|;*/constant kPaperbackSlot		:= 'PaperbackVers;DefineGlobalConstant('kPaperbackName, 	LocObj("Paperback", 'paperbackLabel));DefineGlobalConstant('kFolderLib,		LocObj("FolderLib", 'folderLibLabel));DefineGlobalConstant('kUnfiled,			LocObj("Unfiled",	'unfiledLabel));DefineGlobalConstant('kNewtWorksName,	LocObj("NewtWorks", 'newtworksLabel));DefineGlobalConstant('kNewtWorksSoupName, "NewtWorks");	// !!!i. unchangingconstant kNewtWorksSym		:= 'NewtWorks;//constant kNewtsCapeSymbol	:= '|Newtscape:Newtscape|; // defined in protoAboutTextconstant kRegistrationPackage := '|Register:FlaSheridn|;constant kSharewareFee := 45.00;DefineGlobalConstant('kRegFrame,	{package: kAppSymbol, 	price:	 kSharewareFee,	platform: 'Newton, 	Version:  kVersionString,	notes:	 kNoteString,	});// info buttonconstant kAboutItem := 0;constant kHelpItem	:= 1;constant kPrefsItem := 2;// more Globalsconstant scrollLines := 8;     // for paraconstant kPopLeft := 10;constant kPopLineHeight := 13; // for popup//constant lpMax := 23; // number of lines in labelPicker-1constant kDragRadius := 5;constant sysSoupName :=  ROM_systemsoupname;constant eArray := '[]; // an empty array  (readonly)constant eString := ""; // an empty string (readonly)constant eFrame := '{}; // an empty frame  (readonly)constant nilString := "NIL";constant lf := "\u000A";DefineGlobalConstant('crlf, unicodeCR & unicodeLF);constant crfunc    := "\nfunc("; // for validTest: source is a  method?constant crfuncsp  := "\nfunc (";// for validTest: source is a  method?constant crfuncnat := "\nfunc native";// for validTest: source is a  method?constant crbrace   := "\n{";     // for validTest: source is an object?constant crdot     := "\n.";     // for validTest: source is a  page?constant crspdot   := "\n .";    // for validTest: (page from a BookMaker book)constant crcomment := "\n//";constant comment   := "//";      // a tea?DefineGlobalConstant('kStartDefs, [crbrace,crfunc,crfuncsp,crfuncnat,crdot,crspdot]);DefineGlobalConstant('kStartFunc, [crfunc,crfuncsp,crfuncnat]);DefineGlobalConstant('kRemovePackage,	LocObj("Remove Package",	'removePkgMsg)  & ":\n");DefineGlobalConstant('kReplacePackage,	LocObj("Replace Package", 	'replacePkgMsg) & ":\n");DefineGlobalConstant('knewMethod, $# & LocObj("newMethod", 	'newMethod));DefineGlobalConstant('knewObject, $# & LocObj("newObject", 	'newObject));DefineGlobalConstant('knewPage,   $# & LocObj("newPage",	'newPage));DefineGlobalConstant('defNewSym,  $# & LocObj("new", 'new));DefineGlobalConstant('templateSources, [{item: knewMethod, source: knewMethod & "\nfunc()\nbegin\n\nend"},{item: knewObject, source: knewObject & "\n{_proto: protoXXX,\nviewBounds: ,\n\n}"},{item: knewPage,   source: knewPage   & "\n.subject 1\nHeading\n.story\ntext"},'pickSeparator,]);DefineGlobalConstant('newArray,		templateSources);DefineGlobalConstant('defObjEntry,	templateSources[1]);DefineGlobalConstant('defObjSym, knewObject); // ="#newObject"DefineGlobalConstant('kTemplateOffset, Length(templateSources));constant lparen :=  "(";constant rparen :=  ")";constant commaSp := ", ";constant commaCr := ",\n";constant plusStr := "+";constant dotStr :=  ".";constant dotTilda:= ".~";constant tilda :=   "~";constant semiSp :=  "; ";constant vertBar := "|";constant quoteStr := "\"";DefineGlobalConstant('kPrintTitle,	LocObj("Eval Log", 'evalLogTitle));DefineGlobalConstant('kEvalTitle,	LocObj("Eval Controls", 'evalControlsTitle));DefineGlobalConstant('kPrefsTitle,	kNewt && LocObj("Prefs", 'prefsItem));DefineGlobalConstant('kAboutTitle, 	LocObj("About", 'aboutItem) && kTitle);DefineGlobalConstant('kHeap,		LocObj("Heap", 'heapLabel));DefineGlobalConstant('kSave,		LocObj("Save", 'saveLabel));DefineGlobalConstant('kEval,		LocObj("Eval", 'evalLabel));DefineGlobalConstant('kPage,		LocObj("Page", 'pageLabel));DefineGlobalConstant('kDeleteAll,	LocObj("Delete All", 'deleteAllitem) & "É");DefineGlobalConstant('kCopyAll,		LocObj("Copy All", 'copyAllitem) & "É");constant noteLeft		:=  10;constant noteTop		:=   2;constant noteWidth		:= 226;constant noteHeight		:= 265;constant evalHeight		:=  30; // height of 2 linesconstant kPrintSpacing	:=  12;	// viewlinespacing in EvalLog, Aboutconstant kEditSpacing	:=  16; // viewlinespacing in editorconstant kNewtFont	:= userFont10;DefineGlobalConstant('kTabs,[10,20,30,40,50,60,70,80,90,100,]); // only up to 8 supported?constant errSound	:= ROM_plinkbeep;constant keyboardIcon := ROM_keybuttbitmap;DefineGlobalConstant ('pgb1, [0, 0,206, 14]);DefineGlobalConstant ('pgb2, [0,16,206,214]);constant kdeepStart := "<<";constant kdeepEnd   := ">>";constant kdeepLen   := $#; //"len=";constant printIndent:= "   ";constant slotSep    := ": ";constant allsym     := '_all;constant slash      := $/;DefineGlobalConstant('noAppErr,		LocObj("no app", 'noAppMsg));DefineGlobalConstant('noSaveErr,	LocObj("no NewtPack", 'noNewtPackMsg));DefineGlobalConstant('slotErr,		LocObj("existing slot", 'slotMsg));DefineGlobalConstant('noSlotErr,	LocObj("not a slot/method", 'noSlotMsg));DefineGlobalConstant('dupName,		LocObj("duplicate name", 'dupNameMsg));DefineGlobalConstant('notFoundErr,	LocObj("not found", 'notFoundMsg));constant subLeft    :=  4;  // left offset of Print,Aboutconstant aboutTop   := 18;  // top offset of Aboutconstant subTop     := 27; // top of Edit,Printconstant subRight   := -4;  // right offset of Print,Aboutconstant subBottom  := -22; // bottom offset of Print,AboutDefineGlobalConstant ('sourcePath,'[pathExpr: data,0,text]);DefineGlobalConstant ('stylePath, '[pathExpr: data,0,styles]);constant kFakeParent := '_MyParent_;DefineGlobalConstant('kAppendList, func(a1,a2) // since AppendList not official	if a1	then ArrayMunger(a1,Length(a1),0, a2,0,nil)	else a2);// GLOBAL functionsDefineGlobalConstant('kRoundTo, func(val,grid,fn) // used in knewBounds, drawView:viewGestureScriptif grid then call Functions.(fn) with (val/grid)*grid else val); // e.g. Floor, RIntToLDefineGlobalConstant('kMakeFace, func(font,face)	// !!!dif isFrame(font)	then begin	local bfont := Clone(font);	bfont.face := Bor(font.face, if face=tsBold then kFaceBold else kFaceItalic);	bfont;	endelse Bor(font,face));DefineGlobalConstant('kSourceStyles, func(slotSource,slotLen,font) // used in saveNote, editCodebegin	if not slotLen	then slotLen :=		if kBuild20		then CharPos(slotSource, unicodeCR, 0)		else StrPos (slotSource, cr, 0);	if not slotLen then slotLen := 0;	[slotLen, call kMakeFace with (font,tsBold), StrLen(slotSource) - slotLen, font];	// !!!dend);//DefineGlobalConstant('kNilFunc,func() nil);DefineGlobalConstant('kNilFunc1,func(x) nil); 	// used for newtAlphaKeyboard, helpbook.viewClickScript//DefineGlobalConstant('kTrueFunc1,func(x) true); 	// used as validTest: predDefineGlobalConstant('kScrollUp,  func() para:scroll(0,scrollLines)); // evalLog, newtViewDefineGlobalConstant('kScrollDown,func() para:scroll(0,-scrollLines));DefineGlobalConstant('kNewBounds, func(view,loffset,toffset,roffset,boffset,xgrid,ygrid)begin	local vb := view.viewBounds;	RelBounds(		if loffset<0 then vb.left+vb.right +loffset else loffset, // - for evalControls		if toffset<0 then vb.top +vb.bottom+toffset else toffset,		call kRoundTo with (			if loffset<0  // was: if roffset>0			then roffset-loffset			else vb.right+roffset-vb.left-loffset,			xgrid,'Floor),		call kRoundTo with (			if toffset<0 // was: if boffset>0			then boffset-toffset			else vb.bottom+boffset-vb.top-toffset,			ygrid,'Floor)		);end);DefineGlobalConstant('kStrPosAny, func NATIVE (str, ARRAY astrs, INT start, minp)if kIgnoreNativeKeywordthen begin // regular version		local pos, mpos, astr;		foreach astr in astrs		do if pos := StrPos(str,astr,start)			then if minp				then (if (not mpos) or pos < mpos then mpos := pos)				else return pos;		mpos;	endelse begin // NATIVE version		local pos, mpos;		//local astr;		//foreach astr in astrs		local int apos;		for apos:=0 to Length(astrs)-1		do if pos := StrPos(str,astrs[apos],start)			then if minp				then (if (not mpos) or pos < mpos then mpos := pos)				else return pos;		mpos;	end);DefineGlobalConstant('kSubStr, func(str, pos, upto) // upto = str or NIL. #160begin	if isFrame(str) then str := str.(sourcePath);	local pos2 := if (if kBuild20 then IsString(upto) else isInstance(upto,'string))		then if kBuild20 and StrLen(upto)=1			then CharPos(str, upto[0], pos)			else StrPos (str, upto, pos)		else if isArray(upto)		then call kStrPosAny with (str, upto, pos, true)		else upto;	SubStr(str, pos, if pos2 then pos2-pos); // (if pos2 then pos2 else StrLen(str)) - posend);DefineGlobalConstant('kCheckSymbol, func NATIVE (str, INT start, INT stop)  // returns error string or NILbegin // used by saveMethodCode, printObject	local INT i;	local ch, kisAlphaNumeric := if kBuild20 then GetGlobalFn('isAlphaNumeric) else Functions.isAlphaNumeric;	for i := start to stop-1	do if not // allow initial digits. check alphanum first			//((ch := str[i]) = $_ or (call kisAlphaNumeric with (ch) and (i>start or ch>=$A)))			(call kisAlphaNumeric with (ch := str[i]) or ch = $_)      then return ch;end);DefineGlobalConstant('kFixDigitName, func(str)	// eliminate numeric prefix in :doObjbegin	local ch, del := 0, i;	for i:=0 to StrLen(str)-1	do if (ch := str[i]) <= $9 and $0 <= ch		then del := del+1		else break;	if del > 0	then StrMunger(str,0,del, nil,0,nil)	else str;end);DefineGlobalConstant('kMakeSourceEntry, func(sources, soupEntry, title, cursor, defCursor) // #162	// given a soup entry, return a cache entry for userSources	begin // used by collectEntries, saveNote		local entry := {			item:	title,			_alias: if kBuild20					then MakeEntryAlias(soupEntry)					else EntryUniqueId(soupEntry),			};		AddArraySlot(sources,entry);		if kBuild20		then return true		else if cursor<>defCursor		then entry.cursor := cursor		else if SetContains(GetStores(),EntryStore(soupEntry)) <> defCursor		then begin			if kBuild1x and Functions.BroadcastSoupChange exists			then BroadcastSoupChange(newtSoupName)			else XmitSoupChange(newtSoupName, kAppSymbol, 'whatThe, NIL);			return NIL;			end;		true; // for saveNote	end);/*DefineGlobalConstant('PerformVals, func(f,msg,aparams) // iterate over list of paramsbegin // e.g., :PerformVals(self,'removeNewt,clone(all_Newts))   local val;   foreach val in aparams   do Perform(f,msg,if isArray(val) then val else [val]);end);*//*DefineGlobalConstant('GetDateStringSpec, func(elemArray)	begin		local spec := 0, val;		foreach val in elemArray do			spec := spec<<kElementShift + val[1]<<kElementTypeWidth + val[0];		spec;	end);DefineGlobalConstant('shortDateStrSpec, call GetDateStringSpec with ([ [kElementMonth,  kFormatNumericDate], [kElementDay, kFormatNumericDate], [kElementYear, kFormatNumericDate], ]));*/constant shortDateStrSpec := 112220; // for ShortDateStr, e.g., 11/29/93// these defined in proterr1.txt//constant kExpSymbol	:= "exp. symbol";//constant kExpFrame	:= "exp. frame";//constant kExpString	:= "exp. string";// some specific errors (these actually take more space, but in pkg rather than heap?)DefineGlobalConstant('kSharewareErr, 	[LocObj("Shareware Registration", 'shareRegMsg), notFoundErr]); // money button in AboutDefineGlobalConstant('kFixFrameMissing,	['fixFrame, LocObj("missing", 'missingMsg)]);DefineGlobalConstant('kFixFrameExp, 	['fixFrame, "exp. frame, sym or num"]);DefineGlobalConstant('kAddSlotExp, 		['addSlot, kExpSymbol]);DefineGlobalConstant('kAddAppExp, 		['addApp, kExpFrame]);DefineGlobalConstant('kSaveAppErr, 		['saveApp, noAppErr]);DefineGlobalConstant('kAddStepExpSym, 	['addStep, kExpSymbol]);DefineGlobalConstant('kAddStepExpFrm, 	['addStep, kExpFrame]);DefineGlobalConstant('kRemoveSlotErr, 	['removeSlot, noSlotErr]);DefineGlobalConstant('kRemoveAppErr, 	['removeApp, noAppErr]);DefineGlobalConstant('kRunMethodErr, 	['run_method, noSlotErr]);DefineGlobalConstant('kFieldErr, 		['field, notFoundErr]);DefineGlobalConstant('kResourceErr, 	['resource, notFoundErr]);DefineGlobalConstant('kResourceExp, 	['resource, kExpString]);DefineGlobalConstant('kSoupErr, 		['soup, notFoundErr]);DefineGlobalConstant('kRemoveStepChild,['removeStep, "child not removed"]);DefineGlobalConstant('kRemoveStepErr, 	['removeStep, noSlotErr]);DefineGlobalConstant('kPathSeps, 		[plusStr, dotStr]);DefineGlobalConstant ('kPagePath,'[pathExpr: rendering,0,pages]);DefineGlobalConstant ('kHintPath,'[pathExpr: rendering,0,contents,0]);DefineGlobalConstant ('kTemplatePath,'[pathExpr: templates,0]);DefineGlobalConstant ('kTOCPath,'[pathExpr: browsers,0,list]);DefineGlobalConstant('kBookOpen, func()	if Length(book.contents) > 0	then GetRoot().(kBookReaderSymbol):openBook(isbn));DefineGlobalConstant('kLFetch, func(ARRAY a, item, INT start, test, path)begin // like limited LFetch for 1.x. if path=nil, use ArrayPos directly	local entry, val;	foreach entry in a	do if (val := entry.(path)) and call test with (item, val)	then return entry;	NIL;end);// same as Newt's CapeDefineGlobalConstant('kFindBook, func(isbn,libentry) // used by addApp, removeApp, addViewbegin	local viewer := GetRoot().(kBookReaderSymbol), nos20 := kBuild20 or HasVariable(viewer,'getLibraryEntry);	local libook := viewer:whereIsBook(isbn);	if (kBuild20 or nos20) and libook and		(not isFrame(libook.bookSoup)									// <bad pkg ref>		or not try libook.bookSoup.book onexception |evt.ex| do NIL)	// *** evt.ex.fr ***	then begin // see kBookCleanup		RemoveSlot(viewer.library, Intern(isbn)); // NOS 2.x bug. badly removed help book?		libook := NIL;		end;	// don't bother with thawing	if libook	then if libentry		then if kBuild20 or nos20			then libook.library			else begin				if viewer.library				then call kLFetch with (viewer.library.books, isbn, 0, Functions.StrEqual, 'isbn, nil);				end		else if libook.bookSoup and			(not nos20 or not libook.library or libook.library.bookPresent>0 or libook.bookSoup.help)		then libook.bookSoup.book;end);// used by addApp, removePackage, buildFolderLib (declareUnit?)DefineGlobalConstant('kFindPkg, func(pkgname,retpkg) // !!!b. same name as Newt's Cape, but extra argif kBuild20then begin	local store, pkg;	foreach store in GetStores()	do  if pkg := GetPkgRef(pkgname, store)			// active?		then return if retpkg then pkg else TRUE;	// pkg if binary obj rather than frame	NIL;	endelse begin	local pkg := call kLFetch with (GetPackages(), pkgname, 0, Functions.StrEqual, 'title); // no nil final arg	if pkg	then if retpkg then pkg else TRUE;	end);/*DefineGlobalConstant('kFindPkg, func(str,retpkg)begin	local pkg :=       	if kBuild20       	then LFetch(GetPackages(), str, 0, '|str=|, 'title)		else call kLFetch with (GetPackages(), str, 0, Functions.StrEqual, 'title);	if retpkg	then pkg	else if pkg	then TRUE;end);*/DefineGlobalConstant('kPrintStr, func(str, val) // used by printObjectif (if kBuild20 then IsString(str) else isInstance(str,'string))then StrMunger(str,StrLen(str),0, if val=unicodeCR then cr else val,0,nil)else begin	if val=unicodeCR	then val := crlf	else if (if kBuild20 then CharPos(val, unicodeCR, 0) else StrPos(val, cr, 0))	then StrReplace(val:=Clone(val), cr, crlf, nil);	str:Output(val,nil);	if not HasVariable(str, 'firstLineSpec) 	// !!!c	then str:FlushOutput();		// older Sloup. eventually remove this...	end);DefineGlobalConstant('kQuoteStr, func(str,qstr) // used by printObject	begin		if StrPos(str, qstr, 0)		then StrReplace(str := Clone(str), qstr, $\\ & qstr, nil);		qstr & str & qstr;	end);DefineGlobalConstant('kNewtPrintFunction, func(val)	begin		local newt := GetRoot().(kAppSymbol), prefs := newt.prefsCurrent;		newt:printVal(val, printDepth, true, nil,			if prefs then prefs.printRefresh,			if prefs then prefs.print,			unicodeCR);	end);DefineGlobalConstant('kNewtWriteFunction, func(val)	begin		local newt := GetRoot().(kAppSymbol), prefs := newt.prefsCurrent;		newt:printVal(val,printdepth,nil,nil,			if prefs then prefs.printRefresh,			if prefs then prefs.print,			"");	end);DefineGlobalConstant('kNewtNotifyMethod, func(num,v1,v2)	GetRoot().(kAppSymbol):Notify(num,v1,v2));/*DefineGlobalConstant('kSubSeq, func(a,start,count) // like SubStr for array	ArrayMunger([],0,nil,a,start,count));*//*  readonly error!?DefineGlobalConstant('kCheckPath, func NATIVE (slotstr) // use this from saveMethodCode. return string(err) or #	begin		local INT pos1 := sub := 0, pos2, epos := call Functions.StrLen with (slotstr);		local ch, dpos, ppos;      		// check (subparts of) slotstr name		repeat begin			ppos := if kBuild20 then CharPos(slotstr, $+, pos1)				else StrPos(slotstr, plusStr, pos1); // kStrPosAny ... kPathSeps			dpos := if kBuild20 then CharPos(slotstr, $., pos1)				else StrPos(slotstr, dotStr,  pos1);			pos2 :=				if dpos or ppos				then begin					sub := sub+1;					if dpos					then if ppos and ppos < dpos then ppos else dpos					else ppos;					end				else if sub > 0 and slotstr[epos-1] = $~				then epos := epos-1				else epos;      			if pos1 = pos2			then return LocObj("empty", 'emptyMsg)			else if (pos2 - pos1) > 254			then return LocObj("too long", 'tooLongMsg)			else if ch := call kCheckSymbol with (slotstr,pos1,pos2)			then return LocObj("illegal char", 'illegalCharMsg) & $: && ch;      			end until (pos1 := pos2+1) > epos;		sub;	end);*/DefineGlobalConstant('kFolderList, func(lab) // if lab=nil, return frame/arraybegin	local folders;	if kBuild20 or Functions.GetFolderList exists	then begin // 2.0 CheckThatFolderExists(prefsEntry) buggy on 2.0			folders := call Functions.GetFolderList with (kNotesSym, nil); // array			if lab			then SetContains(folders,lab)			else folders;		end	else begin // 1.x		folders := call kGetUserConfigFunc with ('userFolders); // frame		if lab		then HasSlot(folders, lab)		else folders;		end;end);DefineGlobalConstant('kAppendPickList, func(a1,a2,field) // added field. selectLibrary, pickActionScriptArrayMunger(a1,Length(a1),0, Sort(a2,'|str<|,field),0,nil));DefineGlobalConstant('kMakeHeaderItem, func(str,str2) // selectLibrary, pickActionScript, buildFolderLibbegin	constant dashes := "--";	if str2	then str := str & $: & str2;	{item: dashes & str & dashes,	pickable: NIL,	};end);DefineGlobalConstant('kGetHandlesFunc, func(docHandle, ARRAY items, docClass) // for Personal Media blotters,docsbegin /* 	docHandle	store or blotter	items		array	docClass	'pt_protoBlotter, 'pt_protoTextDoc, 'pt_protoEditPad*/	local docMngr := GetRoot().(kPersonalMediaSym).pt_clDocMngr;	local pmnew := docMngr.version;	local flstuff := // used in RQuery and GetChildren		if pmnew		then '{none: [tagClDocMngrRecycled]}	// >= 2.1		else func(fl) BAND(fl,1)=0;  			// 1.55,2.0	local docHandles :=		if docClass = 'pt_protoBlotter		then begin			local args := [docHandle, docClass, flstuff, nil];			if pmnew then AddArraySlot(args, nil);			Perform(docMngr:new(kPMSoupName), 'RQuery, args); 	// get blotters for store			end		else docHandle:GetChildren(docClass, flstuff, nil);	// get docs for blotter	if pmnew	then begin // cursor based. >= 2.1		docHandle := docHandles:entry();		while docHandle		do begin			AddArraySlot(items,				{item: docHandle:GetTitle(), docHandle: docHandle});			docHandle := docHandles:next();			end;		end	else if isArray(docHandles)	then foreach docHandle in docHandles		do AddArraySlot(items,			{item: docHandle.title, docHandle: docHandle});	items;end);constant kConstant 		:= 'constants; // for protoDictconstant kProto	   		:= 'protos;    // for errorCodesconstant kProtoDict		:= '|protErr1:TKnollSys|;constant kProtoDict2	:= '|protNOS2:TKnollSys|;constant kErrorCodes	:= 'errorCodes;constant kInstalled		:= 'installed;constant kEvalContextSym := 'getEvalContext;DefineGlobalConstant('kEvalContextFunc, func()begin	local evalContext, evalTemp, fr;	local gData :=		if kBuild1x and Functions.GetGlobals exists		then GetGlobals().(kAppSymbol)		else GetGlobalVar(kAppSymbol);	evalContext := evalTemp := {_parent: GetRoot()};	// e.g., protoDict, ViewCnst, PlatFunc	foreach fr in gData.(kConstant)	do evalTemp := evalTemp._parent :=		{_parent: evalTemp._parent, _proto: fr};	evalContext;end);DefineGlobalConstant('kIsNewtObj, func(slotSource) // used by matchNewtEntry, kNewtWorksDoItFuncbegin	local spos;	if (if kBuild20		then isString(slotSource) and			not IsRichString(slotSource) and			spos := CharPos(slotSource, unicodeCR, 0)		else isInstance(slotSource, 'string) and			spos := StrPos(slotSource, cr, 0)) and		spos > 0 and		slotSource[0] <> $< and //not BeginsWith(slotSource, "<") and // non-empty, possible HTML?		call kStrPosAny with (slotSource, kStartDefs, spos, NIL)	then slotSource;end);// ----------// NotesDefineGlobalConstant('kNotesGetHighlightedText, func(target)if HiliteOwner() and target = GetVariable(HiliteOwner(), 'realData) and GetHiliteOffsets()then begin	local ARRAY offset := GetHiliteOffsets()[0];	local start := offset[1];	if start	then SubStr(offset[0].realData.text, start, offset[2]-start);	end);DefineGlobalConstant('kNotesGetTitle, func(target)// for GetTitle slot of routeframeif targetthen begin	local str := call kNotesGetHighlightedText with (target);	if str	then kNewtDevEnv & $: & LocObj("Eval", 'evalLabel)	else if GetRoot().(kAppSymbol):matchNewtEntry(target)	then kNewtDevEnv & $: & LocObj("Add", 'addLabel);	end);DefineGlobalConstant('kNewtDoitFunc, func(str)begin	local newt := GetRoot().(kAppSymbol);	newt:open();	if kBuild1x and Functions.AddDeferredAction exists	then AddDeferredAction(		Functions.Perform, [newt, 'readEvalPrintContext, [str, nil]])	else AddDeferredSend(newt, 'readEvalPrintContext, [str, nil]);end);DefineGlobalConstant('kNotesRouteScript, func(target,targetView)begin // for RouteScript slot of routeframe	local str := call kNotesGetHighlightedText with (target);	if str	then call kNewtDoitFunc with (str)	else begin		local newt := GetRoot().(kAppSymbol);		newt:open();		newt.startFolder := target.labels;		if kBuild1x and Functions.AddDeferredAction exists		then AddDeferredAction(			Functions.Perform, [newt, 'addObj, [target,newt]])		else AddDeferredSend(newt, 'addObj, [target,newt]);		end;end);constant kNewtRouteScriptSym := 'NewtDevRouteScript;DefineGlobalConstant('kNotesRouteItem, { // for routeScript array (GetRouteScripts)GetTitle: 			kNotesGetTitle,//icon:				call kGetResource with (...),tag:				kAppSymbol,routeScript:		kNotesRouteScript,});DefineGlobalConstant('kNotesProtoItem, { // for Notes _proto chainGetRouteScripts:	func(targetInfo)begin	local routes := [kNotesRouteItem], oldRoutes;	if oldRoutes := inherited:?GetRouteScripts(targetInfo)	then routes := SetUnion(routes, oldRoutes, true);	SetUnion(routes, routeScripts, true);end});// ----------DefineGlobalConstant ('kAddPatchFunc, func(target, template)if targetthen begin	// init the patch	local patch := EnsureInternal({}), sym, val;	// copy all of the patched slots (including tag)	foreach sym, val in template	do patch.(EnsureInternal(sym)) := val;	patch.(EnsureInternal('tag)) := EnsureInternal(kAppSymbol);	// link into the target's proto chain	patch.(EnsureInternal('_proto)) := target._proto;	target._proto := patch; // returns patch	end);DefineGlobalConstant('kRemovePatchFunc, func(target)begin	local nextProto;	if target	then while nextProto := target._proto	do  if nextProto.tag = kAppSymbol		then break target._proto := nextProto._proto		else target := nextProto;end);// ----------// NewtWorksDefineGlobalConstant('kNewtWorksDoItFunc, func(viewDefView, newtAppBase)	// newtAppBase is unusedbegin	// check if anything is selected	local range := viewDefView:GetHiliteRange(), source;	// if nothing is selected, treat it as 'Select All'	if range.first = range.last	then begin	  	range.first := 0 ;	  	range.last 	:= viewDefView:GetCountCharacters() ;		end;	local source := viewDefView:GetRangeData(range, 'text);	local newt := GetRoot().(kAppSymbol);	newt:open();	AddDeferredSend(newt, 'newtText,		[if call kIsNewtObj with (source) then 'obj else 'expr, source, source]);end);DefineGlobalConstant('kToolFrame,	{ // see Rot13 exampledataTypeSymbol: 'paper,		// REQUIRED: ('paper for word processor; 'drawPaper for drawing app)item: 			kNewtDevEnv,// REQUIRED: appears in popup in tool picker.keyCommand: {				// optional	char:		$1,			// cmd-!	showchar:	$!,	modifiers:	if kBuild20 then kCommandModifier,	//1 << 25	keyMessage:	'DoNewtDevEnv,	keyFn:		func(viewDefView)					call kNewtWorksDoItFunc with (viewDefView, nil),	// newtAppBase is unused	name:		kNewtDevEnv,	category:	"General",	},// REQUIRED: called when user selects the item in the Tools pickercmdFunc:	kNewtWorksDoItFunc,});DefineGlobalConstant('bline, "\n-----");DefineGlobalConstant('eline, "-----\n");DefineGlobalConstant('kMargin32,	SetBounds(32, 32, 32, 32)); // !!!gif kBuild21then DefineGlobalConstant('kDummyTx, {	// !!!g. from Newt's Cape	_proto: protoTxView,	viewBounds: SetBounds(0,0,0,0),	viewFlags: 0,	ReorientToScreen: ROM_DefRotateFunc,	viewSetupFormScript: func()	begin		inherited:?viewSetupFormScript();		:SetGeometry(nil, 0, 0, kMargin32); // how to wrap long lines?		:SetStore(GetDefaultStore());	end,});if kBuild21then DefineGlobalConstant('kVBOFlush, 20*1024); // !!!gif kBuild21then DefineGlobalConstant('kNewVBO, func(store, cl, dlen)	// the recommended initializationbegin	gc();	local data := if not IsInteger(dlen) then dlen;		// string or binary obj	local vbo :=		(if store then store else GetDefaultStore()):NewCompressedVBO(			if cl then cl else 'string,			// cl == binary			if data then Length(data) else dlen,// length of string or binary or #			kTextCompander, 					//kBitmapCompander unreliable for bin?			nil);	if data	then begin		BinaryMunger(vbo, 0, nil, data, 0, nil);		if Length(data) > 2		then ClearVBOCache(vbo);		end;	vbo;end);if kBuild21then DefineGlobalConstant('kNewtWorksChunkSize, 2048);	// !!!gif kBuild21then DefineGlobalConstant('kNewtWorksGetDoc, func(entry)	// !!!g. from Newt's Capebegin	local textView := BuildContext(kDummyTx);	textView:Open();	textView:Internalize(entry.saveData);	// kCopyNewtWorksRange, func(textView, range, cleanup)	local INT start := 0, last := textView:GetCountCharacters();    local INT i, nextFlush := kVBOFlush, slen := 0;	local cstr, str := call kNewVBO with (nil, nil, "");	for i := start to last by kNewtWorksChunkSize    do begin		cstr := StringFilter( // strip out graphics characters					textView:GetRangeData(						{first: i, 						last: min(last, i + kNewtWorksChunkSize),						}, 'text),					"\u2206\u", 'rejectAll);		StrMunger(str, slen, 0,	cstr, 0, nil);	// !!!b. was i,nil		slen := slen + StrLen(cstr);		if (slen*2) >= nextFlush		then begin			ClearVBOCache(str);			nextFlush := nextFlush + kVBOFlush;			end;		end;	ClearVBOCache(str);	textView:close();	str;end);DefineGlobalConstant('kFixedFont, 	{family: 'Courier, 		face: kFaceNormal, size: 10, });DefineGlobalConstant('kLabelEqual, func(elabel1, elabel2)	// elabel1=labelsFilter, elabel2=entry.labelselabel1 = elabel2 or elabel1 = allsym or(isArray(elabel2) and	// SuperNotepad	if elabel1	then SetContains(elabel2, elabel1)	else Length(elabel2)=0));DefineGlobalConstant('kObjectConst, func(obj)	// !!!hIsArray(obj) or IsFrame(obj) or(IsBinary(obj) and not (	if kBuild20	then IsString(obj) or IsSymbol(obj)	// !!!j	else isInstance(obj,'string) or isInstance(obj,'symbol))));DefineGlobalConstant('kEmptyGlobal, {	constants: {}, libraries: {}, protos: {},	tools: {}, views: {}, installed: {},});//INSTALL & REMOVE scriptsInstallScript := func(partFrame)begin	local app := partFrame.theForm, root := GetRoot();	local asym := EnsureInternal(kAppSymbol);	local gData, routingFrame, notes, rs;	if kBuild1x and Functions.GetGlobals exists	then begin		gData 		 := GetGlobals().(kAppSymbol);		if not gData		then GetGlobals().(asym) := gData := EnsureInternal(kEmptyGlobal);		routingFrame := GetGlobals().Routing;		routingFrame.(asym) := app.routeScripts; // !!!h. renamed/moved		end	else begin		gData 		 := GetGlobalVar(kAppSymbol);		if not gData		then DefGlobalVar(asym, gData := EnsureInternal(kEmptyGlobal));		routingFrame := GetGlobalVar('Routing);		// for Notes (below)		end;//Print(kTitle);	gData.(kInstalled).(asym)						:= kTitle;	gData.(kConstant).(EnsureInternal(kProtoDict))	:= app.(kProtoDict);	if kBuild20	then gData.(kConstant).(EnsureInternal(kProtoDict2)) := app.(kProtoDict2);	//gData.(kProto).(EnsureInternal(kErrorCodes)) 	:= app.(kErrorCodes);	//gData.(EnsureInternal(kEvalContextSym)) 		:= app.(kEvalContextSym);	if not HasSlot(Functions,'originalPrint)	then Functions.(EnsureInternal('originalPrint)) := Functions.Print;	if not HasSlot(Functions,'originalWrite)	then Functions.(EnsureInternal('originalWrite)) := Functions.Write;	if not HasSlot(root,'originalNotify)	then root.(EnsureInternal('originalNotify)) 	:= root.Notify;	if notes := root.(kNotesSym)	then if kBuild20 or isArray(rs := notes.routeScripts) // 2.x. (ok since rs not used)		then call kAddPatchFunc with (notes, kNotesProtoItem)			/*begin			rf.routeScript := kNotesRouteScript;			if isReadonly(rs) 			then rs := notes.(EnsureInternal('routeScripts)) := Clone(rs);			AddArraySlot(rs, rf);			end*/		else if isFrame(rs := routingFrame.(kNotesSym)) // 1.x		then begin			local rf := EnsureInternal({GetTitle: nil, tag: asym, routeScript: nil});			rf.GetTitle := kNotesGetTitle;			notes.(EnsureInternal(rf.routeScript := kNewtRouteScriptSym)) := kNotesRouteScript;			if isReadonly(rs)			then rs := routingFrame.(kNotesSym) := Clone(rs);			rs.(asym) := rf;			end;	if kBuild21	// eMate only?	then // returns non-NIL if successful		root.(kNewtWorksSym):?RegNewtWorksTool(EnsureInternal(kAppSymbol), kToolFrame);end;RemoveScript := func(partFrame)begin	local gData, routingFrame, notes, root := GetRoot(), rs;	if kBuild1x and Functions.GetGlobals exists	then begin		gData 		 := GetGlobals().(kAppSymbol);		routingFrame := GetGlobals().Routing;		RemoveSlot(routingFrame, kAppSymbol);	// !!!h. moved		end	else begin		gData 		 := GetGlobalVar(kAppSymbol);		routingFrame := GetGlobalVar('Routing);		end;	RemoveSlot(gData.(kConstant), kProtoDict);	RemoveSlot(gData.(kInstalled), kAppSymbol);	if kBuild20	then RemoveSlot(gData.(kConstant), kProtoDict2);	//RemoveSlot(gData.(kProto), kErrorCodes);	//RemoveSlot(gData, kEvalContextSym);	if notes := root.(kNotesSym)	then if kBuild20 or isArray(rs := notes.routeScripts) // 2.x. (ok since rs not used)		then call kRemovePatchFunc with (notes)			/*begin			if i := LSearch(rs, kAppSymbol, 0, '|=|, 'tag)			then ArrayRemoveCount(rs,i,1);			end*/		else if isFrame(rs := routingFrame.(kNotesSym)) // 1.x		then begin			RemoveSlot(rs, kAppSymbol);			RemoveSlot(notes, kNewtRouteScriptSym);			end;	if kBuild21	then root.(kNewtWorksSym):?UnRegNewtWorksTool(kAppSymbol);end;// MetaDot support. these are used in para, evalField, Print:paraDefineGlobalConstant('kMetaDotKeyFrame, { // 2.x	char: 				$.,	modifiers:			if kBuild20 then kCommandModifier+kOptionModifier,	keyMessage:			'_keyMetaDot,		name:				"Meta-.",	category:			"Editing"});DefineGlobalConstant('kMetaDotKeyFunc, func(view)	// 2.x.  _keyMetaDotMetaDot:?popupMeta(view,nil,nil) // it uses GetCaretBox() for charpos/x1/y1);DefineGlobalConstant('kMetaDotSetupFunc, func() // 2.x. for viewSetupFormScriptbegin	:?AddKeyCommand(kMetaDotKeyFrame);	//self.viewFormat := if prefsEntry.noLines then 1 else 12289;	// !!!d noLines??	inherited:?viewSetupFormScript();end);DefineGlobalConstant('kMetaDotQuitFunc, func()		// 2.x. viewQuitScriptbegin	:?ClearKeyCommands();		inherited:?viewQuitScript();end);DefineGlobalConstant('kMetaDotGestureFunc, func(unit,gestureID)	// viewGestureScriptif gestureID = aeTap and prefsCurrent.smartEdit and not GetHiliteOffsets()	// !!!dthen begin	local INT x1 := GetPoint(firstX,unit), y1 := GetPoint(firstY,unit);	if kBuild20 or nos20	then MetaDot:?popupMeta(self, x1, y1)		//AddDelayedSend(MetaDot, 'popupMeta, [self,x1,y1], MetaDot.delay)	else AddDelayedAction(Functions.Perform,		[MetaDot, 'popupMeta, [self,x1,y1]], MetaDot.delay);	NIL;	// allow default (setting caret?)	end);DefineGlobalConstant('kMetaDotPickFunc, func(i)	// pickActionScript. see MetaDot.popupMeta, pickMetaif i := :realPopIndex(i)then begin	self.originalPopList := NIL;	local newText := MetaDot:?pickMeta(self, i);	if newText	then begin		if kBuild20 or nos20		then AddUndoCall(GetGlobalFn('SetValue), [self, 'text, text]);		else AddUndoAction('setText, [text]);	// uses current context?		SetValue(self, 'text, newText);		if (if kBuild20 then IsInteger(charCaret) else isInstance(charCaret,'int))		then SetKeyView(self, charCaret);	// set in pickMeta		end;	end);	DefineGlobalConstant('kMetaDotSetEditFunc, func(newEdit)	// setEdit. 1.xbegin	local oldEdit := edited;	// from parent	edited := newEdit;			// set it (w/o updating)	oldEdit;					// return previous valend);	/*tt := GetRoot().|NewtDevEnv:TKnollSys|; nilss := GetRoot().|Sloup:TKnollSys|; nilbreakonthrows := truestacktrace()exitbreakloop()breakonthrows := nilgetroot().|NewtDevEnv:TKnollSys|.unitsmapgetroot().|NewtDevEnv:TKnollSys|.unitsimportgetpkgrefinfo(getpkgref("MooUser:Newt", GetStores()[1]))getpkgrefinfo(objectpkgref(getpkgrefinfo(getpkgref("MooUnit:Newt", GetStores()[1])).parts[0]._ExportTable[0].objects[1]))getroot().|NewtDevEnv:TKnollSys|.myapp._package._ImportTablegetpkgrefinfo(getpkgref("LS1 Libs 2.1Bc306", GetStores()[1])).partslunit := getpkgrefinfo(objectpkgref(getglobals().|newtdevenv:tknollsys|.constants.lunaobj.protolocation));lunit.parts[1]._exporttable[0].objects*/