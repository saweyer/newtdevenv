// platfunc.txt// constant definitions for PlatFunc.pkg// Copyright 1995-97 S. Weyer. All Rights Reserved Worldwide// 30 Dec 1997// based on MessagePad 1.5, 2.0, 2.1 (Copyright Apple Computer, Inc. 1995)// package size =~??K// 0 Dec 1997: added kSetupOwnerAppFunc// added kGetAllFontsFunc, kGetCommPortInfoFunc, kGetCorrectInfoFunc// 2.1: kGetMaskedPixelFunc, kStringToKeyCodesFunc, kDownUpKeyCodesFunc// PLATFORM FUNCTIONS  (alphabetical)/* in your app you would define as a slot, for example,AddAlarm: kAddAlarmFunc,then later in a method, use... :AddAlarm(<alarm args>);*/constant kNoStr1x := "not defined for 1.x";DefineGlobalConstant('kNo1xFunc0, func()		Print(kNoStr1x));DefineGlobalConstant('kNo1xFunc1, func(a)		Print(kNoStr1x));DefineGlobalConstant('kNo1xFunc2, func(a,b) 	Print(kNoStr1x));DefineGlobalConstant('kNo1xFunc3, func(a,b,c) 	Print(kNoStr1x));DefineGlobalConstant('kNo1xFunc4, func(a,b,c,d) Print(kNoStr1x));constant kNoStr20 := "not defined for 2.0";DefineGlobalConstant('KNo20Func0, func()		Print(kNoStr20));DefineGlobalConstant('KNo20Func1, func(a)		Print(kNoStr20));DefineGlobalConstant('KNo20Func2, func(a,b) 	Print(kNoStr20));DefineGlobalConstant('KNo20Func3, func(a,b,c) 	Print(kNoStr20));DefineGlobalConstant('KNo20Func4, func(a,b,c,d) Print(kNoStr20));// look at kBuild20 flag in Project Data/* platform functions are tagged as: 1.x, 2.0, or BOTHthe function value provides a clue about compatibility"kNo1xFunc" means that there is no equivalent in 1.x."kNo20Func" means that there is no function in 2.0 (no deprecated fn; but usually a built-in fn)."deprecated" means that it will work in 2.0 for now but its use is notrecommended since it will likely disappear in the future (i.e., obsolete).there is usually a built-in function or another way to achieve the samefunctionality.*/PartData := {//AddAlarm:						func(alarmKey,time,notifyArgs,callBackFn,callBackParams)kAddAlarmFunc: 					if kBuild20								then KNo20Func4 //kAddAlarmDeprecatedFunc		// use AddAlarm function								else kAddAlarmFunc,					// 1.x/* see falsalrm.nwt examplesee NTK Docs: AddAlarm*/// -----//AddExtraIcon:					func(extraType, paramFrame, packageName, store)kAddExtraIconFunc:				if kBuild20								then kAddExtraIconFunc				// 2.0								else kno1xFunc4,/* Adds an icon to the Extras Drawer. You can use this function to add anicon that represents several soups created by your application, for example.You can also add an icon that simply executes a function object when tapped.This function does not check if your icon already exists before adding it.You must check to be sure it doesnÕt already exist.extraType 	-- a symbol identifying the type of icon to add. You can	specify 'soupEntry to add a soup icon, or 'scriptEntry to add a script icon.paramFrame	-- a frame containing information to be used in creating the icon. slots:	text: 	(required) string that is the text shown under the icon.	icon: 	(recommended) bitmap frame (of the kind returned by GetPictAsBits)		containing the bitmap for the icon displayed in the Extras Drawer.	app:  	(recommended) symbol used by SetExtrasInfo to find the icon.	labels:	(optional) symbol identifying the Extras Drawer folder in which		to file the icon. Do not specify nil.	ownerApp:(optional) appSymbol of the application that owns the soups. This		slot is used only if the icon is of type 'soupEntry.	soupNames: (optional) array of strings that are the names of soups to be		associated with this icon. This slot is used only if the icon is of type 'soupEntry.	tapAction: (optional) function object that is called if this icon is of type 'scriptEntry	and the user taps it. This function is passed no parameters.	This function is stored in a soup. You should keep it as small as possiblepackageName -- a string naming a package with which this icon should be	associated. If this package is removed from the Newton device, the icon you	added will also be removed. For an icon of type 'soupEntry, you should	specify a package name different from your application. This prevents your	soup icon from being removed if the application is on a card and the card is removed.store		-- a store object on which the part entry should reside.>> returns a frame that is the entry added to the Extras Drawer.*/// -----//AddLocale:					func(newLocalBundle)kAddLocaleFunc: 				kAddLocaleFunc,						// BOTH// see NTK docs:AddLocale// -----//CardFileSafeRemoveLayout:		func(layout) kCardFileSafeRemoveLayoutFunc: 	if kBuild20								then kCardFileSafeRemoveLayoutFunc	// 2.0								else kno1xFunc1,/* Safely removes a cardfile layout from the Names application.(Cardfile layouts appear on the Show menu in the Names application.)You should use this function instead of the cardfile method RemoveLayoutto remove a cardfile layout. Using this function avoids ÒReinsert the cardÓ warnings.layout -- symbol identifying the cardfile layout you want to remove.		(same symbol you passed to the cardfile method AddLayout to add the layout).>> return value of this function is undefined; do not rely on it*/// -----//ClearSelectionHilites:		func(theView)kClearSelectionHilitesFunc:		kClearSelectionHilitesFunc,			// BOTH(?)								// kClearSelectionHilitesDeprecatedFunc ???// -----//CloseRemoteControl:			func(IRconnectionID)kCloseRemoteControlFunc:		if kBuild20								then kCloseRemoteControlDeprecatedFunc 	// use CloseRemoteControl function								else kCloseRemoteControlFunc,			// 1.x/* Call when all remote control operations are completed,to free the memory used for remote control communications.Use IRconnectionID returned by OpenRemoteControl -- this isinvalid after calling CloseRemoteControl.>> always returns nil.*/ // -----//DownUpKeyCodes:				func(keyCodeOrArray)kDownUpKeyCodesFunc: 			if kBuild20								then kDownUpKeyCodesFunc			// 2.1								else kNo1xFunc1,					// 1.x// >> returns keyCodeOrArray// DragAndDropLtd:	"unit,bounds,limitBounds,copy,dragInfo",	// Misc. Toolbox. new platform func?// -----//EnableIRModule:				func(enable)kEnableIRModuleFunc: 			if kBuild20								then kEnableIRModuleDeprecatedFunc	// ???								else kEnableIRModuleFunc,			// 1.x// -----//FindLocale:					func(titleString)kFindLocaleFunc: 				kFindLocaleFunc,					// BOTH// see NTK docs:FindLocale// -----//FlushUserConfig:				func()kFlushUserConfigFunc: 			if kBuild20								then kFlushUserConfigDeprecatedFunc // use FlushUserConfig function								else kFlushUserConfigFunc,			// 1.x//saves user configuration frame// -----//GetAlarm:						func(alarmKey)kGetAlarmFunc: 					if kBuild20								then kNo20Func1 //kGetAlarmDeprecatedFunc		// use GetAlarm function								else kGetAlarmFunc,					// 1.x/* see falsalrm.nwt */// -----//GetAllFonts:					func()kGetAllFontsFunc:				if kBuild20								then kGetAllFontsFunc								else kNo1xFunc0,// >> returns array of font description frames// -----//GetAppAlarmKeys:				func(alarmKeySuffix)kGetAppAlarmKeysFunc: 			if kBuild20								then kNo20Func1 //kGetAppAlarmKeysDeprecatedFunc	// use GetAppAlarmKeys function								else kGetAppAlarmKeysFunc,			// 1.x/* see falsalrm.nwt */// -----//GetCalendarMeetingTypes:		func()kGetCalendarMeetingTypesFunc:	if kBuild20								then kGetCalendarMeetingTypesFunc	// 2.0								else kNo1xFunc0,/*>> returns an array of symbols that identify all of the meeting typesregistered with the Dates application (calendar). The array includes bothbuilt-in meeting types and any new types registered through the use of RegMeetingType*/// -----//GetCalendarMeetingTypeInfo:	func(typeSymbol)kGetCalendarMeetingTypeInfoFunc:if kBuild20								then kGetCalendarMeetingTypeInfoFunc // 2.0								else kNo1xFunc1,/* typeSymbol -- symbol identifying a meeting type registered with the Dates application.Specify one of the symbols returned by GetCalendarMeetingTypes.>> if the specified type is not found, returns NIL>> if particular meeting type found, returns a frame of info:	{label: 	// string that is the text displayed in the New menu for this meeting type.	icon:		// bitmap frame (of the kind returned by GetPictAsBits) containing the bitmap that is displayed in the New menu for this meeting type.	smallIcon:	// bitmap frame containing the bitmap that is displayed in the meeting slip for this meeting type.	shape:		// shape object containing the icon bitmap.	memory:		// symbol under which the most recently used meeting title strings are stored. (These are stored and accessed using the functions AddMemoryItem and GetMemoryItems.)	}*/// -----//GetCommPortInfo:				func()kGetCommPortInfoFunc:			if kBuild20								then kGetCommPortInfoFunc								else kNo1xFunc0,								// >> returns array of comm port description frames// -----//GetCorrectInfo:				func()kGetCorrectInfoFunc:			if kBuild20								then kGetCorrectInfoFunc								else kNo1xFunc0,								// >> returns  correct info frame// -----//GetDefaultStore:				func()kGetDefaultStoreFunc: 			if kBuild20								then kGetDefaultStoreDeprecatedFunc	// use GetDefaultStore function								else kGetDefaultStoreFunc,			// 1.x/*>> returns the current default storeNotes:- Apps shouldn't normally need to use either of these calls if they'reusing union-soups.- Calling SetDefaultStore while the backupslip is visible doesn't forcethe backup-slip to update.- The default store cannot change if the inserted card is locked.SetDefaultStore throws an evt.ex.msg exception in this case.*/// -----//GetLanguageEnvironment:		func()kGetLanguageEnvironmentFunc:	kGetLanguageEnvironmentFunc,		// BOTH/* returns a value indicating the language for which the ROM in the currentNewton device is implemented.	Language	ROM language codes		English		0		French		1		German		2		Japanese	14*/// -----//GetMaskedPixel: 				func(arg1, arg2, arg3)	// ???kGetMaskedPixelFunc:			if kBuild20								then kGetMaskedPixelFunc				// 2.1 only								else kNo1xFunc3,// -----//GetPartCursor: 				func(packageName, store, folderSym)kGetPartCursorFunc:				if kBuild20								then kGetPartCursorFunc				// 2.0								else kNo1xFunc3,/*packageName -- string naming a package (return parts only from that package)			-- nil (return parts from all packages)store		-- a store object (returns parts only from that store)			-- nil (return parts from all stores)folderSym 	-- a symbol identifying a folder (returns parts only filed within that Extras Drawer folder)			-- nil (return parts from the unfiled folder)			-- '_all (return parts from all folders)>> returns a cursor for entries corresponding to parts (icons) displayed inthe Extras Drawer. The structure of the entries returned by the cursor issubject to change. Entries should be accessed only by using the functionsGetPartEntryData, LaunchPartEntry, and SetExtrasInfo. Do not directly changethe entries returned by GetPartCursor*/// -----//GetPartEntryData:				func(entry)kGetPartEntryDataFunc:			if kBuild20								then kGetPartEntryDataFunc			// 2.0								else kNo1xFunc1,/*entry -- obtained from a part cursor (by using GetPartCursor).>> Returns a frame containing information about an Extras Drawer part entry:	{icon:		// bitmap frame (of the kind returned by GetPictAsBits) containing the bitmap for the part icon displayed in the Extras Drawer.	text:		// string that is the text shown under the part icon.	labels:		// symbol identifying the Extras Drawer folder in which the part is filed. If this slot is nil, the part is unfiled.	appSymbol:	// symbol identifying the application, if the part frame has an app slot.	packageName:// string that is the name of the package which contains the part.	}*/// -----//GetPrinterName:				func(printFrame)kGetPrinterNameFunc: 			kGetPrinterNameFunc,				// BOTH/* Retrieves the name of the printer, given a printer frame object.printerFrame -- printer frame object. The only valid method for obtaining aprinter frame object is to retrieve it from the system userConfigurationframe with the GetUserConfig function. Do not try to construct the slots ofthis frame yourself because different types of printer drivers requiredifferent slots.>> returns a string representing the name of the printer associated with printerFrame.Here is an example of some code that retrieves the name of the current printer:printerFrame := :GetUserConfig('currentPrinter);thePrinterName := :GetPrinterName(printerFrame);*/// -----//GetSCCSideB:					func()kGetSCCSideBFunc: 				if kBuild20								then kGetSCCSideBDeprecatedFunc		// ???								else kGetSCCSideBFunc,				// 1.x// -----//GetUserConfig:				func(configSym)kGetUserConfigFunc: 			if kBuild20								then kGetUserConfigDeprecatedFunc	// use GetUserConfig function								else kGetUserConfigFunc,			// 1.x/* configSym -- symbol naming a slot in the userConfiguration frame.>> returns the value of the requested userConfiguration slot.*/// -----//ItemToText:					func(item, target, transportSym, isTextOnly, noDefaultInkConvert)kItemToTextFunc: 				if kBuild20								then kItemToTextFunc			// 2.1 only?								else kNo1xFunc4,				// 1.x/*item: the iobox itemtarget: the target, if available. If the item came from a transport     :itemRequest() call, pass item.body here. used by the format textscripttransportSym: the transport symbol (no transport group symbols)isTextOnly: *THIS MUST BE SET TO TRUE* in this version of the function.               This will change later.noDefaultInkConvert:    if true, does not convert rich strings and instead returns the 'ink   return value so that the transport can present a user interface for   conversion. if nil, converts ink words to some default (currently   "-ink", but that could change) text>>returns: nil, 'ink, 'error, or an error numberif the return value is nil, it completed successfully (or the item wasalready converted) if the return value is 'ink, it completedsuccessfully, but the item.title and/or item.text slots now contain richstrings rather than plain text. It is up to the transport to convert inkappropriately. if exceptions occur during text export, the error will bereturned as a return value or the value 'error if the error number couldnot be determined.*/// -----//LaunchPartEntry:				func(entry)kLaunchPartEntryFunc:			if kBuild20								then kLaunchPartEntryFunc			// 2.0								else kNo1xFunc1,/* Launches the specified part. The operation is the equivalent of the usertapping the part icon in the Extras Drawer.entry -- obtained from a part cursor (by using GetPartCursor).>> returns a non-nil value if the Extras Drawer would have closed itself after the icon was tapped>> returns nil if the Extras Drawer would have stayed open after the icon was tapped.*/// -----//MissingImports:				func(pkgRef)kMissingImportsFunc:			if kBuild20								then kMissingImportsFunc			// 2.0								else kNo1xFunc1,/* pkgRef -- package reference identifying the package for which this functionreturns information. You can obtain a package reference by using thefunctions ObjectPkgRef or GetPkgRef.>> returns nil if no units are missing>> returns an array of frames describing units used by a package that arenot currently available. Each frame has the following slots	{name:	// symbol identifying the unit.	major:	// unit major version number.	minor:	// unit minor version number.	}*/// -----//OpenRemoteControl:			func()kOpenRemoteControlFunc:			if kBuild20								then kOpenRemoteControlDeprecatedFunc	// use OpenRemoteControl function								else kOpenRemoteControlFunc,			// 1.x/* Initialize the remote control functions.>> returns an object, IRconnectionID, that must be passed to subsequent remote control calls>> returns nil if the initialization failed.*/// -----//PtInBitMap:					func(dx,dy,bitMap)kPtInBitMapFunc: 				if kBuild20								then kPtInBitMapDeprecatedFunc		// ???								else kPtInBitMapFunc,				// 1.x/* This function tests if the specified point (distance from the top leftcorner of the bitmap) is "on". If the bitmap has a maskit tests the mask data, otherwise it uses the bitMap.  >>  returns true or nil*/// -----//QuietSendAll:					func(xxx)kQuietSendAllFunc: 				if kBuild20								then kQuietSendAllFunc				// 2.0								else kNo1xFunc1,/* */// -----//RegEmailSystem:				func(x,y,z)kRegEmailSystemFunc: 			if kBuild20								then kRegEmailSystemFunc			// 2.0								else kNo1xFunc3,// -----//RegFindApps:					func(appSymbol)kRegFindAppsFunc: 				if kBuild20								then kRegFindAppsDeprecatedFunc		// use RegFindApps function								else kRegFindAppsFunc,				// 1.x// -----//RegFormulas:					func(appSymbol,formulasTemplate)kRegFormulas:					if kBuild20								then kRegFormulasDeprecatedFunc		// use RegFormulas function								else kRegFormulasFunc,				// 1.x								/*Registers with the system a template used to add a view to the Formulasapplication in the Extras Drawer. The template must be based on theprotoFormulasPanel system prototype.appSymbol -- unique symbol identifying the application adding this item tothe Preferences roll; normally, the value of this parameter is theapplication symbol, which includes your registered signature.formulasTemplate -- view template based on the protoFormulasPanel systemprototype; it describes the view to be added to the Formulas roll.>> returns (unspecified)*/// -----//RegGlobalKeyboard:			func(kbdSymbol, kbdTemplate)kRegGlobalKeyboardFunc:			if kBuild20								then kRegGlobalKeyboardFunc			// 2.0								else kNo1xFunc2,/* Replaces the alphanumeric keyboard in the system with a custom keyboard.Anytime the alphanumeric keyboard would have been opened, the customkeyboard will be opened instead.kbdSymbol 	-- unique symbol identifying the keyboard view. You should		append your developer signature to ensure that this symbol is unique.kbdTemplate	-- view template that is the new keyboard you are registering.		This template must include a slot named preAllocatedContext whose value is		set to the symbol 'alphaKeyboard. This template must also include a slot		named userName whose value is a string naming the keyboard. This is the		keyboard name that the user sees in keyboard pickers.>> returns the keyboard view, if it was successfully instantiated and installed in the system;>> otherwise, it returns nil.The keyboard view will be created as a child of the root view. In yourcustom keyboard, you might want to include a button that opens the PersonalWord List. ThatÕs the userÕs dictionary of personal words. The standardalphanumeric keyboard includes a button that opens the Personal Word List.To do this, include your own button in your keyboard template (don't use thebitmap from the ROM), and if the user taps it, execute code like this:If GetRoot().reviewdict then	begin	GetRoot().reviewdict:Open();	base:Close();	end;*/// -----//RegisterCardSoup:				func(soupName,soupIndexes,appSymbol,appObject)kRegisterCardSoupFunc: 			if kBuild20								then kRegisterCardSoupDeprecatedFunc// use RegisterCardSoup function								else kRegisterCardSoupFunc,			// 1.x/* This function makes sure the specified soup exists on all availablestores, creating soups as necessary. It also adds it to the CardSoupsglobal array so it will exist on stores that are later introduced.soupName 	- string that's the soup's namesoupIndexes - array of index specifications (as per CreateSoup)appSymbol	- your application's appSymbolappObject	-  array of 2 strings, the singular and plural of the				type of data in the soup - e.g. ["wolf","wolves"]>>  returns the union soup for soupNameYou should normally call RegisterCardSoup in your base view'sViewSetupFormScript or ViewSetupDoneScript.*/// -----//RegNamesRouteScript:			func(symbol, routeScriptFrame)kRegNamesRouteScriptFunc:		if kBuild20								then kRegNamesRouteScriptFunc		// 2.0								else kNo1xFunc2,/* Adds an application-defined action to the Action picker in the Names application.symbol -- unique symbol identifying the action you are adding. You should		append your developer signature to ensure that this symbol is unique.routeScriptFrame -- frame describing the routing action.	{title: string,			// string name of picker item	icon: bitmap object,	// icon for picker item	RouteScript: symbol,	// func called if this action chosen	appSymbol: symbol,		// symbol for context of RouteScript	GetTitle: function		// supplied instead of title slot	...						// other slots used by your app	}>> return value of this function is undefined; do not rely on it.HereÕs an example of using the RegNamesRouteScript function::RegNamesRouteScript('|EntryDumper:PIEDTS|,	{GetTitle: func(target)		if GetTargetCursor(target, nil):entry() then		then "Dump entry";		else nil,	// no selections, so don't show in list	icon: nil,	RouteScript: func(target, targetView)		begin			local curs:=GetTargetCursor(target, nil);			local e := curs:Entry();			while e do begin				print(e);				e:=curs:Next();			end;		end,	})*/// -----//RegPagerType:					func(x,y)kRegPagerTypeFunc: 				if kBuild20								then kRegPagerTypeFunc			// 2.0								else kNo1xFunc2,// -----//RegPhoneType:					func(x,y,z)kRegPhoneTypeFunc: 				if kBuild20								then kRegPhoneTypeFunc				// 2.0								else kNo1xFunc3,// -----//RegPrefs:						func(appSymbol,prefsTemplate)kRegPrefsFunc:					if kBuild20								then kRegPrefsDeprecatedFunc		// use RegPrefs function								else kRegPrefsFunc,					// 1.x/*Registers with the system a template used to add an item to the Preferencesroll in the Extras drawer. The template must be based on theprotoPrefsRollItem system prototype. Note that items added to thePreferences roll must specify system-wide preferences rather thanapplication-specific ones.appSymbol -- unique symbol identifying the application adding this item tothe Preferences roll; normally, the value of this parameter is theapplication symbol, which includes your registered signature.prefsTemplate -- view template based on the protoPrefsRollItem systemprototype; it describes the view to be added to the Preferences roll. Itemsin the Preferences roll must be used for settings that are global in nature(like to Control Panels in the Mac OS), not for application-specificsettings.>> returns (unspecified)*/// -----//RemoveAlarm:					func(alarmKey)kRemoveAlarmFunc: 				if kBuild20								then kNo20Func1 //kRemoveAlarmDeprecatedFunc		// use RemoveAlarm function								else kRemoveAlarmFunc,				// 1.x// -----//RemoveAppAlarms:				func(alarmKeySuffix)kRemoveAppAlarmsFunc: 			if kBuild20								then kNo20Func1 //kRemoveAppAlarmsDeprecatedFunc	// use RemoveAppAlarms function								else kRemoveAppAlarmsFunc,			// 1.x// -----//RemoveLocale:					func(arg)kRemoveLocaleFunc: 				kRemoveLocaleFunc,// see NTK docs:RemoveLocale// -----//Send:							func(transportSym, item)kSendFunc: 						if kBuild20								then kSendDeprecatedFunc			// use Send function								else kSendFunc,						// 1.x// -----	//SendRemoteControlCode:		func(IRconnectionID, command, count)kSendRemoteControlCodeFunc:		if kBuild20								then kSendRemoteControlCodeDeprecatedFunc	// use SendRemoteControlCode function								else kSendRemoteControlCodeFunc,			// 1.x/* Sends a remote control command through the infrared module.IRconnectionID --  object returned from OpenRemoteControl.command	-- remote control command (a series of raw bytes in the following C structure).	struct IRCodeWord {		unsigned long name; 	// Identifies the command code. You can set this value to anything you like		unsigned long timeBase;	// The time base in microseconds. This sets the bit time base		unsigned long leadIn;	// Duration in timeBase units of the lead bit cell		unsigned long repeat;	// Duration in timeBase units of the last bit cell for loop commands. This field is used only when the command is sent multiple times		unsigned long leadOut;	// Duration in timeBase units of the last bit cell for non-loop commands		unsigned long count;	// One-based count of transitions following		unsigned long transitions[]; // Array of transition durations in timeBase units. This data is specific to the particular equipment you intend to control. You should contact the equipment manufacturer for this data		}count -- number of times to send command. You must specify at least 1.>> returns nil, after the command has been sent count times.*/// -----//SetDefaultStore:				func(newDefaultStore)kSetDefaultStoreFunc: 			if kBuild20								then kSetDefaultStoreDeprecatedFunc	// use SetDefaultStore function								else kSetDefaultStoreFunc,			// 1.x/*   newDefaultStore 	- the store to become the default>> returns the newDefaultStorenotes: see GetDefaultStore*/// -----//SetEventAlarm:				func(x,y,z)kSetEventAlarmFunc: 			if kBuild20								then kSetEventAlarmFunc				// 2.0								else kNo1xFunc3,/*   */// -----//SetExtrasInfo:				func(appSymbol, newInfo)			// 1.x//SetExtrasInfo:				func(paramFrame, newInfo)			// 2.0kSetExtrasInfoFunc: 			if kBuild20								then kSetExtrasInfoDeprecatedFunc								else kSetExtrasInfoFunc,								/* NOTE: different interpretation of parameters under 1.x and 2.0 */// 2.0/* Changes the extras drawer information for the specified Extras Drawer icon.paramFrame --  frame identifying the icon whose Extras Drawer information you want to change.	{appSymbol: (required) symbol identifying the application that the icon represents.	store: (optional) store object identifying the store on which the icon resides.	packageName: (optional) string naming the package to which the icon belongs.	}Alternately, you can specify just an appSymbol for the paramFrame parameter,or you can specify an entry obtained from a part cursor (by using GetPartCursor).newInfo -- new information frame for the icon represented by paramFrame.If you don't specify a particular slot (or specify nil), the value of thatslot is not changed.	{icon:		// bitmap frame (of the kind returned by GetPictAsBits) containing the bitmap for the part icon displayed in the Extras Drawer.	text:		// string that is the text shown under the part icon.	labels: 	// symbol identifying the Extras Drawer folder in which to file the icon. Do not specify nil.	soupNames:	// array of strings that are the names of soups to be associated with this icon. This slot applies to soup icons only.	ownerApp:	// appSymbol of the application that owns the soups. This slot applies to soup icons only.	}>> returns the information frame that was in effect before this call.>> If the icon isn't found, this function returns nil.// 1.xChanges the specified application's extras drawer info and returns its current state.appSymbol	- appSymbol of the app who's extras drawer info you want to changenewInfo 	- new extras drawer info (frame) to use.			A nil or missing slot means leave that particular attribute unchanged.	{icon: 	//BitMap or PICT that shows in the extras drawer  	text:	//text displayed underneath the icon 	} >> returns the app's current extras drawer info frame,>> or nil if the app isn't found). Useful for restoring state.*/// -----//SetupOwnerApp:				func(arg)kSetupOwnerAppFunc:				if kBuild20								then kSetupOwnerAppFunc								else kNo1xFunc1,// -----//SetUserConfig:				func(configSym, theValue)kSetUserConfigFunc: 			if kBuild20								then kSetUserConfigDeprecatedFunc	// use SetUserConfig function								else kSetUserConfigFunc,			// 1.x// -----//ShowBusyBox:					func(showIt)kShowBusyBoxFunc:				if kBuild20								then kShowBusyBoxFunc				// 2.0								else kNo1xFunc1,/* Shows or hides the system busy icon.showIt -- Boolean that specifies whether to show or hide the system busy icon.	true to show the busy icon until control returns to the system.	nil to hide the busy icon for the rest of the current iteration of the system event loop.>> return value of this function is undefined; do not rely on it*/// -----//SimpleTextHeight:				func(text,width,fontSpec)kSimpleTextHeightFunc:			if kBuild20								then kSimpleTextHeightDeprecatedFunc // use TextBounds?								else kSimpleTextHeightFunc,// -----//StringToKeyCodes:				func(str)kStringToKeyCodesFunc: 			if kBuild20								then kStringToKeyCodesFunc			// 2.1								else kNo1xFunc1,					// 1.x// >> returns keyCodeOrArray// -----//SupplantSoupDef:				func(soup, newDef)kSupplantSoupDefFunc:			if kBuild20								then kSupplantSoupDefFunc			// 2.0								else kNo1xFunc2,/* Creates or replaces the soup definition frame for a soup.soup	-- soup object.newDef	-- new soup definition frame you want to set for the soup.>> return value of this function is undefined; do not rely on it.WARNING:Changing a soup definition frame is not recommended. You should use thisfunction only if you know exactly what you are doing and know that it willnot cause errors or undesirable side effects. Some situations where thisfunction might be useful are adding a soup definition to a 1.x version soup,and renaming a soup.*/// -----//UnionSoupIsNull:				func(unionSoup)kUnionSoupIsNullFunc: 			if kBuild20								then kUnionSoupIsNullDeprecatedFunc	// ???								else kUnionSoupIsNullFunc,			// 1.x/* >> returns true if unionSoup has no constituent soups.This is not a situation that should normally occur. Currently, union-soupsin this state don't work. If you try to make a cursor for them, you get anerror (rather than an empty cursor).Notes on UnionSoupIsNull:Under unusual circumstances you may get a union-soup which doesn'tcontain any soups. Queries on such a union-soup will fail.This situation should not normally arise. Below are some cases whereit might occur and some suggestions on how to deal with it.- Someone removes a card containing the last soup in a union-soup  If you follow DTS guidelines for creating soups, then your soup will always  exist in the internal store. So this situation should not happen unless you  purposely do not to create your soup on the internal store. When a card is  yanked, your app's SoupChanged method is called, so you can use UnionSoupIsNull  to detect the problem.- Someone deletes soup(s) your app is using	Hopefully, any program which deletes soups would at least call	BroadcastSoupChange. Your SoupChanged method should use UnionSoupIsNull	to detect this situation. Normal applications don't go around deleting	soups, so this would be done by some sort of utility program.- The most likely way for an empty union-soup to exist is when you're  debugging your code. e.g. you go around deleting soups to test your  app in the situation when its soups don't initially exist. Once all  the constituent soups of a union-soup are removed, the union-soup  can be garbage collect - provided there are no references to it.    You can force garbage collection using GC(), then, if GetUnionSoup(<soupname>)  doesn't return nil, then you've left some references lying around.  Perhaps there are slots in your base view that need to be nilled out  (you should nil out all refs to soups and cursors in your viewQuitScript)  or maybe there is an Inspector (global) variable lying around with a  reference to your soup.In summary, empty union-soups don't normally occur. If you're running intothem you need to think carefully about your code. Right now, I can't thinkof any reason that normal apps should run into this problem.The function, UnionSoupIsNull is provided so you can detect this situationif you need to. For now, you will have to provide this code yourself, asa method in your base view. In future products, there may be an IsNullmethod defined for union-soups.*/// -----//UnRegEmailSystem:				func(x)kUnRegEmailSystemFunc: 			if kBuild20								then kUnRegEmailSystemFunc			// 2.0								else kNo1xFunc1,// -----//UnRegFindApps:				func(appSymbol),kUnRegFindAppsFunc: 			if kBuild20								then kUnRegFindAppsDeprecatedFunc	// use UnRegFindApps function								else kUnRegFindAppsFunc,			// 1.x// -----//UnRegFormulas:				func(x)kUnRegFormulas:					if kBuild20								then kUnRegFormulasDeprecatedFunc	// use UnRegFormulas function								else kUnRegFormulasFunc,			// 1.x/*Unregisters the specified Formulas application item. appSymbol --  unique symbol identifying the application adding this item tothe Preferences roll; normally, the value of this parameter is theapplication symbol, which includes your registered signature.>> returns (unspecified)*/// -----//UnRegGlobalKeyboard:			func(kbdSymbol)	kUnRegGlobalKeyboardFunc:		if kBuild20								then kUnRegGlobalKeyboardFunc		// 2.0								else kNo1xFunc1,/* Unregisters a custom keyboard that you registered with RegGlobalKeyboard.kbdSymbol -- symbol identifying the keyboard to unregister.This function restores the original keyboard that you replaced in thesystem. It closes the custom keyboard, if it is open when this function iscalled, but this function does not open the original keyboard that wasreplaced.>> returns nil.*/// -----//UnRegisterCardSoup:			func(soupName)kUnregisterCardSoupFunc:		if kBuild20								then kUnRegisterCardSoupDeprecatedFunc  // use UnRegisterCardSoup function								else kUnregisterCardSoupFunc,			// 1.x/*soupName - string that's the soup's nameThis function unregisters soupName with CardSoups global array meaningsoupName soups won't be automatically created on cards when they're inserted.You should normally call UnRegisterCardSoup in your base view's ViewQuitScript.>> returns NIL*/// -----//UnRegNamesRouteScript:		func(symbol)kUnRegNamesRouteScriptFunc:		if kBuild20								then kUnRegNamesRouteScriptFunc		// 2.0								else kNo1xFunc1,/* Removes an application-defined action from the Action picker in the Names application. This function only removes actions added by RegNameRouteScript.symbol -- symbol identifying the action you are removing, e.g.,	:RegNamesRouteScriptFunc('|EntryDumper:PIEDTS|);>> return value of this function is undefined; do not rely on it.*/// -----//UnRegPagerType:				func(x)kUnRegPagerTypeFunc: 			if kBuild20								then kUnRegPagerTypeFunc			// 2.0								else kNo1xFunc1,// -----//UnRegPhoneType:				func(x)kUnRegPhoneTypeFunc: 			if kBuild20								then kUnRegPhoneTypeFunc			// 2.0								else kNo1xFunc1,// -----//UnRegPrefs:					func(x)kUnRegPrefsFunc:				if kBuild20								then kUnRegPrefsDeprecatedFunc		// use UnRegPrefs function								else kUnRegPrefsFunc,				// 1.x/*Unregisters the specified application's Preference roll items. appSymbol -- unique symbol identifying the application adding this item tothe Preferences roll; normally, the value of this parameter is theapplication symbol, which includes your registered signature, or somevariation on it.>> returns (unspecified)*/// -----//ViewIsOpen:					func(view)kViewIsOpenFunc: 				kViewIsOpenFunc,					// BOTH/* This function is a better way to check if a view is open, rather thanchecking if the viewCObject slot is non-nilview -- the view you wish to check.Note that a view can be open but not visible (if it is hidden).>> returns true if the view is open,>> returns nil if it is not.*/};