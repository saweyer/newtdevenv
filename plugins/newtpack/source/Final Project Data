if kBuild20then begin	DeclareGlobalFn('Query,2);	// so we can use same names	//DefineGlobalConstant('kGetUserConfigFunc, kGetUserConfigDeprecatedFunc);	//DefineGlobalConstant('kGetDefaultStoreFunc, kGetDefaultStoreDeprecatedFunc);	endelse begin	DeclareGlobalFn('AddDeferredCall,2);	DeclareGlobalFn('GetGlobalFn, 1);	DeclareGlobalFn('GetGlobalVar,1);	DeclareGlobalFn('DefGlobalVar,2);	DeclareGlobalFn('LFetch,5);	DeclareGlobalFn('GetDefaultStore,0);	DeclareGlobalFn('IsString,1);	DeclareGlobalFn('GetUserConfig,1);	DeclareGlobalFn('DoProgress,3);	DeclareGlobalFn('IsEntryAlias, 1);	DeclareGlobalFn('ResolveEntryAlias, 1);	DeclareGlobalFn('EntryRemoveFromSoupXmit, 2);	DeclareGlobalFn('IsInteger, 1);	DefineGlobalConstant('kTextCompander,	"TLZStoreCompander");	end;DeclareGlobalFn('ClearVBOCache,1);DeclareGlobalFn('GetPkgRef,2);DeclareGlobalFn('BackupPackage,2);// !!!a. defined in reloFix//DefineGlobalConstant('kVBOFlush, 24*1024);	// every 24K or so? ( < 32K?)DefineGlobalConstant('pkgPad, if kBuild20 then 4 else 8);constant cr := "\n";constant kCopyright	:= "©1995-2001,"; // used also for dev copyrightconstant kCopyAuthor:= "S. Weyer                                        ";DefineGlobalConstant('kCopyTool, kVersion && kCopyright && kCopyAuthor);constant kPkgSoupName	:= "TEMPPKG:TKnollSys";constant kSegSize		:= 4096;constant kTooBig		:= "pkgOffset too big";constant kFakeParent	:= '_MyParent_;partData := {}; // set protoPackage, protoProgress in afterScriptconstant kSymbolType := '|?$_Symbol_$?|;constant eArray := '[];DefineGlobalConstant('eFrame, {});DefineGlobalConstant('kSymCompare, func NATIVE (ARRAY a1, ARRAY a2) // [hi,lo,str,sym]  // #5begin	local INT hi := a1[0]-a2[0], lo;	if hi=0	then if (lo := a1[1]-a2[1])=0		then if kBuild20			then StrCompare(a1[2],a2[2])			else call Functions.StrCompare with (a1[2],a2[2])		else lo	else hi;end);DefineGlobalConstant('kFindArray, func NATIVE (ARRAY objs, ARRAY aobj, nocheck) // #6begin	local INT i, j, alen := Length(aobj);	local ARRAY obj1;	local aclass := ClassOf(aobj), found;	for i:=0 to Length(objs)-1	do if nocheck or IsArray(objs[i]) then		begin			obj1 := objs[i];			if alen = Length(obj1) and				(nocheck or (isReadonly(obj1) and aclass = ClassOf(obj1)))			then for j:=0 to (found := alen-1)				do if obj1[j]<>aobj[j] then break found := NIL;			if found then return i;		end;end);DefineGlobalConstant('kStuffNum, func NATIVE (data, INT offset, INT val, INT len, INT shoff)begin	// stuff 1-4 bytes as a (big) number, possibly shifted	local INT i, sh := shoff;	for i := offset+len-1 to offset by -1	do begin		StuffByte(data, i, if sh < 0 then val << -sh else val >> sh);		sh := sh + 8;		end;end);DefineGlobalConstant('kExtractNum, func(data, INT offset, INT len, INT shoff)begin	// extract 1-4 bytes as a number	// for len=4, use ExtractLong for "small" nums	local INT i, val := 0, sh := shoff, byte;	for i := len-1 to 0 by -1	do begin		byte := ExtractByte(data, offset+i);		val := val + (if sh < 0 then byte >> -sh else byte << sh);		sh := sh + 8;		end;	val;end);DefineGlobalConstant('kSaveOffset, func NATIVE (ARRAY objects, offsets, obj, INT offset, INT pos)begin	local INT last := Length(objects)-1, esize := 2;	local stuffFunc :=		if kBuild20 or Functions.IsVBO exists		then begin			esize := 4;			GetGlobalFn('StuffLong);			end		else Functions.StuffWord;	if pos < 0	then if offsets		then begin			if objects[last] // check last element			then objects[last] := objects[pos := objects[last]] // remove from chain			else begin				pos := last;				SetLength(objects, pos+2);				SetLength(offsets, (pos+1)*esize);				end;			objects[pos] := obj;			call stuffFunc with (offsets, pos*esize, offset div pkgPad);			//call kStuffNum with (offsets, pos*esize, offset div pkgPad, esize, 0);			pos; // for later remove			end		else begin // framemap			SetClass(obj, offset);			AddArraySlot(objects,obj);			NIL; //don't remove.   (or last?)			end	else begin // frame map		if pos <= 65535		then begin			objects[pos] := objects[last]; // add previous front			objects[last] := pos; // add to front of chain			end;//Print([offset,obj]);		if kBuild20		then offsets := MakeBinary(esize, '_pkgOffset_)		else begin			SetClass(offsets := Clone(""), '_pkgOffset_);			SetLength(offsets, esize);			end;		call stuffFunc with (offsets, 0, offset div pkgPad);		ReplaceObject(obj, offsets);		end;end);DefineGlobalConstant('kGetOffset, func NATIVE (offsets, INT pos)begin	local INT esize := if kBuild20 or Functions.IsVBO exists then 4 else 2;	pkgPad * call kExtractNum with (offsets, pos*esize, esize, 0);	// pkgPad * (ExtractByte(offsets, (pos*2)) * 256 + ExtractByte(offsets, (pos*2)+1));end);DefineGlobalConstant('orda, Ord($a));DefineGlobalConstant('ordz, Ord($z));DefineGlobalConstant('kSymHash, func NATIVE (data, INT offset, str, sym)begin	local INT i, ch, tot:=0;	local OrdFn := if kBuild1x then Functions.Ord; //GetGlobalFn('Ord) else 	for i:=0 to if kBuild20 then StrLen(str)-1 else call Functions.StrLen with(str)-1	do begin		ch := if kBuild20 then Ord(str[i]) else call OrdFn with(str[i]);		tot := tot + if orda <= ch and ch <= ordz then ch-32 else ch;		end;	local INT lo := 0x79B9 * tot;	local INT hi := (0x9E37 * tot) + (lo >> 16);	if data	then begin		StuffWord(data, offset,   hi);		StuffWord(data, offset+2, lo);		end	else begin // assume array		local ARRAY dd :=			if kBuild20			then Array(if sym then 4 else 2, NIL)			else call Functions.Array with (if sym then 4 else 2, NIL);		dd[offset]   := Band(hi,0xFFFF);		dd[offset+1] := Band(lo,0xFFFF);		if sym		then begin // for sorting			dd[offset+2] := str;			dd[offset+3] := sym;			end;		dd;		end;end);DefineGlobalConstant('kFormInstallScript, func(partFrame) // InstallScript for a normal (part) packagebegin//Print("installing" && partFrame.app);	if Extras exists and isArray(Extras) and		//Functions.ArrayPos exists and		// !!!d		(if kBuild20			then LSearch (Extras, partFrame, 0, '|=|, 'app)			// !!!d			else ArrayPos(Extras, partFrame.app, 0, func(a,e) a=e.app))	then GetRoot():Notify(kNotifyAlert,		EnsureInternal("Extras"),		"Duplicate App" && partFrame.app)	else if HasSlot(partFrame,'devInstallScript)	then begin		partFrame:devInstallScript(partFrame);		partFrame.devInstallScript := NIL;		end;	partFrame.InstallScript := NIL;//Print("end install");end);DefineGlobalConstant('kFormRemoveScript, func(partFrame)	partFrame:?devRemoveScript(partFrame));DefineGlobalConstant('kAutoInstallScript, func(partFrame)begin	local rFrame := EnsureInternal({removeScript: partFrame.devRemoveScript});	partFrame:devInstallScript(partFrame, rFrame);	rFrame;end);DefineGlobalConstant('kDeletionScript, func() nil);DefineGlobalConstant('kExportEntry, func(obj) // !!!a. used by StuffVPUMif kBuild20then begin	local pkgRef := ObjectPkgRef(obj), part, exportTable;	if isPackage(pkgRef) // !!!c	then //LFetch(GetPkgRefInfo(pkgRef).parts,obj,0, '|=|,[pathExpr: '_ExportTable, 0, 'objects])		foreach part in GetPkgRefInfo(pkgRef).parts		do  if isFrame(part) and	// !!!d				isArray(exportTable := part._ExportTable) and				SetContains(exportTable[0].objects, obj)			then return exportTable[0];	// {name:..., objects:} assume only 1 item in array?	NIL;	end);if kDebugOnthen DefineGlobalConstant('kArrayEqual, func (ARRAY a1, ARRAY a2)if Length(a1)=Length(a2)	and Classof(a1)=Classof(a2)then begin	local INT i;	for i := 0 to Length(a1)-1	do if a1[i] <> a2[i] then return NIL;	return TRUE;	end);if kDebugOnthen DefineGlobalConstant('kPrintObj, func(off,obj,len)	begin		Write(off & ": [" & len & "] "); Print(obj);	end);