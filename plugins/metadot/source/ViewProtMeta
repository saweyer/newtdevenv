/*constant kBullet := "\u2022";DefineGlobalConstant('kItemEqual, func(item, entry)StrEqual(item, entry.item));*//*DefineGlobalConstant('kMerge, func(meta)	//single array versionbegin	local INT i;	local ARRAY anArray := Clone(meta);	ArrayRemoveCount(anArray,0,1);		// remove 1st ("proto") element	Sort(anArray, '|str<|, 'item);		// sort at start. keep sorted!	while isArray(meta := meta[0])	do  for i := 1 to Length(meta)-1		do  if kBuild20			then BInsert(anArray, meta[i], '|str<|, 'item, true)			else begin				local INT j, cmp;				local ins := -1, entry := meta[i], str := entry.item;				for j := 0 to Length(anArray)-1				do if (cmp := StrCompare(anArray[j].item, str)) < 0					then ins := j					else break if cmp=0 then ins := nil;				if ins				then ArrayMunger(anArray, ins+1, 0, [entry],0,1);				//if not ArrayPos(anArray, entry.item, 0, kItemEqual)				//then AddArraySlot(anArray, entry);	// sort later				end;	anArray;end);*/constant kAZletters := "ABCDEFGHIJKLMNOPQRSTUVWXYZ";DefineGlobalConstant('kAupper, Ord($A));DefineGlobalConstant('kAlower, Ord($a));constant kLastLetter 	:= 25;DefineGlobalConstant('kAZindex, func(str)	// return 0-25 for any char. 25(z) for non-az/AZbegin	local INT code := Ord(str[0]);	code := if code >= kAlower		then code - kAlower		else if code >= kAupper		then code - kAupper		else kLastLetter;	min(code, kLastLetter);end);// create menu items {item: "A", value: []}, omitting empty entriesDefineGlobalConstant('kAZlist, func(ARRAY names, prefix, suffix)begin	local ARRAY anArray := [];	local INT az;	for az := 0 to kLastLetter	do if Length(names[az]) > 0		then AddArraySlot(anArray,			{item: prefix & kAZletters[az] & suffix, value: names[az]});	anArray;end);DefineGlobalConstant('kMerge, func(meta)	// A:-Z: versionbegin	local entry, str;	local INT i, az;	local ARRAY azSlots := Array(kLastLetter+1, '[protMeta: ]), anArray;	while isArray(meta)	do begin		for i := 1 to Length(meta)-1	// skip 1st(proto) entry		do  begin			entry := meta[i];			az := call kAZindex with (str := entry.item);			anArray := azSlots[az];			if isReadonly(anArray)			then anArray := azSlots[az] := Clone(anArray); // to avoid sharing			if kBuild20			then BInsert(anArray, entry, '|str<|, 'item, true)			else begin				local INT j, cmp;				local ins := -1;				for j := 0 to Length(anArray)-1				do if (cmp := StrCompare(anArray[j].item, str)) < 0					then ins := j					else break if cmp=0 then ins := nil;				if ins				then ArrayMunger(anArray, ins+1, 0, [entry],0,1);				end;			end;		meta := meta[0];		end;	call kAZlist with (azSlots, nil, $:);end);constant kEMeta := '[protMeta: NIL];// common to all viewClass/protosDefineGlobalConstant('kViewMeta, [protMeta:// platformfile.attributeSlotsNIL,											// no further "proto"{item: "hideSound"},		//value: nil},{item: "scrollDownSound"},	//value: kNil},{item: "scrollUpSound"}, 	//value: kNil},{item: "showSound"},		//value: kNil},{item: "viewBounds",		value: kBounds},{item: "viewEffect",		value: 0},{item: "viewFlags",			value: 1},{item: "viewFont",			value: 0},{item: "viewFormat",		value: 0},{item: "viewJustify",		value: 0},{item: "viewOriginX",		value: 0},{item: "viewOriginY",		value: 0},{item: "viewTransferMode", 	value: 0},{item: "_nextKeyView"},		//value: kNil},// platformFile.scriptSlots{item: "pickActionScript",		value: kScriptCmd},	//called if the view has been specified as the notifyView for a DoPopup() call, and an item has been selected{item: "pickCancelledScript",	value: kScript0},	//called if the view has been specified as the notifyView for a DoPopup() call, and the picker is cancelled{item: "viewCaretActivateScript",	value: kScriptArgs, args: "active"},	//handle key view changes,	//called when a view gains or loses key view focus{item: "viewCaretChangedScript",	value: kScriptArgs, args: "view,offset,len"},{item: "viewChangedScript",		value: kScriptArgs, args: "slot,view"},	//called when the value of a slot in the view is changed as the result of SetValue{item: "viewClickScript",		value: kScriptUnit},	//return true if click completely handled,	// if view accepts clicks, this is called when the user taps or writes inside the view{item: "viewDragFeedbackScript",	value: kScriptArgs, args: "dragInfo,curPt,show"},	//return true if this drew      {item: "viewDrawDragBackgroundScript",	value: kScriptArgs, args: "bnds,copy"},	//return true or nil	//draw the image that will appear behind the dragged data{item: "viewDrawDragDataScript",	value: kScriptArgs, args: "bnds"},	//return true or nil	//draw the image that will be dragged{item: "viewDrawScript",		value: kScript0},	//called after the view system does its drawing{item: "viewDropApproveScript",	value: kScriptArgs, args: "destView"},	//return true or nil	//provides a way for the sourceview to disallow dropping onto a particular view {item: "viewDropDoneScript",	value: kScript0},	//"Sent at the very end each drag and drop to let the destination view know that all specified items have been dropped or moved."{item: "viewDropMoveScript",	value: kScriptArgs, args: "dragRef,offset,lastPt,copy"},	//return true if this handled move{item: "viewDropRemoveScript",	value: kScriptArgs, args: "dragRef"},	//return true if this method handled removing item{item: "viewFindTargetScript",	value: kScriptArgs, args: "dragInfo"},	//return view to receive drop messages	//Lets the destination view redirect the drop to a different view{item: "viewGestureScript",		value: kScriptArgs, args: "unit,gestureID"},	//return true if gesture has been completely handled	//called when the user writes a gesture inside the view{item: "viewGetDropDataScript",	value: kScriptArgs, args: "dragType,dragRef"},	//return frame containing actual data to be dropped into destination{item: "viewGetDropTypesScript",value: kScriptArgs, args: "curPt"},	//return array of symbols for data types accepted by the view at curPt{item: "viewHideScript",		value: kScript0},	//called when the view receives a hide command{item: "viewHiliteScript",		value: kScriptArgs, args: "hilite"},	// hilite = true(nil) if view is to be (un)highlighted	// called just before the view system changes the hilite of the view           {item: "viewIdleScript",		value: kScript0},	//return number of millisecs to delay or nil{item: "viewInkWordScript",		value: kScriptStroke},{item: "viewKeyDownScript",		value: kKeyScript},	//Sent by the system when the user presses a keyboard key{item: "viewKeyRepeatScript",	value: kKeyScript},	//Sent repeatedly by the system when the user holds down a keyboard key{item: "viewKeyStringScript",	value: kScriptArgs, args: kArgStr},	//return true if string completely handled	//Sent by the system when keystrokes have been batched{item: "viewKeyUpScript",		value: kKeyScript},	//Sent by the system when the user presses a keyboard key{item: "viewOverviewScript",	value: kScript0},	//called when the view system receives an Overview event{item: "viewQuitScript",		value: kScript0},	//called just before the view (and all of its children) is disposed{item: "viewRawInkScript",		value: kScriptStroke},{item: "viewScrollDownScript",	value: kScript0},	//called when the view system receives a scrollDown event{item: "viewScrollUpScript",	value: kScript0},	//called when the view system receives a scrollDown event{item: "viewSetupChildrenScript",	value: kScript0},	//called after the view is created, but before its children are instantiated{item: "viewSetupDoneScript",	value: kScript0},	//called after all of the child views are instantiated{item: "viewSetupFormScript",	value: kScript0},	//called before any slots in the view template are read{item: "viewShowScript",		value: kScript0},	//called when the view receives a show command{item: "viewStrokeScript",		value: kScriptStroke}, 	//return true if stroke has been completely handled	//called when the user writes inside the view{item: "viewWordScript",		value: kScriptUnit},	//return true if input completely handled	//called when a word is recognized and passed to your view]);//Print("kViewMeta. before:" && Length(kViewMeta));if kBuild1xthen call kRemoveString with (kViewMeta, [	"_nextKeyView",	"viewCaretActivateScript", "viewCaretChangedScript",	"viewDragFeedbackScript", "viewDrawDragBackgroundScript", "viewDrawDragDataScript",	"viewDropApproveScript", "viewDropDoneScript",	"viewDropMoveScript", "viewDropRemoveScript",	"viewFindTargetScript",	"viewGetDropDataScript", "viewGetDropTypesScript", "viewInkWordScript",	"viewKeyDownScript", "viewKeyRepeatScript",	"viewKeyStringScript", "viewKeyUpScript", "viewRawInkScript",	]);//Print("kViewMeta. after:" && Length(kViewMeta));// viewClass/proto-specificDefineGlobalConstant('kProtMeta, {});// ==========// __ntRequired: {viewBounds: "RECT", viewFlags: "NUMB", viewFormat: "NUMB"}}kProtMeta.clView := [protMeta:	kViewMeta,	//{item: "viewFlags",	value: 1}, 	//viewFormat: 0, 	{item: "declareSelf"},	//value: "'base"},	// see protoApp for soupChanged, powerOffScript, doCardRouting, GetTargetInfo];// ==========// __ntRequired: {icon: "PICT", viewBounds: "RECT", viewFlags: "NUMB", viewFormat: "NUMB"}}kProtMeta.clPictureView := [protMeta:	kViewMeta,	//{item: "viewFlags",	value: 1}, 	{item: "icon",		value: kNil},];// ==========// __ntRequired: {viewFlags: "NUMB", viewFormat: "NUMB", viewBounds: "RECT"}, kProtMeta.clEditView := [protMeta:	kViewMeta,	//{item: "viewFlags",		value: 1}, 	{item: "viewFormat",		value: 377}, 	{item: "viewLinePattern"},	//value: kNil}, //custom pattern used to draw lines in the view	{item: "viewLineSpacing",	value: 20}, 	{item: "viewAddChildScript",	value: kScriptArgs, args: "child"},		//return true if this added child		//called when a child view is about to be added to the view	{item: "viewDropChildScript",	value: kScriptArgs, args: "child"},		//return true if this removed child		//called when a child view is about to be removed from the view];// ==========// __ntRequired: {viewBounds: "RECT", viewFlags: "NUMB", viewFont: "EVAL", viewFormat: "NUMB", viewLineSpacing: "NUMB"}, kProtMeta.clParagraphView := [protMeta:	kViewMeta,	//{item: "viewFlags",		value: 1}, 	//{item: "viewJustify",		value: 0}, 	{item: "viewFormat",		value: 12625}, 	{item: "viewLineSpacing",	value: 20}, 	{item: "copyProtection", 	value: 0},	{item: "styles",			value: kEArray}, //array of alternating run lengths and font information, if multiple font styles are used	{item: "tabs",				value: kEArray}, //array of up to 8 tab-stop positions, in pixels	{item: "text",				value: "\"text\""}, //text to display in the view	{item: "textFlags"},		//value: kNil}, 0?	{item: "viewFont",			value: simpleFont18}, ];// ==========// not really documented, but here for sharingkProtMeta.clTextView := kProtMeta.clParagraphView; /*[protMeta:	kViewMeta,];*/// ==========// __ntRequired: {viewBounds: "RECT", viewFormat: "NUMB", viewFlags: "NUMB", points: "EVAL"}, kProtMeta.clPolygonView := [protMeta:	kViewMeta,	//{item: "viewFlags",		value: 1}, 	{item: "viewFormat",		value: 512}, 	{item: "points"},			//value: kNil},//binary data structure containing polygon data	{item: "timeStamp"},		//value: kNil},];// ==========// __ntRequired: {viewBounds: "RECT", viewFlags: "NUMB", viewFormat: "NUMB"}}kProtMeta.clRemoteView := kViewMeta;// ==========// __ntRequired: {datesFont: "EVAL", labelFont: "EVAL", selectedDates: "EVAL", viewBounds: "RECT", viewFlags: "NUMB", viewFormat: "NUMB", viewSetupFormScript: "SCPT"}, kProtMeta.clMonthView := [protMeta:	kViewMeta,	{item: "viewFlags",			value: 513}, 	{item: "datesFont",			value: "@99"},	//ROM_fontSystem9", 	{item: "labelFont",			value: "@100"},	//ROM_fontSystem9Bold", 	{item: "monthChangedScript",value: kScript0}, //Called when the user changes the selection	{item: "selectedDates",		value: kEArray},	//Default dates selected in the view, usually a slot in the parent	{item: "singleDay",			value: kTrue},	//Limits selection to a single day if non-nil];kSlotMeta.datesFont := kSlotMeta.labelFont := kSlotMeta.viewFont;// ==========//__ntRequired: {browsers: "EVAL", outlineClickScript: "SCPT", viewBounds: "RECT", viewFlags: "NUMB", viewFont: "EVAL"}, kProtMeta.clOutline := [protMeta:	kViewMeta,	{item: "viewFlags",		value: 515}, 	{item: "browsers",		value: kEArray},	{item: "clickSound",	value: "@85"},	//ROM_flip",	{item: "outlineClickScript",		value: kScriptArgs, args: "index,dummy"}, //This function must return true	{item: "viewFont",		value: "@87"},	//ROM_fontSystem10"}, ];kSlotMeta.clickSound := kSoundList;// ==========// __ntRequired: {keyArrayIndex: "INTG", keyDefinitions: "EVAL", keyHighlightKeys: "EVAL", keyPressScript: "SCPT", keyReceiverView: "EVAL", keyResultsAreKeycodes: "BOOL", keySound: "EVAL", viewBounds: "RECT", viewFlags: "NUMB"}, kProtMeta.clKeyboardView := [protMeta:	kViewMeta,	{item: "viewFlags",				value: 513}, 	{item: "keyDefinitions",		value: kEArray},	//defs???  array that defines the individual keys	{item: "keyArrayIndex",			value: 0}, 	//Dynamically determine the array element to be used for a key legend or result	{item: "keyHighlightKeys",		value: kEArray},	//Array of keys to be highlighted on the keyboard	{item: "keyResultsAreKeycodes"},//value: kNil},	//If true, interpret integer results as key codes	{item: "keyReceiverView",		value: "'viewFrontKey"}, //View that key presses are sent to if no KeyPressScript is defined	{item: "keySound",				value: if kBuild20 then "@432"}, //ROM_typewriter 1.x?? //sound frame that is played when a key is pressed	{item: "keyPressScript",		value: kScriptArgs, args: "key"}, //Called whenver a key is pressed];kSlotMeta.keySound := kSoundList;// ==========// __ntRequired: {viewBounds: "RECT", viewFlags: "NUMB", viewFormat: "NUMB", viewValue: "NUMB"}, kProtMeta.clGaugeView := [protMeta:	kViewMeta,	//{item: "viewFlags",			value: 513}, // not clickable?	{item: "gaugeDrawLimits",		value: kTrue},	//Controls the display of the gray background	{item: "maxValue",				value: 100}, 	//maximum value to display	{item: "minValue",				value: 0}, 		//minimum value to display	{item: "viewValue",				value: 50}, 	//value to display];// ==========kProtMeta.clPickView := kProtMeta.clView;// ==========//__ntRequired: {title: "EVAL", viewBounds: "RECT", viewFormat: "NUMB"}, kProtMeta.protoApp := [protMeta:	kProtMeta.clView,	//{item: "viewFormat",		value: 83951953}, 	//{item: "viewFlags", 		value: 4},	//{item: "viewJustify", 	value: 16}, 	{item: "appAll", 			value: "\"All Items\""}, //A string that is displayed as the last item in the protoFolderTab popup menu	{item: "appObject", 		value: "[\"item\", \"items\"]"}, //singular and plural forms of the application's data items, used for filing	{item: "appSymbol"}, 		//value: kNilSym}, //symbol identifying the application	{item: "DateFind", 			value: kScriptArgs,	//Find all items from before or after findTime		args: "findTime,filter,results,scope,statusContext"},	{item: "doCardRouting"},	//value: kNil},	{item: "filingChanged", 	value: kScript0},	//User picked a new folder for current item	{item: "filterChanged", 	value: kScript0},	//User picked a new folder to view	{item: "Find", 				value: kScriptArgs, //Find string what and put the result frame in array results		args: "what,results,scope,statusContext"},	{item: "FindSoupExcerpt", 	value: kScriptArgs, //Return a string to represent entry in find overview		args: "entry,resultFrame"},	{item: "folderChanged", 	value: kScriptArgs, //A folder was added, renamed, or deleted		args: "soupName,oldFolder,newFolder"},	{item: "GetTargetInfo",		value: kInheritedArgs, args: "reason"},		//"func(reason)\nbegin\n\t{target: target,\n\ttargetView: base,\n\t};\nend"},		//reason could be 'routing, 'filing, or other symbols		//Returns a target information frame required by system services such as Filing and Routing	{item: "labelsFilter"}, 	//value: kNilSym}, //Currently displayed folder. Maintained by by filing system	{item: "powerOffScript",	value: kScriptArgs, args: "what"},		//called if the view that has this method has been registered as a power off handler	{item: "PutAway", 			value: kScriptArgs, // Put away a newly-received beam		args: "item"},	{item: "ReorientToScreen", value: [		"@588, //ROM_DefRotateFunc",		"func()\nbegin\n\t:SyncView();\n\t:RedoChildren();\nend",		]},	{item: "SetupRoutingSlip", 	value: "func(fields)\nbegin\n\tfields.title := title && DateNTime(Time());\nend"},	{item: "setupTarget", 		value: "func(slip)\nbegin\n\tslip.target := target;\n\tslip.targetView := self;\nend"}, // Set up slip before routing	{item: "soupChanged",			value: kScriptArgs, args: "soupName"},		//called when a different application (or the system) has changed a soup that you own or use	{item: "target"}, 			//value: kNil},	//Current soup entry	{item: "targetView"}, 		//value: kNil},	//For routing and filing	{item: "title", 			value: kEString},	//"\"Application\""},	{item: "titleHeight", 		value: 12},];if kBuild1xthen call kRemoveString with (kProtMeta.protoApp, [	"doCardRouting", "FindSoupExcerpt", "GetTargetInfo", "SetupRoutingSlip",	"setupTarget", "titleHeight"]);// ==========if kBuild20	// __ntRequired: {viewBounds: "RECT", viewFlags: "NUMB"}, then kProtMeta.protoDragger := [protMeta:	kProtMeta.clView,	//{item: "viewFormat", 			value: 83953489}, // 1.x or in protofloater?	//{item: "viewFlags", 			value: 512},	//{item: "declareSelf", 		value: "'base"},	//Identifies the view to be closed when the user taps the close box	iClick,	iSForm,	//DragWindow(arg) kInh??	{item: "noOverview"},	//	value: "\"App does not support Overview\""}, //Message the user gets when they hit the overview button	{item: "noScroll"}, 	//	value: "\"App does not support scrolling\""}, //Message the user gets when they hit the scroll arrows];	// ==========// __ntRequired: {viewBounds: "RECT"}, kProtMeta.protoFloater :=if kBuild20 then kProtMeta.protoDraggerelse [protMeta:		kProtMeta.clView,	//{item: "viewEffect", 	value: 236577}, 	//{item: "viewFlags", 	value: 576},	//{item: "viewJustify", value: 16},	{item: "noOverview"},	{item: "noScroll"},];// ==========kProtMeta.protoFloatNGo := kProtMeta.protoFloater;	// __ntRequired: {viewBounds: "RECT"}, // ==========//__ntRequired: {viewBounds: "RECT", viewFlags: "NUMB"}, if kBuild20 thenkProtMeta.protoDragNGo := kProtMeta.protoDragger; /*[protMeta:	kProtMeta.protoDragger,	//{item: "viewJustify", 	value: 16},];*/// ==========// __ntRequired: {viewBounds: "RECT", viewJustify: "NUMB"}, if kBuild20 thenkProtMeta.protoGeneralPopup := [protMeta:	kProtMeta.protoFloater,	//{item: "viewBounds",		value: kBounds},	//{item: "viewEffect",		value: 393216}, 	//{item: "viewFlags", 		value: 608}, 	//{item: "viewFormat", 		value: 67109456}, 	//{item: "viewJustify",		value: 0}, 	iSDone,	iQuit, 	//{item: "context",			value: kNil}, 	//{item: "cancelled",		value: kTrue}, 	{item: "Affirmative",	//Sent to the protoGeneralPopup when the user accepts the changes		value: "func()\nbegin\n\tif context\n\tthen context:?pickActionScript();\nend;"}, 	{item: "Init",				value: kInherited0},	//used internally to initialize the popup	{item: "New",			//Used internally to setup the popup		value: kInheritedArgs, args: "bbox,callContext"},	{item: "popup",			//Used internally to figure out where to show the popup		value: kInheritedArgs, args: "bbox"},]; // ==========// __ntRequired: {viewBounds: "RECT"}, if kBuild20 thenkProtMeta.protoStatusTemplate := [protMeta:	kProtMeta.protoFloater, 	//{item: "viewBounds", 		value: "ReBounds(0,75,185,75)"}, 	//{item: "viewJustify",		value: 16}, 	//{item: "viewFlags",		value: 576}, 	//iSForm,	// protoDragger	{item: "updateIndicator", 	value: kInheritedArgs, args: "setup"},	{item: "viewSet", 			value: kInheritedArgs, args: "setup"},	{item: "CancelRequest",		value: kScriptArgs, args: "why"},];// ==========// __ntRequired: {afterScript: "EVAL", viewBounds: "RECT"}, kProtMeta.protoKeyboard := [protMeta:	kProtMeta.protoFloater,	iClick,	//{item: "viewFlags",		value: 576},	//{item: "viewJustify",		value: 16},	iSForm,	iQuit,	{item: "saveBounds"},		//value: "RelBounds(0,0,100,100), //set to viewBounds"},	//Size and location where you want the Keyboard view to appear	{item: "freeze"},			//value: kNil}, //if true, prevents the system from moving the keyboard to prevent obscuring];kSlotMeta.saveBounds := kSlotMeta.viewBounds;if kBuild20 // redundant (via protoDragger)then call kRemoveString with (kProtMeta.protoKeyboard, ["viewSetupFormScript", "viewClickScript"]);// ==========// __ntRequired: {viewBounds: "RECT", viewJustify: "NUMB", viewFlags: "NUMB", viewFormat: "NUMB", GetRepeatSpec: "SCPT"}, if kBuild20 thenkProtMeta.protoRepeatView := [protMeta:	kProtMeta.protoFloatNGo,	//{item: "viewBounds",		value:"RelBounds(0,0,218,185)"}, //204,190??	//{item: "viewJustify",		value: 80},	//{item: "viewFlags",		value: 608}, //576?	//{item: "viewFormat",		value: 67109457}, 	iSDone,	//iSForm,	{item: "GetRepeatSpec",	value: kInherited0}, //Takes no arguments and returns a repeatTemplate containing the repeat information or nil//?? NumberOfDays, IsCurrentSettingsSameAsEveryDay, SetupRepeatViews, IsAmbiguousWeek.// UpdateText, HitItem, daysInMonth,];// ==========constant kMyImageScript := "func(^1)\nbegin\n\t// imgView:^0(^1);\nend";// __ntRequired: {viewBounds: "RECT", GetScalingInfo: "SCPT", ScrollTo: "SCPT"}}if kBuild20 thenkProtMeta.protoThumbnailFloater := [protMeta:	kProtMeta.protoFloatNGo,	//{item: "viewBounds",		value: "SetBounds(12,-50,-2,-23)"}, 	//{item: "viewDrawScript", 	value: kScript0}, // draw the image and the greybox	//{item: "viewFormat",		value: 336},	//{item: "viewFlags",		value: 545},	//{item: "viewJustify",		value: 16}, 	//iClick,	//{item: "cAllowZooming",		value: kTrue},		//existence of this slot enables resizing of the greybox	{item: "DoneScrolling", 	value: kScript0}, //Called following any scrolling	{item: "DoneZooming", 		value: kScript0}, //Called following the zoom operation	{item: "GetScalingInfo",	value: kMyImageScript, args: kEString},  //Returns scaling information for the image	{item: "Image",				value: "img"},	{item: "ImageView"},		//value: kNil},	{item: "OpenThumbnail",		value: kInheritedArgs, args: "img"},	{item: "PrepareToScroll", 	value: kScript0}, //Call immediately before any scrolling is performed	{item: "PrepareToZoom", 	value: kScript0}, //Called immediately before any zooming is performed	{item: "ScaleGreybox",		//create an array of styles and shapes which is used as a greybox		value: "func(theScaleInfo)\nbegin\n\t// set up fGreyBox\n\tself:RecomputeGreyboxAttributes();\nend"}, 	{item: "ScrollTo",			value: kMyImageScript, args: "x,y"},	//Called if the user scrolls the image	{item: "Setup", 			value: kInheritedArgs, args: "img"},	{item: "ToggleThumbnail",	value: kInheritedArgs, args: "img"},	{item: "trackWhileScrolling"},	//value: kTrue}, 	{item: "Update",			value: kInherited0},	{item: "ZoomTo", 			value: kMyImageScript, args: "horRatio,vertRatio"}, //Called if the edge of the greybox is zoomed//?? RelocateGreyBox, ];// ==========//__ntRequired: {text: "EVAL", viewBounds: "RECT"}, kProtMeta.protoStaticText := [protMeta:	kProtMeta.clParagraphView,	//{item: "viewFlags",		value: 3}, 	{item: "viewFont",			value: "@100"},	//ROM_fontSystem9Bold"}, 	//{item: "viewFormat",		value: 0}, 	//{item: "viewJustify",		value: 8388608}, 	//{item: "viewTransferMode", value: 1}, 	//{item: "styles"},		//value: kEArray},	//alternating run lengths and font information, if multiple font styles are used	//{item: "tabs"},			//value: "[10, 20, 30, 40]"}, //array of up to 8 tab-stops, in pixels	//{item: "text"},			//value: kEString},	//text to be displayed];// ==========//__ntRequired: {name: "EVAL", viewBounds: "RECT"},  if kBuild20 thenkProtMeta.protoStatusText := [protMeta:	kProtMeta.protoStaticText,	//{item: "viewBounds", value: "RelBounds(42,4,138,25)"},	//{item: "viewJustify",	value: 4}, 	iSForm, 	{item: "name",			value: "'statusText"}, 	//unique name	{item: "path",			value: "func() curData.values.(name)"},	//Returns a string to display// ?? viewUpdateFormScript, GetText, GetJustify];// ==========// __ntRequired: {labelCommands: "EVAL", text: "EVAL", viewBounds: "RECT", alwaysCallPickActionScript: "BOOL"}}kProtMeta.protoLabelPicker := [protMeta:	kProtMeta.protoStaticText,	//{item: "viewFlags",		value: 515}, 	//{item: "viewFormat",		value: 50397184}, 	//{item: "viewJustify",		value: 8388608},  	{item: "viewFont",			value: "@100"},	//ROM_fontSystem9Bold"}, 	iClick,	iSForm,	iHilite,	iPickA,	iPickC,	{item: "alwaysCallPickActionScript"}, //Causes PickActionScript to be called for every key comand when the picker is open	{item: "checkCurrentItem"},	//{item: "height",			value: kNil},	{item: "iconBounds"},	{item: "iconIndent"},	{item: "iconSetup", value: kScript0},	{item: "indent"},	//value: 0},	//distance from the left edge of the text label to the picker	{item: "labelActionScript", //called when an item is chosen from the label popup.  The item index is passed into this method		value: kScriptCmd},	{item: "labelCommands"},	//value: kEArray}, //If this slot is supplied, then the pop-up feature is activated.  Specify an array of strings to use as popup items	{item: "pickerSetup",		value: kScript0}, //Return true if the label popup should happen	{item: "popIt",				value: kInheritedArgs, args: "pos"},	{item: "text",				value: "\"label\""}, 	{item: "textChanged",		value: kScript0},	//Called when the entry text is changed	{item: "textIndent"},	{item: "textSetup",		//Returns default text for the entry area		value: "func()\nif labelCommands\nthen labelCommands[0]\nelse \"\""},	{item: "updateIcon", 		value: kInheritedArgs, args: "icn"},	{item: "updateText",		value: kInheritedArgs, args: "txt"},	{item: "viewCaretActivateScript", value: kInheritedUnit},// ?? PopupHiliteBox];if kBuild1xthen call kRemoveString with (kProtMeta.protoLabelPicker, [	"alwaysCallPickActionScript", "checkCurrentItem", "iconBounds",	"iconIndent", "iconSetup", "textIndent", "updateIcon", "viewCaretActivateScript"])else kSlotMeta.iconBounds := kSlotMeta.viewBounds;// ==========// __ntRequired: {text: "EVAL", viewBounds: "RECT"}, kProtMeta.protoCheckBox := [protMeta:	kProtMeta.clPictureView,	//{item: "viewFlags",		value: 513}, 	{item: "viewFont",			value: "@99"},	//ROM_fontSystem9"}, 	//{item: "viewFormat",		value: 0}, 	//{item: "viewJustify",		value: 4}, 	iSDone,	iClick,	iChange,	{item: "buttonValue"},		//value: 1}, 	//value for viewValue when the checkbox is checked	{item: "declareSelf"},		//value: "'base"}, 	{item: "text"},				//value: "\"a Checkbox\""}, //label for the check box	{item: "toggleCheck",		value: kInherited0},	{item: "UpdateBitmap",		value: kInherited0},	{item: "valueChanged",		value: kScript0},	//called when the state of the checkbox changes	{item: "viewValue"},		//value: NIL}, //current value of the checkbox. Set to nil when unchecked and to the value specified in buttonValue when checked// ?? SetCheck];// ==========// __ntRequired: {indent: "NUMB", text: "EVAL", viewBounds: "RECT", viewSetupFormScript: "SCPT"}, kProtMeta.protoRCheckBox := [protMeta:	kProtMeta.protoCheckBox,	//{item: "viewJustify",	value: 5}, 	iSForm,		//"func()\nbegin\n\tself.indent:=self.indent+StrFontWidth(text,viewFont);\n\tinherited:?^0();\nend"},	{item: "indent",		value: 16}, 	//{item: "text"},			//value: "\"a Right Checkbox\""}, ];// ==========// __ntRequired: {buttonValue: "EVAL", viewBounds: "RECT", text: "EVAL"}, kProtMeta.protoRadioButton := [protMeta:	kProtMeta.protoCheckBox,	//iClick,	{item: "radioClickScript",	value: kInheritedUnit},	//{item: "text"},				//value: "\"a RadioButton\""}, //string that is the radio button text label	//{item: "viewValue",		value: kNil},	//current state of the radio button. Holds the value in buttonValue when selected and nil when unselected	//buttonValue = Used to set the clusterValue of a protoRadioCluster. Each radio button in a cluster should have a unique buttonValue];// ==========// __ntRequired: {viewBounds: "RECT"}, kProtMeta.protoRadioCluster := [protMeta:	kProtMeta.clView,	//{item: "viewFlags",			value: 3}, 	//{item: "viewFormat",			value: 0}, 	iSDone,	{item: "clusterChanged",		value: kScript0}, //called when the value of the cluster changes	{item: "clusterValue"},			//value: 1}, //currently selected radio button buttonValue. The default radio button may be specified by storing its buttonValue here	//{item: "declareSelf"},		//value: 'cluster	{item: "InitClusterValue",		value: kInheritedArgs, args: "bval"},	{item: "SetClusterValue",		value: kInheritedArgs, args: "bval"},//viewSetupFormScript: "This method can be used to calculate and set the default clusterValue at run time// ?? SetCluster, InitCluster, UndoAction]; // ==========// __ntRequired: {viewBounds: "RECT"}, kProtMeta.protoInputLine := [protMeta:	kProtMeta.clParagraphView,	//{item: "viewFlags",			value: 14849}, 	//{item: "viewFormat",			value: 12288}, 	//{item: "viewLineSpacing",		value: 20}, 	//height of the input line in pixels	//{item: "viewJustify",			value: 8388608}, 	{item: "viewLinePattern"},		//value: kNil}, //pattern used to draw the line	{item: "viewFont",				value: if kBuild20 then editFont12 else userFont12}, //??font for the text the user writes in the input field	iSDone,	iSForm,	//{item: "viewTransferMode",	value: 1},	{item: "viewChangedScript",		value: "func(slot,view)\nbegin\n\tif slot='text\n\tthen begin end;\nend"},	//called whenever the value of the input field is changed    //textFlags: 8, 	//{item: "styles"},	//{item: "tabs"},	//{item: "text",				value: "\"text\""},	//default text for the input line];// ==========if kBuild20 thenkProtMeta.protoRichInputLine := [protMeta:	kProtMeta.protoInputLine,	{item: "viewFlags",	value: 14849}, ];// ==========// __ntRequired: {viewBounds: "RECT", alwaysCallPickActionScript: "BOOL"}, kProtMeta.protoLabelInputLine := [protMeta:	kProtMeta.protoInputLine,	//{item: "viewFlags",			value: 513}, 	//{item: "viewFormat",			value: 0}, 	iQuit,	{item: "alwaysCallPickActionScript"}, //Causes PickActionScript to be called for every key comand when the picker is open	{item: "curLabelCommand",		value: 0}, //Index that specifies default label to check in the labelCommands array	{item: "entryFlags"},			//value: 14849}, 	//?? Used to set the type of input the entry line will accept	{item: "indent"},				//value: 0}, //distance from the left edge of the view for the dotted line to begin	{item: "label"},				//value: "\"Label\""}, //label text for the input line	{item: "labelActionScript",		value: kScriptCmd},		//called when an item is chosen from the label popup.  The item index is passed into this method		// return true if selection completely handled, nil otherwise	{item: "labelClick",			value: kScriptUnit}, //called when the user taps in the label		//value: "func(unit)\nbegin\n\t// return true if click has been completely handled, nil otherwise\nend"},	{item: "labelCommands",			value: kEArray},	//If this slot is supplied, then the pop-up feature is activated.  Specify an array of strings to use as popup items	{item: "labelFont",				value: "@100"}, //ROM_fontSystem9Bold, //Font to display the label in	{item: "setLabelCommands",		value: kInheritedArgs, args: "cmds"},	{item: "setLabelText",			value: kInheritedArgs, args: "lbl"},	{item: "textChanged",			value: kScript0},	//called when the input text changes	{item: "textSetup",				value: kScript0}, //called to set the initial value of the entry field		//value: "func()\nbegin\n\ttext; // return value becomes the initial value of the input field\nend"},	{item: "updateText",			value: kInheritedArgs, args: "txt"},// ?? _popKeyScript,];if kBuild1xthen call kRemoveString with (kProtMeta.protoLabelInputLine, ["alwaysCallPickActionScript"]);kSlotMeta.entryFlags := kSlotMeta.viewFlags;// ==========// __ntRequired: {path: "EVAL", viewBounds: "RECT"}}kProtMeta.protoTextExpando := [protMeta:	kProtMeta.protoLabelInputLine,	//{item: "viewFlags",		value: 513}, 	//{item: "viewFormat",		value: 208897}, //196609?	//{item: "viewLineSpacing",	value: 20}, 	//{item: "indent",			value: 0}, //distance from the left edge of the view for the dotted line to begin	{item: "Keyboard",			value: "'alphaKeyboard"}, //symbol naming a keyboard to be used when the edit field is expanded	{item: "labelCommands"},	//value: kNil}, 	{item: "path"},				//value: kNilSym}, //symbol that is a path expression identifying the slot in the target frame from which the initial value for the field is gotten, and in which the final value is to be stored	{item: "setup1",			value: kScriptArgs, args: kArgTarget},		//method should return the text for the field label whenever the collapsed view of this field is displayed.  It is passed the contents of the target slot of the enclosing protoExpandoShell	{item: "setup2",			value: kScriptArgs, args: kArgTarget},		//method should return the text for the field contents whenever the collapsed view of this field is displayed.  It is passed the contents of the target slot of the enclosing protoExpandoShell		//target.(path)	{item: "specialClass"},		//value: kNilSym}, //symbol used to set the subclass of the string stored in the target path	iTChange,	iTSetup,];// ==========// __ntRequired: {viewBounds: "RECT", path: "EVAL"}, kProtMeta.protoDateExpando := [protMeta:	kProtMeta.protoTextExpando,/*	{item: "Date",	//What elements should be included in the date and how it should be formatted		value: "GetDateStringSpec([[kElementYear, kFormatNumeric],						[kElementMonth, kFormatNumeric],						[kElementDay, kFormatNumeric]])"}, ???*/	{item: "Date"},	//{item: "entryFlags"},		//value: 526849},	{item: "Keyboard",			value: "'dateKeyboard"},	//{item: "label",			value: kEString},	//label text for the input line	//{item: "path",			value: kNilSym},	//iTChange,	//iTSetup,];// ==========// __ntRequired: {viewBounds: "RECT", path: "EVAL"}, kProtMeta.protoPhoneExpando := [protMeta:	kProtMeta.protoLabelInputLine,	//{item: "viewFormat",	value: 208897}, //196609?	{item: "labelActionScript",	value: kInheritedArg},	//{item: "entryFlags"},		//value: 264705}, 	{item: "Keyboard",			value: "'phoneKeyboard"}, //A symbol naming a keyboard to be used when the edit field is expanded	{item: "labelCommands",		//choices to appear on the picker		value: "[\"Phone\", \"Home\", \"Work\", \"Fax\", \"Car\", \"Beeper\", \"Mobile\", \"Other\"]"},	{item: "labelSymbols",		//array of symbols that are used to indentify phone numbers stored in the target slot. These should be subclasses of the 'string class		value: "'[phone, homePhone, workPhone, faxPhone, carPhone, beeperPhone, mobilePhone, otherPhone]"},	{item: "path"},				//value: kNil}, //symbol that is a path expression identifying the slot in the target frame from which the initial value for the field is gotten, and in which the final value is to be stored. The specified slot should contain an array of phone number strings	{item: "phoneIndex"},		//value: 0},	//index into the array of phone strings in the slot referenced by target.(path)	{item: "setup1",			value: kScriptArgs, args: kArgTarget},		//method should return the text for the field label whenever the collapsed view of this field is displayed.  It is passed the contents of the target slot of the enclosing protoExpandoShell	{item: "setup2",			// return the text to be displayed for the field value when collapsed		value: "func(target)\nbegin\n\ntarget.(path)[phoneIndex]\nend"}, 	iTChange,	iTSetup,];// ==========if kBuild20 thenkProtMeta.protoRichLabelInputLine := [protMeta:	kProtMeta.protoLabelInputLine,	//entryFlags	//viewQuitScript	iChild,	{item: "GetRichString",	value: kInherited0},	//{item: "label"},		//value: "\"Label\""},  ];// ==========// __ntRequired: {viewBounds: "RECT"}}kProtMeta.protoBorder := [protMeta:	kProtMeta.clView,	//{item: "viewFlags",		value: 1},	//{item: "viewFormat",		value: 5}, ];// ==========// __ntRequired: {title: "EVAL", viewBounds: "RECT"}, kProtMeta.protoDivider := [protMeta:	kProtMeta.clView, 	//{item: "viewBounds",	value: "SetBounds(0,0,0,16)"}, 	//{item: "viewFlags",		value: 3}, 	{item: "viewFont",		value: "@100"},	//ROM_fontSystem9Bold"}, 	//{item: "viewFormat",	value: 0}, 	//{item: "viewJustify",	value: 48}, 	iChild,	{item: "title",			value: kEString}, //string which is the text displayed on the divider bar.. If this is nil then the height is calculated from viewFont	{item: "titleHeight",	value: 12}, ];// ==========// __ntRequired: {viewBounds: "RECT", viewSetupFormScript: "SCPT", viewValue: "NUMB"}, kProtMeta.protoGauge := kProtMeta.clGaugeView; /*[protMeta:	kProtMeta.clGaugeView,	//{item: "viewFlags",		value: 3}, 	//{item: "viewFormat",	value: 0}, 	//{item: "gaugeDrawLimits",	value: kTrue}, //If this field is true, the gray background is displayed. If it is nil, the gray background is not displayed	//{item: "maxValue",		value: 100}, //maximum value to display	//{item: "minValue",		value: 0}, 	//minimum value to display	//{item: "viewValue",		value: 50}, //the value to display	//iSForm,];*/// ==========// __ntRequired: {changedSlider: "SCPT", viewBounds: "RECT", viewSetupFormScript: "SCPT", viewValue: "NUMB"}, kProtMeta.protoSlider := [protMeta:	kProtMeta.protoGauge,	//{item: "viewFlags",		value: 513}, 	//iSForm, 	iChange,	{item: "changedSlider",		value: kScript0},//called after the user changes the slider setting	{item: "trackSlider",		value: kScript0}, //???called repeatedly as the user drags the slider	//{item: "declareSelf",		value: "'baseGauge"},  //?	//{item: "gaugeDrawLimits",	value: kTrue},  	//maxValue: 100,  	//minValue: 0, 	//viewValue: 50, 	{item: "viewFinalChangeScript", value: kInherited0},// ?? _sound];// ==========//__ntRequired: {name: "EVAL", viewBounds: "RECT"}, if kBuild20 thenkProtMeta.protoStatusGauge := [protMeta:	kProtMeta.protoGauge,	//{item: "viewBounds",		value: "RelBounds(0,6,166,14)"},	// 0,2?	//{item: "viewFlags",		value: 3, 	//{item: "viewJustify",		value: 8208}, 	iSForm,	{item: "name"},				//value: "'progress"}, // unique name	{item: "path",				value: "func() curData.values.(name)"}, //Returns either a single value that reflects the value of the gauge or an array [value, min, max]	{item: "viewUpdateFormScript",	value: kInherited0},	//{item: "viewValue",		value: 0}, ?];// ==========// __ntRequired: {viewBounds: "RECT"}}kProtMeta.protoLabeledBatteryGauge := [protMeta:	kProtMeta.clView,	//viewFlags: 3	iChild,	iSDone,	iIdle,		//value: "func()\nbegin\n\tinherited:?^0();\n\t300; // milliseconds to delay or nil to end idling\nend"}, 	iQuit,	{item: "ReadBattery",	value: kInherited0},// ?? viewIdleFrequency, ];// ==========// __ntRequired: {viewBounds: "RECT", buttonClickScript: "SCPT"}, kProtMeta.protoPictureButton := [protMeta:	kProtMeta.clPictureView,	//{item: "viewFlags",		value: 515}, 	//{item: "viewFormat",		value: 67109457}, 	//{item: "viewJustify",		value: 6}, 	iClick,		//value: "func(unit)\nbegin\n/*This method is defined internally - do not override it\nDefine your own buttonClickScript instead*/\nend"},	{item: "buttonClickScript",	value: kScript0},//called when the button is tapped	{item: "buttonPressedScript",	value:  kScript0}, //called repeatedly as long as the button is pressed	//{item: "icon",			value: NIL}, //picture (PICT) for the button];// ==========kProtMeta.protoLargeCloseBox := [protMeta:	kProtMeta.protoPictureButton, 	//{item: "viewBounds",		value: "RelBounds(-18,-18,13,13)"}, 	//{item: "viewFormat",		value: 67109457}, 	//{item: "viewJustify",		value: 166},	iSForm,	iBut,];// ==========kProtMeta.protoCloseBox := kProtMeta.protoLargeCloseBox; /*[protMeta:	kProtMeta.protoLargeCloseBox,	//{item: "viewFormat",	value: 0}, 	//{item: "viewJustify",	value: 160},	//{item: "viewBounds", 	value: "RelBounds(-14,-15,13,13)"},	//iSForm,	//iBut,];*/// ==========//__ntRequired: {name: "EVAL", viewBounds: "RECT"}, if kBuild20 thenkProtMeta.protoStatusCloseBox := [protMeta:	kProtMeta.protoLargeCloseBox,	//viewFlags: 515, 	//iSForm,	iSDone,	{item: "name"},			//value: "'closeBox"}, 	//unique name	{item: "path",			//Returns a ButtonClickScript for the close box. If nil is returned, then no close box is drawn		value: "func() curData.values.(name)"}, 	//iBut,	{item: "viewUpdateFormScript",	value: kInherited0},];// ==========// __ntRequired: {viewFlags: "NUMB"}, kProtMeta.protoInfoButton := [protMeta:	kProtMeta.protoPictureButton,	//viewFlags: 515, 	//{item: "viewJustify",	value: 17414}, 	//{item: "viewBounds",	value: "RelBounds(6,0,13,13)"},	iSForm,	iQuit,	//iClick,	{item: "DoInfoAbout", 	value: kScript0},	//Called if the user selects the About menu item	{item: "DoInfoAux",		//Called if the user selects one of the auxiliary items. The array of auxiliary items and the index of the selected item are passed as parameters		value: kScriptArgs, args: "auxArray,index"},	{item: "DoInfoHelp",	value: kScript0},	//Called if the user selects the Help menu item	{item: "DoInfoPrefs",	value: kScript0},	//Called if the user selects the Prefs menu item	{item: "GenInfoAuxItems",	//Returns an array of items suitable for passing to DoPopup().  These items will appear in the picker below the three standard items		value: "func()\nbegin\n\t[];\nend"},	// return your custom items 	//icon: NIL, 	iPickA,	iPickC,// ?? GenInfoItems, SetCapsLock];// ==========// __ntRequired: {viewBounds: "RECT", viewFlags: "NUMB"}, kProtMeta.protoKeyboardButton := [protMeta:	kProtMeta.protoPictureButton,	//viewFlags: 515,  	//viewJustify: 6,  	//{item: "viewBounds",		value: "RelBounds(5,0,23,13)"},	//iClick,	iBut,	{item: "defaultKeyboard"},	//value: kNilSym},	iPickA,	// icon: NIL, // ?? SetDefaultKeyboard,SetKeyboardList, GetKeyboardList];// ==========if kBuild20 thenkProtMeta.protoSmallKeyboardButton := kProtMeta.protoKeyboardButton; /*[protMeta:	kProtMeta.protoKeyboardButton,	//{item: "viewBounds",	value: "RelBounds(5,0,18,13)"},	//icon: NIL, ];*/// ==========// __ntRequired: {viewBounds: "RECT"}}kProtMeta.protoFilingButton := [protMeta:	kProtMeta.protoPictureButton,	//?icon: {bits: <bits, length 60>, bounds: {#6016F431}},  	//{item: "viewJustify",		value: 2054}, 	//{item: "viewBounds",		value: "RelBounds(-23,2,17,13)"},	//{item: "viewFormat",		value: 67109457}, 	iSForm,	iBut,	{item: "Update",			value: kInherited0},// ?? PickIcon, ];// ==========// __ntRequired: {buttonValue: "EVAL", viewBounds: "RECT", viewDrawScript}, kProtMeta.protoPictRadioButton := [protMeta:	kProtMeta.protoPictureButton,	//iClick,	{item: "buttonValue"},		//value: "1"}, //Used to set the clusterValue of a protoRadioCluster. Each radio button in a cluster should have a unique buttonValue	//declareSelf: base, 	//icon: NIL, 	//{item: "viewDrawScript", 	value: kScript0}, //This method must hilight the radio button in some appropriate fashion		//value: "func()\nbegin\n\t// if viewValue then hilight the radio button else take no action\nend"}, 	{item: "UpdateBitmap",		value: kInherited0},	{item: "viewValue"},		//value: kNil}, //current state of the radio button. Holds the value in buttonValue when selected and nil when unselected];// ==========kProtMeta.protoActionButton := [protMeta:	kProtMeta.protoPictureButton,	//{item: "viewJustify",	value: 38}, 	//{item: "viewBounds",	value: "RelBounds(-42,2,17,13)"},	//iClick,	{item: "alwaysCallPickActionScript"},	//icon: {bits: <bits, length 60>,  bounds: {#60172F39}}, 	iBut,	iPickA,	iPickC,// ?? GetActionTransports, GetActionScripts];if kBuild1xthen call kRemoveString with (kProtMeta.protoActionButton, ["alwaysCallPickActionScript"]);// ==========// __ntRequired: {buttonClickScript: "SCPT", text: "EVAL", viewBounds: "RECT"}, kProtMeta.protoTextButton := [protMeta:	kProtMeta.clTextView,	//{item: "viewFlags",			value: 515}, 	{item: "viewFont",				value: "@100"},	//ROM_fontSystem9Bold"}, 	//{item: "viewFormat",			value: 67109457}, 	//{item: "viewJustify",			value: 8388614}, 	//{item: "viewTransferMode",	value: 1}, 	iClick,	{item: "buttonClickScript",		value: kScript0},	//called when the button is tapped	{item: "buttonPressedScript",	value: kScript0},	//called repeatedly as long as the button is pressed	//{item: "text",				value: "\"Button\""}, //label for the button];// ==========// __ntRequired: {name: "EVAL", viewBounds: "RECT", viewFlags: "NUMB"}, if kBuild20 thenkProtMeta.protoStatusButton := [protMeta:	kProtMeta.protoTextButton,	//{item: "viewBounds",		value: "RelBounds(-59,-18,34,13)"}, // -55?	//{item: "viewJustify",		value: 8388774}, 	//viewFlags: 515, 	iSForm,	iSDone,	iBut, 	{item: "name"},				//value: "'primary"}, 	//unique name	{item: "path",			//a string or a frame with a text slot (the button's text) and a script slot (the button's ButtonClickScript)		value: "func() curData.values.(name)"}, 	{item: "ShiftItem",			value: "func() cancelButton"}, //Returns an item that this view should not obscure	//{item: "text",			value: "\"Stop\""}, 	{item: "viewUpdateFormScript",	value: kInherited0},];// ==========// __ntRequired: {text: "EVAL", popup: "EVAL", viewBounds: "RECT", viewFlags: "NUMB"}, if kBuild20 thenkProtMeta.protoPopupButton := [protMeta:	kProtMeta.protoTextButton, 	//viewFlags: 515, 	//{item: "viewJustify",			value: 8389638},	//iClick,	iSForm,	iDraw, 	{item: "alwaysCallPickActionScript"},	//value: kNil},	//?Causes PickActionScript to be called for every key comand when the menu is open	iBut,	//method can set up the popup list dynamically, before it is displayed		//value: "func()\nbegin\n\tpopup := [\"item1\"];\n\tinherited:?^0();\nend"},	iPickA, 	//Called when the user selects an item from the popup list	iPickC,	//text: ""Popup Button"", 	//Text that shows up in the popup button	{item: "popup",					value: kEArray}, //Array of strings that appear in the popup	//text// ?? PadText, SetText,];// ==========// __ntRequired: {viewBounds: "RECT", viewFlags: "NUMB", popup: "EVAL", text: "EVAL", pickActionScript: "SCPT"}, if kBuild20 thenkProtMeta.protoPopInPlace := kProtMeta.protoPopupButton; /*[protMeta:	kProtMeta.protoPopupButton, 	//viewFlags: 515,  	//{item: "viewJustify",		value: 6}, 	//iSForm,	//{item: "alwaysCallPickActionScript", value: kNil}, //Causes PickActionScript to be called for every key comand when the menu is open	//iBut,	//iPickA, // cancelled???	//{item: "popup",				value: kEArray},	//Array of strings that appear in the popup	//text// ?? SetBounds, ];*/// ==========if kBuild20 thenkProtMeta.protoPersonaPopup := [protMeta:	kProtMeta.protoPopInPlace,	//viewJustify: 4	//viewFormat: 0	//viewSetupFormScript	//viewDrawScript	//pickActionScript	iQuit,	//iBut	{item: "Jamit",			value: kScript0},	{item: "SetupText",		value: kScript0},];// ==========if kBuild20 thenkProtMeta.protoEmporiumPopup := [protMeta:	kProtMeta.protoPopInPlace,	//viewJustify: 4	//viewFormat: 0	//viewSetupFormScript	//viewDrawScript	//pickActionScript	iQuit,	//iBut	{item: "Jamit",			value: kScript0},	{item: "SetupText",		value: kScript0},// ??PickOther];// ==========if kBuild20 thenkProtMeta.protoSenderPopup := [protMeta:	kProtMeta.protoPopInPlace,	//viewJustify: 4	//viewFormat: 0	//viewSetupFormScript	//viewDrawScript	//pickActionScript	iQuit,	iHilite,	//iBut	{item: "Jamit",			value: kScript0},	{item: "SetupText",		value: kScript0},];// ==========kProtMeta.protoRecToggle :=if kBuild20 then [protMeta:	kProtMeta.protoPopupButton,	//{item: "viewBounds",		value: "RelBounds(25,2,18,13)"},	//{item: "viewFlags",		value: 1}, ??	//{item: "viewFormat",		value: 67109457}, ??	//iSForm,	iQuit,	//iBut,	{item: "_recogSettings"},	//Required; holds the current setting of the protoRecToggle view. 		//When your application closes, it can save the value of this slot for use in 		//restoring the state of the protoRecToggle view when the application opens again.		//This slot may appear anywhere in the _parent chain of the view that the 		//recToggle controls.	{item: "defaultItem"},	//Optional; an integer value specifying the element of the _recogPopup array to be used as the recToggle view’s default setting. If this slot is missing or nil, the first element of the _recogPopup array specifies the default setting.	{item: "_recogPopup", 		value: kEArray},	//	Optional; an array of symbols specifying the items to be included in the protoRecToggle picker. If this slot is missing or nil, all items specified in the _recogPopup slot of the recToggle view’s template are included in the picker. The first item in this array is the default setting for the recToggle button. 	//iPickA, //Called when the user selects an item from the popup list	{item: "RecogSettingsChanged",	value: kInheritedArgs, args: "vflags"},// ?? BuildInputMask, InitRecogSettings, SetItem, ClearSettings, RecognizerUsed// GetDefaultSettings, GetDefaults, ParseCommands, CompactSettingsFrame, GetRecognizers// ExpandSettingsFrame, SetupPopup, JamIt, PickItem, itemIndex, ValidItem, GetItem,// GetSettings, GetUserChoices, UpdateTogglers, SetRecognizers]else kProtMeta.clView;	// ???// ==========// __ntRequired: {viewBounds: "RECT", viewFlags: "NUMB", viewJustify: "NUMB"}, if kBuild20 thenkProtMeta.protoOrientation := [protMeta:	kProtMeta.protoPopupButton,	// protoTextButton on 2.0?	//viewFlags: 515, 	//{item: "viewBounds",	value: "RelBounds(7,0,47,13)"},	{item: "viewJustify",	value: 146},  //??	//iBut,	//text// ?? RelRotate, FlipBBar, FlipBBarControls];// ==========// __ntRequired: {title: "EVAL"}, kProtMeta.protoTitle := [protMeta:	kProtMeta.clTextView,	//{item: "viewFlags",		value: 3}, 	{item: "viewFont",			value: "@88"},	//ROM_fontSystem10Bold"}, 	{item: "viewFormat",		value: 50331653}, 	// 1?	{item: "viewJustify",		value: 22}, 		// 21?	{item: "viewTransferMode",	value: 3}, 			// 2?	iSForm,	iDraw,	{item: "title",				value: kEString},	//"\"title\""}, //text for the title	{item: "titleHeight",		value: 12}, 	//Pixel height for the title. If nil, calculated from the font	{item: "titleIcon"},		//value: kNil}, //"Picture to use for the title."}, ];if kBuild1xthen call kRemoveString with (kProtMeta.protoTitle, ["titleIcon"]);// ==========kProtMeta.protoStatusBar := [protMeta:	kProtMeta.clView,	//{item: "viewFlags",		value: 1}, 	//{item: "viewFormat",		value: 0}, 	//{item: "viewJustify",		value: 176}, 	//{item: "viewBounds",		value: "SetBounds(0,-18,0,0)"},	iDraw,];// ==========kProtMeta.protoStatus := kProtMeta.protoStatusBar; /*[protMeta:	kProtMeta.protoStatusBar,	//viewFlags: 1,  	//viewFormat: 0,  	//viewJustify: 176,  	//viewBounds: {left: 0, top: -18, right: 0, bottom: 0}}];*/// ==========// __ntRequired: {icon: "PICT", iconBBox: "RECT", numIndices: "NUMB", indexClickScript: "SCPT", curIndex: "NUMB"}, kProtMeta.protoPictIndexer := [protMeta:	kProtMeta.clPictureView,	//{item: "viewBounds",		value: "SetBounds(0,-16,0,0)"},	//{item: "viewFlags",			value: 513}, 	//{item: "viewFormat",		value: 1}, 	//{item: "viewJustify",		value: 182}, 	iClick,	iDraw,	iSDone,	{item: "Hilite",			value: kInheritedArg},	{item: "Hiliter",			value: kInheritedArg},	{item: "curIndex"},			//value: 0}, //index of the currently selected item	//{item: "icon",			value: kNil}, //Picture to use for the indexer, if it is not 16 pixels high, you must change the viewbounds	{item: "iconBBox",			value: kBounds}, //bounding box of the icon starting from 0,0	{item: "indexClickScript",	value: kScriptCmd}, //When the selection changes this method is passed the index of the chosen item	{item: "numIndices"},		//value: 0}, //number of 'items' in the icon that the user can choose from	{item: "TrackPictHilite",	value: kInheritedArg},	{item: "unHilite",			value: kInherited0},// ?? SetHilite];kSlotMeta.iconBBox := kSlotMeta.viewBounds;// ==========if kBuild20 thenkProtMeta.protoAZTabs := [protMeta:	kProtMeta.protoPictIndexer,	//{item: "viewBounds",		value: "SetBounds(0,0,0,18)"},	//viewJustify: 58	iSForm,	{item: "indexClickScript",	value: kInheritedCmd}, //?	{item: "pickLetterScript",	value: kScriptArgs,	args: "ltr"},	{item: "SetLetter",			value: kScriptArgs,	args: "ltr,reserved"},];// ==========if kBuild20 thenkProtMeta.protoAZVertTabs := kProtMeta.protoAZTabs; /*[protMeta:	kProtMeta.protoAZTabs,	//{item: "viewBounds",		value: "SetBounds(0,0,25,0)"},	//{item: "viewJustify",	value: 196}, ];*/// ==========// __ntRequired: {viewBounds: "RECT"}, kProtMeta.protoDrawer := [protMeta:	kProtMeta.clView,	//{item: "viewFlags",		value: 68}, 	{item: "viewFormat",	value: 592}, 	//848?	//{item: "viewEffect",	value: 133120},	//fxDrawerEffect	iKeyD,	{item: "hideSound",		value: "@76"},	//ROM_drawerclose"}, //sound that plays when the drawer view is closed	{item: "showSound",		value: "@77"},	//ROM_draweropen"}, //sound that plays when the drawer view is opened	//textFlags: 50176, ];if kBuild1xthen call kRemoveString with (kProtMeta.protoDrawer, ["viewKeyDownScript"]);// ==========// __ntRequired: {text: "EVAL", viewBounds: "RECT"}, kProtMeta.protoGlance := [protMeta:	kProtMeta.clTextView,	//{item: "viewEffect",			value: 327680}, 	//{item: "viewFlags",			value: 514}, //516?	{item: "viewFont",				value: "@100"},	//ROM_fontSystem9Bold"}, 	//{item: "viewJustify",			value: 4}, 	//{item: "viewFormat",			value: 66129}, 	iIdle, //milliseconds to delay or nil to end idling		//value: "func()\nbegin\n\tinherited:^0();\n\tviewIdleFrequency;\nend"},//??	iClick,	iSDone,	iKeyD,	{item: "viewIdleFrequency"},	//value: 3000}, //length of time the view should remain open, in milliseconds	//{item: "text",				value: "\"text\""},	//textFlags: 33792];if kBuild1xthen call kRemoveString with (kProtMeta.protoGlance, ["viewKeyDownScript"]);// ==========// __ntRequired: {hours: "NUMB", minutes: "NUMB", timeChanged: "SCPT", viewBounds: "RECT"}, kProtMeta.protoSetClock := [protMeta:	kProtMeta.clPictureView,	//{item: "viewBounds",		value: "RelBounds(0,0,64,64)"},	//{item: "viewFlags",		value: 1537}, 	//{item: "viewFormat",		value: 0}, 	//{item: "viewJustify",		value: 0}, 	iDraw,	iStroke,	{item: "hours"},			//value: kNil}, //current hours setting for the clock	{item: "minutes"},			//value: kNil}, //current minutes setting for the clock	{item: "timeChanged",	//Called when the user draws in the clock. Should dirty the clock		value: "func()\nbegin\n\t:Dirty();\nend"}, //// do this so the old hands are erased	//{item: "diff",			value: kInheritedArgs, args: "a1,a2"},	//{item: "distance",		value: kInheritedArgs, args: "a1,a2"},	//{item: "FastEnoughAtan",	value: kInheritedArgs, args: "a1,a2"},// ?? GetHandShape, DrawHand, DrawHilite];// ==========// __ntRequired: {height: "NUMB", overview: "EVAL", viewBounds: "RECT"}, kProtMeta.protoRollItem := [protMeta:	kProtMeta.clView,	//{item: "viewBounds",	value: "SetBounds(0,0,0,20)"},	//{item: "viewFlags",	value: 1}, 	//{item: "viewJustify",	value: 8240}, 	{item: "viewFormat",	value: 337}, 	{item: "height",		value: 20}, 	{item: "overview",		value: "\"text\""},	{item: "stepChildren",	value: kEArray},];// ==========// __ntRequired: {height: "NUMB", overview: "EVAL", viewBounds: "RECT"}, if kBuild20 thenkProtMeta.protoPrefsRollItem := [protMeta:	kProtMeta.clView,	//viewFlags: 1		vVisible	//viewJustify: 48	vjParentFullH	//viewFormat: 0		vfNone	iSForm,	{item: "height",		value: 20}, 	//height of the panel	{item: "overview",		value: "\"text\""},	//string displayed in the Prefs overview 	{item: "icon"},			//value: kNil}, 	//small icon displayed in the Prefs overview and as the title of the panel when it is picked. You may set this to nil to not use an icon	//textFlags: 50176];// ==========// __ntRequired: {rollItems: "EVAL", title: "EVAL", viewBounds: "RECT"}, kProtMeta.protoRollBrowser := [protMeta:	kProtMeta.protoApp,	//{item: "viewFormat",	value: 328017}, 	//83951953?	//{item: "viewJustify",	value: 16}, 		vjParentCenterH	//declareSelf: "'base", 	{item: "rollItems",		value: kEArray}, //array of items to be displayed, all of type protoRollItem	{item: "rollCollapsed"},//value: kTrue}, //Specifies if roll starts out in overview or not	{item: "rollIndex"},	//value: 0}, //Start displaying rollItems from this index, if the browser is initially expanded	{item: "title",			value: kEString},	//"\"rollBrowser\""}, //title for the rollBrowser based application/*[{_proto: protoRollItem,	height: 50,	overview: "Overview of 1",	viewBounds: {left: 0, top: 0, bottom: 50, right: 0},	viewChildren: [{_proto: protoTextButton,				  viewBounds: {left: 5, top: 5, right: -5, bottom: -5},				  viewJustify: vjParentFullH + vjParentFullV,				  buttonClickScript: func()				  begin				  	PlaySound(ROM_funBeep)				  end,				  text: "Play funBeep"}]},	{_proto: protoRollItem,	height: 50,	overview: "Overview of 2",	viewBounds: {left: 0, top: 0, bottom: 50, right: 0},	viewChildren: [{_proto: protoTextButton,				  viewBounds: {left: 5, top: 5, right: -5, bottom: -5},				  buttonClickScript: func()				  begin				  	PlaySound(ROM_bootSound)				  end,				  viewJustify: vjParentFullH + vjParentFullV,				  text: "Play bootSound"}]}]", */];// ==========// __ntRequired: {items: "EVAL", declareSelf: "EVAL", viewBounds: "RECT"}, kProtMeta.protoRoll := [protMeta:	kProtMeta.clView,	//{item: "viewFlags",			value: 36},	iOver,	iScrollU,	iChild,	iScrollD,	iQuit,	{item: "GetOverview",		value: kInherited0},	{item: "ShowItem",			value: kInherited0},	{item: "allCollapsed"},		//value: kNil}, //Specifies if roll starts out in overview or not	//{item: "declareSelf"},	//value: "'roll"}, //DeclareSelf to 'Roll to receive scrolling and overview messages	{item: "index"},			//value: 0}, //Start showing expanded view from this element of the array of items	{item: "items",				value: kEArray}, //Array of overview items. Elements should be of type protoRollItem// ?? ShowItem,	/*: "[{_proto: protoRollItem,	height: 50,	overview: "Overview of 1",	viewBounds: {left: 0, top: 0, bottom: 50, right: 0},	viewChildren: [{_proto: protoTextButton,				  viewBounds: {left: 5, top: 5, right: -5, bottom: -5},				  viewJustify: vjParentFullH + vjParentFullV,				  buttonClickScript: func()				  begin				  	PlaySound(ROM_funBeep)				  end,				  text: "Play funBeep"}]},	{_proto: protoRollItem,	height: 50,	overview: "Overview of 2",	viewBounds: {left: 0, top: 0, bottom: 50, right: 0},	viewChildren: [{_proto: protoTextButton,				  viewBounds: {left: 5, top: 5, right: -5, bottom: -5},				  buttonClickScript: func()				  begin				  	PlaySound(ROM_bootSound)				  end,				  viewJustify: vjParentFullH + vjParentFullV,				  text: "Play bootSound"}]}]", */];// ==========// __ntRequired: {def: "EVAL", viewSetupFormScript: "SCPT", viewBounds: "RECT"}, kProtMeta.protoTable := [protMeta:	kProtMeta.clView,	//viewFlags: 3	//{item: "viewFormat",		value: 337}, 	{item: "viewSetupFormScript",	//setup the table definition		value: "func()\nbegin\n\tdef := Clone(def);\n\tdef.tabValues := [ ];\n\tdef.tabDown := Length(def.tabValues);\n\tdef.tabWidths := (viewBounds.right-viewBounds.left)-2;\nend"}, 	iScrollD,	iScrollU,	iChild,	{item: "def",				value: "protoTableDef"}, //table definition, based on protoTableDef	{item: "scrollAmount"},		//value: 1}, 	//Number of rows the table scrolls each tap	{item: "selectThisCell",	value: kInheritedArgs, args: kArgView},	{item: "selectedCells",		value: kEArray},	//declareSelf: 'tabbase ??	{item: "updateSelection",	value: kInherited0},// ?? viewScroll2DScript,];// ==========kProtMeta.protoTableDef := [protMeta:	NIL,	{item: "tabAcross"},		//The number of columns in the table. This must be set  to one (1). Multicolumn tables are not supported by protoTable.	{item: "tabDown"},			//The number of rows in the table.	{item: "tabWidths"},		//An integer giving the width of the single table column, in pixels.	{item: "tabHeights"},		//An integer giving the height of a row, in pixels (constant for all rows).	{item: "tabProtos",		value: "protoTableEntry"}, //Each row in the table is child view of the table. This slot holds either a reference to a template used to create the child views, or an array of references to templates. For the slots for the default, see protoTableEntry .	{item: "tabValues"},		//A value used as the value of each child view. Alternately, an array of values mapped to table cells.	{item: "tabValueSlot"},		//A symbol naming the slot in each child view where that child’s view value (specified in tabValues) is stored. (Remember to quote the symbol, as in, 'text.) For example, if the table consists of child views based on the clParagraphView class (the default), you would specify 'text for this slot, since the value of a clParagraphView is stored in its text slot.	{item: "tabUniqueSelection"},	//A Boolean value. Set to non-nil to select only a single cell. Set to nil to select multiple cells.	//{item: "indentX"},		//Reserved for internal use. Do not change.	{item: "TabSetup",		value: kInheritedArgs,	args: "view,col,row"},];// ==========// __ntRequired: {viewBounds: "RECT"}, kProtMeta.protoTableEntry := [protMeta:	kProtMeta.clTextview,	//{item: "viewFlags",		value: 515}, 	//{item: "viewFormat",		value: 0}, 	//{item: "viewJustify",		value: 8388612}, 	//{item: "viewTransferMode",value: 1}, 	iClick,	iHilite,	//{item: "text",			value: "\"text\""}, ];// ==========// __ntRequired: {viewBounds: "RECT", label: "EVAL", Popit: "SCPT", textSetup: "SCPT"}, if kBuild20 thenkProtMeta.protoTextPicker := [protMeta:	kProtMeta.clView,	//{item: "viewBounds",	value: "SetBounds(0,0,0,18)"},	//{item: "viewFlags",	value: 513},	//{item: "viewJustify",	value: 8240},	iChild,	iDraw,	iHilite,	iClick,	iPickA,	// update things so TextSetup script returns correct value and label is correct	iPickC,	{item: "labelFont",		value: "0x00102400"},	//"tsSize(9) + tsBold"},	{item: "entryFont",		value: editFont10},	{item: "indent",		value: 0},	{item: "label"},		//value: "\"Label\""},	{item: "Popit",		// open an appropriate picker using the provided indent		value: kScriptArgs, args: "indent"},	{item: "textSetup",		value: kScript0},// ?? MakePickLine,];// ==========// __ntRequired: {viewBounds: "RECT", label: "EVAL", params: "EVAL"}, if kBuild20 thenkProtMeta.protoMapTextPicker := [protMeta:	kProtMeta.protoTextPicker,	//viewBounds: {left: 0, top: 0, right: 0, bottom: 18}, 	//label: ""Text"", 	{item: "params",	value: "{spots: @295, result: 'name}"}, //ROM_countrySoupName	iPopit,	iTSetup,	//iPickA];// ==========// __ntRequired: {viewBounds: "RECT", label: "EVAL", params: "EVAL"}, if kBuild20 thenkProtMeta.protoCountryTextPicker := kProtMeta.protoMapTextPicker; /*[protMeta:	kProtMeta.protoMapTextPicker,	//viewBounds: {left: 0, top: 0, right: 0, bottom: 18}, 	// label: ""Text"", 	{item: "params",	value: "{spots:  @295, result: 'name}"},	iPopit,	iTSetup,	//iPickA];*/// ==========// __ntRequired: {viewBounds: "RECT", label: "EVAL", params: "EVAL"}, if kBuild20 thenkProtMeta.protoUSstatesTextPicker := [protMeta:	kProtMeta.protoMapTextPicker,	//viewBounds: {left: 0, top: 0, right: 0, bottom: 18}, 	// label: ""Text"", 	{item: "params",	value: "{spots: @452, zoomer: 'northAmerica, result: 'name}"}, //ROM_USStateSoupName	//iPopit,	//iTSetup,	//iPickA];// ==========if kBuild20 thenkProtMeta.protoCitiesTextPicker := [protMeta:	kProtMeta.protoMapTextPicker,	{item: "params",	value: "{spots: @251, result: 'name}"}, //ROM_citySoupName];// ==========// __ntRequired: {viewBounds: "RECT", label: "EVAL", Date: "NUMB"}, if kBuild20 thenkProtMeta.protoDateNTimeTextPicker := [protMeta:	kProtMeta.protoTextPicker,	//viewBounds: {left: 0, top: 0, right: 0, bottom: 18}, 	{item: "Date"},			//value: 0},	{item: "shortFormat"},	//value: "'numericDateStrSpec"},	{item: "longFormat"},	//value: kNil},	{item: "format"},		//value: "'shortTimeStrSpec"},	{item: "increment"},	//value: 15},	iPopit,	iTSetup,	//iPickA];// ==========// __ntRequired: {viewBounds: "RECT", label: "EVAL", startTime: "NUMB", stopTime: "NUMB"}, if kBuild20 thenkProtMeta.protoDateDurationTextPicker := [protMeta:	kProtMeta.protoTextPicker,	//viewBounds: {left: 0, top: 0, right: 0, bottom: 18}, 	//viewFont: 1058816, 	{item: "startTime",			value: 0},	{item: "stopTime",			value: 0},	{item: "shortFormat"},		//value: kNil},	{item: "longFormat"},		//value: "'yearMonthDayStrSpec"},	iPopit,	iTSetup,	{item: "pickActionScript",	value: kInheritedArgs, args: "start,stop"},];// ==========if kBuild20 thenkProtMeta.protoRepeatDateDurationTextPicker := [protMeta:	kProtMeta.protoDateDurationTextPicker,	//viewJustify: 0	iSForm,	//longFormat: NIL	{item: "repeatType"},	// NIL. kDayofWeek, kWeekInMonth (1), kDateInMonth (2), kDateInYear(3), kPeriod(4), kNever(5), kWeekInYear(7).	{item: "mtgInfo"},		//NIL// ?? GetDuration];// ==========// __ntRequired: {viewBounds: "RECT", label: "EVAL", Time: "EVAL"}, if kBuild20 thenkProtMeta.protoTimeTextPicker := [protMeta:	kProtMeta.protoTextPicker,	//viewBounds: {left: 0, top: 0, right: 0, bottom: 18}, 	//{item: "label"},		//value: "\"\uFC01\u Time\""},	{item: "Time"},			//value: kNil},	{item: "format"},		//value: "'shortTimeStrSpec"},	{item: "increment"},	//value: 12},	iPopit,	iTSetup,	//pickActionScript: kInheritedCmd	//newTime arg?];// ==========// __ntRequired: {viewBounds: "RECT", label: "EVAL", startTime: "NUMB", stopTime: "NUMB"}, if kBuild20 thenkProtMeta.protoDurationTextPicker := [protMeta:	kProtMeta.protoTextPicker,	//viewBounds: {left: 0, top: 0, right: 0, bottom: 18}, 	{item: "startTime",			value: 0},	{item: "stopTime",			value: 0},	{item: "format"},			//value: "'shortTimeStrSpec"},	{item: "increment"},		//value: 1},	iPopit,	iTSetup,	{item: "pickActionScript", 	value: kInheritedArgs, args: "start,stop"},];// ==========//__ntRequired: {viewBounds: "RECT", label: "EVAL", Date: "NUMB"}, if kBuild20 thenkProtMeta.protoDateTextPicker := [protMeta:	kProtMeta.protoTextPicker,	//viewBounds: {left: 0, top: 0, right: 0, bottom: 18}, 	{item: "Date"},				//value: 0},	{item: "shortFormat"},		//value: kNil},	{item: "longFormat"},		//value: "'yearMonthDayStrSpec"},	iPopit,	iTSetup,	{item: "pickActionScript",	value: kInheritedArgs, args: "newDate"},];// ==========// __ntRequired: {viewBounds: "RECT", label: "EVAL", longitude: "NUMB", latitude: "NUMB", worldClock: "BOOL"}, if kBuild20 thenkProtMeta.protoLongLatTextPicker := [protMeta:	kProtMeta.protoTextPicker,	//viewBounds: {left: 0, top: 0, right: 0, bottom: 18}, 	//{item: "label"},			//value: "\"\uFC01\uWhere\""},	{item: "longitude"},		//value: 0},	{item: "latitude"},			//value: 0},	{item: "worldClock",		value: true}, //must be true to correctly display the longitude and lattitude	iPopit,	iTSetup,	{item: "pickActionScript",	value: kInheritedArgs, args: "long,lat"},];// ==========// __ntRequired: {viewBounds: "RECT", label: "EVAL", Time: "EVAL"}, if kBuild20 thenkProtMeta.protoTimeDeltaTextPicker := [protMeta:	kProtMeta.protoTextPicker,	//viewBounds: {left: 0, top: 0, right: 0, bottom: 18}, 	//{item: "label"},			//value: "\"\uFC01\uOffset\""},	{item: "Time"},				//value: kNil},	{item: "increment"},		//value: 1},	{item: "minValue"},			//value: 0},	iPopit,	iTSetup,	{item: "pickActionScript",	value: kInheritedArgs, args: "newTime"},];// ==========// __ntRequired: {realText: "EVAL"}, if kBuild20 then	//2.1kProtMeta.protoBlindEntryLine := [protMeta:	kProtMeta.protoLabelInputLine,	//{item: "viewBounds",	value: "SetBounds(0,0,-10,26)"},	//{item: "viewJustify",	value: 8396848}, 	//{item: "viewLineSpacing",	value: 24},	//viewClickScript	//{item: "indent"},			//value: 110},	//{item: "entryFlags"},		//value: 513},	//{item: "realText"},			//value: kEString},//string that the user has typed.  Do not modify this slot directly. Use the UpdateText method	{item: "dummyChar"},		//value: "$•"},	//character to display instead of the real text	iTChange,	//UpdateText];// ==========if kBuild20 thenkProtMeta.protoPrinterChooserButton := [protMeta:	kProtMeta.protoLabelPicker,	//indent: 55	{item: "LabelActionScript",		value: kInheritedCmd},	//pickActionScript	iPSetup,	//text: "Printer"	iTSetup,// ?? nbpString, getPrinterProto, saveNew, ChooserDone, openSerialScript,// openNetworkScript,  networkChooserDone, ];// ==========// __ntRequired: {viewBounds: "RECT", text: "EVAL", selected: "EVAL", single: "BOOL", class: "EVAL", _picker: "EVAL"}, if kBuild20 thenkProtMeta.protoAddressPicker := [protMeta:	kProtMeta.protoLabelPicker,	//{left: 30, top: 55, right: -20, bottom: 71}?	//{item: "viewJustify",value: 48},	//iSForm,	iQuit,	{item: "class",				value: "'|nameRef.email|"},	//Name ref data def class	{item: "OtherText"},		//value: "\"Other Names\""}, //Last item (pops up people picker)	//pickActionScript	{item: "_picker",			value: "protoPeoplePopup"},	//Picker for all addresses	iPSetup,	{item: "selected"},			//value: kNil},	//Name refs to be initially selected	{item: "single"},			//value: kNil},	//Restrict to single address?	//text: "Name"	iTSetup,// ?? EntryLineSetup, PopupSetup, DoOpenPicker, Popit, ToRefEquality// TextFromRef, ];// ==========// __ntRequired: {viewBounds: "RECT", selectedMeeting: "EVAL", originalMtgDate: "EVAL"}, if kBuild20 thenkProtMeta.protoRepeatPicker := [protMeta:	kProtMeta.protoLabelPicker,	//viewFont: 1057792, 	//iSForm,	{item: "labelActionScript",		value: kInheritedCmd},	{item: "originalMtgDate"},		//value: kNil}, //if selectedMeeting is a repeating meeting soup entry, then this slot should contain the date of an instance of that repeating meeting	iPSetup,	{item: "selectedMeeting"},		//value: kNil}, //Contains a meeting frame.  Its mtgStartDate slot (and repeatType, mtgInfo or repeatTemplate slots if present) are used	//text: "Repeat"	iTSetup,];// ==========// __ntRequired: {viewBounds: "RECT", selected: "EVAL"}, if kBuild20 thenkProtMeta.protoListPicker := [protMeta:	kProtMeta.clView,	//{item: "viewJustify",			value: 48},	//{item: "viewBounds",			value: "(SetBounds(2,20,-2,260)"},	//{item: "viewFlags",			value: 517},	//{item: "viewFont",			value: "@88"},	//ROM_fontSystem10bold"},	//viewFont: 1058816	//viewFormat: 33554433	iSDone,	iQuit,	iDraw,	iScrollD,	iScrollU,	iChild,	{item: "cursor"},				//value: kNil},	//?	//declareSelf: pickBase, ?	{item: "defaultJustification",	value: vjParentFullH + vjParentTopV},	{item: "dontPurge"},	{item: "GetSelected",			value: kScript0},	//Returns an array of entries representing items selected in the list	{item: "lineHeight",			value: 10}, //height of each line.  Calculated by default to be the taller of the font and the checkmark characters	{item: "listFormat",			value: vfFrameGray + vfPen(1)}, //Used for the internal list's viewFormat	{item: "pickerDef",				value: ["protoPeopleDataDef", "protoNameRefDataDef"]},	{item: "querySpec"},			//value: kNil},	{item: "readOnly"},				//value: kNil},	{item: "reviewSelections"},		//value: kNil},	{item: "selected",				value: kEArray}, //Array of aliases to soup entries which are to be selected initially	{item: "soupChangeSymbol"},		//value: 'listpicker},	{item: "SoupEnters",			value: kInheritedArgs, args: "soupName,changeData"},	{item: "SoupLeaves",			value: kInheritedArgs, args: "soupName,changeData"},	{item: "soupToQuery"},			//value: kNil},	{item: "suppressAZTabs"},		//value: kNil},	//{item: "suppressBorder"},		//value: kNil},	{item: "suppressCloseBox"},		//value: kNil},	{item: "suppressCounter"},		//value: kNil},	//{item: "suppressFind"},		//value: kNil},	{item: "suppressFolderTabs"},	//value: kNil},	 	{item: "suppressNew"},			//value: kNil},	 	{item: "suppressScrollers"},	//value: kNil},	 	{item: "suppressSelOnlyCheckbox"},	//value: kNil},	 // ?? GetTargetInfo, UpdateCursor, MaskTaps, SetNowShowing, SetupCursor,// IndexStr, SetCursor, ChangePickerDef, SetupPickerDef, FilterChanged, // AddToSelected, RedoCursor, SetupFiltering, AddFake, Refresh, Update// GetCursor, MarkCursorPosition, GetSelected];if kBuild20 thenkSlotMeta.defaultJustification := kSlotMeta.viewJustify;if kBuild20 thenkSlotMeta.listFormat := kSlotMeta.viewFormat;// ==========// __ntRequired: {class: "EVAL", selected: "EVAL", viewBounds: "RECT"}, if kBuild20 thenkProtMeta.protoPeoplePicker := [protMeta:	kProtMeta.protoListPicker,	//{item: "viewBounds",	value: kBounds}, 	//viewFlags: 517, 	//{item: "viewJustify",	value: 240},	{item: "viewFont",		value: simpleFont12},	iSForm,	//selected: kNil, 	//Array of references to selected items	{item: "class",	value: [	//Type of data to display			"'|nameRef.people|", "'|nameRef.phone|",			"'|nameRef.fax|", 	 "'|nameRef.email|"]}, // ?? ChangeDataClass];// ==========// __ntRequired: {viewBounds: "RECT", PickWorld: "SCPT"}, if kBuild20 thenkProtMeta.protoWorldPicker := [protMeta:	kProtMeta.clView,	//{item: "viewFlags",value: 545},	iChild,	iDraw,	iClick,	iPickA,	{item: "autoClose"},		//value: kTrue},	//If true, the view closes when a location is selected	{item: "listLimit"},		//value: 10},	//maximum number of names in the popup list	{item: "PickWorld",			value: kScriptArgs, args: "locInfo"}, //Called when the user chooses a location from the picker];// ==========// __ntRequired: {viewBounds: "RECT", PickWorld: "SCPT"}, if kBuild20 thenkProtMeta.protoCountryPicker := kProtMeta.protoWorldPicker; /*[protMeta:	kProtMeta.protoWorldPicker,	//viewFlags: 545, //	{item: "PickWorld",	value: "func(locInfo)\nbegin\nend"}, //Called when the user chooses a location from the picker]; */ // ==========if kBuild20 thenkProtMeta.protoProvincePicker := kProtMeta.protoWorldPicker; /*[protMeta:	kProtMeta.protoWorldPicker,	//viewFlags: 545, //	{item: "PickWorld",	value: "func(locInfo)\nbegin\nend"}, //Called when the user chooses a location from the picker]; */// ==========if kBuild20 thenkProtMeta.protoStatePicker := kProtMeta.protoWorldPicker; /*[protMeta:	kProtMeta.protoWorldPicker,	//viewFlags: 545, //	{item: "PickWorld",	value: "func(locInfo)\nbegin\nend"}, //Called when the user chooses a location from the picker]; */// ==========// __ntRequired: {viewBounds: "RECT", maxLines: "NUMB", numLines: "NUMB", pieces: "EVAL", hilitedIndex: "EVAL"}, if kBuild20 thenkProtMeta.protoOverview := [protMeta:	kProtMeta.clView,	//{item: "viewFlags",			value: 517},	//{item: "viewFont",			value: "@88"},	//ROM_fontSystem10bold"},	//viewFont: 1058816, 	iDraw,	iScrollU,	iScrollD,	iClick,	{item: "Abstract",		//return shape or shape list representing an item in the overview		value: kInheritedArgs, args: "item,bbox"},	{item: "autoDeselect"},	//{item: "checkBoxHorzOffset"},	//value: 0},	//{item: "checkBoxVertOffset"},	//value: 0},	//3?	{item: "CheckState",		value: kInherited0},	{item: "cursor"},			//value: kNil},	//cursor describing the entries	//{item: "dividerLine",		value: kNil},	//{item: "GetHiliteShape",	value: kInheritedArgs, args: "x,box"},	//{item: "GetIndexEntry",		value: kInheritedCmd},	//{item: "GetTheRightShape",	value: kInheritedArgs, args: "entry,box"},	//{item: "hilitedIndex",		value: kNil},	//{item: "Hiliter",			value: kInheritedArgs, args: "shape,index,state"},	{item: "HitItem",			value: kInheritedArgs, args: "index,x,y"},	{item: "lineHeight"},		//value: 32},	//{item: "maxLines"},			//value: 0},	{item: "nothingCheckable"},	//value: kNil},	//{item: "numLines",			value: 0},	//{item: "pieces",			value: kNil},	{item: "Scroller",			value: kScriptArgs, args: "dir"}, 	{item: "selectIndent"},	{item: "SelectItem",		value: kScriptArgs,	args: "index"},	{item: "SetupAbstracts",	value: kInheritedArg},	{item: "TrackOverview",		value: kInheritedUnit},	//{item: "viewStyle",			value: 0},//?? GetTheRightShape, GetIndexEntry, GetHiliteShape, Hiliter];// ==========// __ntRequired: {viewBounds: "RECT", maxLines: "NUMB", numLines: "NUMB", pieces: "EVAL", hilitedIndex: "EVAL", cursor: "EVAL", selected: "EVAL"}, if kBuild20 thenkProtMeta.protoSoupOverview := [protMeta:	kProtMeta.protoOverview,	iChild,	//Abstract	//cursor: kNil,	//HitItem	//maxLines: 0, 	//numLines: 0, 	//hilitedIndex: kNil, 	{item: "Scroller",			value: kInheritedArgs, args: "dir"}, 	{item: "SelectItem",		value: kInheritedArgs, args: "index"},	//??selected: kNil, 	//Array of aliases to soup entries, one for each item selected//?? isSelected, ForEachSelected];// ==========kProtMeta.protoFolderTab := [protMeta:	kProtMeta.clView,	//{item: "viewBounds",	value: "SetBounds(0,0,0,13)"},	//viewFlags: 1, 	//viewJustify: 48, 	iSForm,	iQuit,	iDraw,	{item: "UpdateFilter",		value: kInheritedArgs, args: "a1,a2"},// ?? RedoText];// ==========if kBuild20 thenkProtMeta.protoNewFolderTab := [protMeta:	kProtMeta.protoFolderTab,	//{item: "viewBounds",	value: "SetBounds(0,0,0,21)"},	//{item: "viewJustify",	value: 48}, 	//iDraw,	//{item: "drawFillPat",	value: 5},	//?? 	{item: "text",			value: "\"title\""},	//??	{item: "titleClickScript",	value: kScript0},];// ==========kProtMeta.protoKeypad := [protMeta:	kProtMeta.clKeyboardView,	//viewFlags: 513, 	//viewFont: 1058816, 	//viewFormat: 1, 	iSForm,	iQuit,	//{item: "keyArrayIndex"},	//: 0, 	//{item: "keyDefinitions",	value: kEArray},	//{item: "keyHighlightKeys"},	//{item: "keyPressScript",	value: kScriptArgs, args: "key?"},	//{item: "keyResultsAreKeycodes"},	//{item: "keyReceiverView"},	//'viewfrontkey, 	//{item: "keySound",	if kBuild20 then value: "@432"},	//ROM_typewriter];// ==========if kBuild20 thenkProtMeta.protoNumericKeyboard := kProtMeta.protoKeypad; /*[protMeta:	kProtMeta.protoKeypad,	//{item: "viewBounds", value: "RelBounds(0,0,105,100)"}, //{left: 0, top: 0, right: 148, bottom: 121}??];*//*	??keyDefinitions: "[[keyVUnit, keyVUnit,				$a,  $a,		keyHUnit + keyVUnit + keyFramed + keyAutoHilite + keyRoundingUnit*3,				$b,  $b,		keyHUnit + keyVUnit + keyFramed + keyAutoHilite + keyRoundingUnit*3], [keyVUnit, keyVUnit,				$c,  $c,		keyHUnit + keyVUnit + keyFramed + keyAutoHilite + keyRoundingUnit*3,				$d,  $d,		keyHUnit + keyVUnit + keyFramed + keyAutoHilite + keyRoundingUnit*3]]",*/// ==========if kBuild20 thenkProtMeta.protoAlphaKeyboard := kProtMeta.protoKeypad; /*[protMeta:	kProtMeta.protoKeypad,	//{item: "viewJustify",	value: 128},	//{item: "viewBounds",	value: "SetBounds(1,-82,226,-1)"}, //{left: 0, top: -112, right: 283, bottom: -1}??];*//*	??keyDefinitions: "[[keyVUnit, keyVUnit,				$a,  $a,		keyHUnit + keyVUnit + keyFramed + keyAutoHilite + keyRoundingUnit*3,				$b,  $b,		keyHUnit + keyVUnit + keyFramed + keyAutoHilite + keyRoundingUnit*3], [keyVUnit, keyVUnit,				$c,  $c,		keyHUnit + keyVUnit + keyFramed + keyAutoHilite + keyRoundingUnit*3,				$d,  $d,		keyHUnit + keyVUnit + keyFramed + keyAutoHilite + keyRoundingUnit*3]]", */// ==========if kBuild20 thenkProtMeta.protoLeftRightScroller := [protMeta:	kProtMeta.clView,	//{item: "viewBounds",	value: "SetBounds(0,-18,33,0)"},	//viewFlags: 3	{item: "viewJustify",	value: 144}, //??	//viewFormat: 1	iSForm,	iGest,	{item: "dataRect",			value: kBounds}, //Extent of data in the view	//declareSelf: 'Scroller, 	{item: "GetArrow",			value: kInheritedArgs, args: "dir"}, //Returns the current arrow direction	{item: "pageThreshold"},	//value: 5}, //number of lines before scrolling a page in acceleration	{item: "scrollAmounts"},	//value: "[1,1,1]"}, //array of three numbers passed to you for scrolling	{item: "scrollRect",		value: kBounds}, //Extent of scrollable area, in lines	{item: "scrollView"},		//value: kNil}, //Messages are sent to this view; the default is the scroller view	{item: "SetArrow",			value: kInheritedArgs, args: "dir,state"}, //Sets the scroll arrow state	{item: "viewRect",			value: kBounds}, //Extent of visible area	{item: "ViewScroll2DScript",	value: kInheritedArgs, args: "dir,extras)"}, //Called when user taps on the scroll arrows	{item: "ViewScrollDoneScript", value: kInherited0}, //Called after scroll is finished	{item: "xPos"},				//value: 0}, //Initial/current horizontal coord in the scrollRect	{item: "yPos"},				//value: 0}, //Initial/current vertical coord in the scrollRect// ?? AdjustArrows,SetupExtras, PlayStopSound, DoScroll];if kBuild20then kSlotMeta.dataRect := kSlotMeta.scrollRect := kSlotMeta.viewRect := kSlotMeta.viewBounds;// ==========if kBuild20 thenkProtMeta.protoUpDownScroller := kProtMeta.protoLeftRightScroller;	//{left: -17, top: 0, right: 0, bottom: 33}	//viewJustify: 96, // ==========if kBuild20 thenkProtMeta.protoHorizontalUpDownScroller := kProtMeta.protoLeftRightScroller;	//{left: 0, top: -18, right: 32, bottom: 0}	//viewJustify: 144, // ==========if kBuild20 thenkProtMeta.protoHorizontal2DScroller := kProtMeta.protoLeftRightScroller;	//{left: 0, top: -17, right: 64, bottom: 0}	//viewJustify: 144, // ==========if kBuild20 thenkProtMeta.protoDatePicker := [protMeta:	kProtMeta.clView,	//{item: "viewBounds",	value: "SetBounds(0,35,120,135)"},	//viewFlags: 1	//viewFormat: NIL	iSDone,	//??	iChild,	{item: "DateChanged",	value: kScriptArgs, args: "newDate"}, //Called when the user picks a new date	//declareSelf: 'pickerBase	//{item: "datesFont",		value: "@90"},	//ROM_fontSystem12"}, //font used for the day numbers	//{item: "labelFont",		value: "@100"},	//ROM_fontSystem9bold"}, //font used to label the days above the dates	{item: "monthChangedScript",	value: kInherited0},	//{item: "popupAnnotate",	value: "'yearTransitions"}, //Symbol indicating when a month in the popup view is accompanied with a year: 'none, 'years, or 'yearTransitions	//{item: "popupAnnotationPosition",	value: "'suffix"}, //Symbol indicating on which side the year annotations are placed: 'prefix or 'suffix	//{item: "popupType",		value: "'rolling"}, //Symbol indicating whether the year popup exists or whether it begins in January or not: 'none, 'fixed, 'rolling	{item: "selectedDates",		value: kEArray},	//??array of selected dates, with each date in minutes since midnight January 1, 1904	{item: "SetTitle",		value: kInherited0},	//{item: "titleFont",		value: "@90"},	//ROM_fontSystem12"}, //font used for the month/year label// ?? Refresh, JamIt];// ==========// __ntRequired: {viewBounds: "RECT", viewJustify: "NUMB"}}if kBuild20 thenkProtMeta.protoNewSetClock := [protMeta:	kProtMeta.clView,	//{item: "viewBounds",		value: "RelBounds(30,30,116,116)"},	//{item: "viewFlags",		value: 513},	{item: "viewJustify",		value: 0},	iSForm,	iDraw,	iClick,	iSDone,	//??	iChild,//??	{item: "annotations"},		//value: "[\"12\", \"3\", \"6\", \"9\"]"}, //Array of 4 strings displayed on the clock face	//{item: "clockFont",		value: "@90"},	//ROM_fontSystem12"}, //font in which to draw the annotations	//{item: "cuckooSound",		value: kNil}, //sound played when the user changes the hour by moving the minute hand	{item: "exactHour"},		//value: kNil},	//{item: "minutes",			value: 30}, //currently set minutes on the clock	{item: "suppressAnnotations"},	//value: kTrue},	// this slot's existence suppresses annotations.", 	{item: "Refresh",			value: kScript0},	//{item: "tickTock",		value: kNil},	//{item: "tickSound",		value: kNil}, // sound played on pen-down when setting the time	{item: "Time",				value: "0"},	// set this to the initial time 	{item: "TimeChanged",		value: kScript0},//??Called when the time changes or the user sets a new time	//{item: "tockSound",		value: kNil}, //sound played on pen-up when setting the time// ?? DrawHand, diff, FastEnoughAtan, distance];// ==========// __ntRequired: {New: "SCPT", pickActionScript: "SCPT", pickCancelledScript: "SCPT"}, if kBuild20 thenkProtMeta.protoDatePopup := [protMeta:	kProtMeta.protoGeneralPopup,	//{item: "viewBounds",	value: "RelBounds(0,0,135,156)"},	//{item: "viewFlags",		value: 608}, 	//{item: "viewJustify",	value: 0}, 	{item: "New",	value: kInheritedArgs, args: "date1,bbox,cbContext"}, //creates the popup	{item: "pickActionScript",	value: kInheritedArgs, args: "selectedDate"}, //called when the user taps the close box	iPickC, //called if the popup is cancelled by a tap outside of the popup// ?? Affirmative];// ==========if kBuild20 thenkProtMeta.protoMultiDatePopup := kProtMeta.protoDatePopup; /*[protMeta:	kProtMeta.protoDatePopup,];*/// ==========if kBuild20 thenkProtMeta.protoTimeDeltaPopup := [protMeta:	kProtMeta.protoGeneralPopup,	{item: "New",				value: kInheritedArgs, args: "delta,params,bbox,cbContext"}, //creates the popup	{item: "pickActionScript",	value: kInheritedArgs, args: "delta"}, //called when the user taps the close box// ?? Affirmative];// ==========if kBuild20 thenkProtMeta.protoTimeIntervalPopup := [protMeta:	kProtMeta.protoGeneralPopup,	//iSForm,	iDraw,	//iClick,	{item: "New",					value: kInheritedArgs, args: "times,inc,bbox,cbContext"}, //creates the popup	{item: "pickActionScript",		value: kInheritedArgs, args: "startTime,stopTime"}, //called when the user taps the close box	//iPickC, //called if the popup is cancelled by a tap outside of the popup// ?? Affirmative, TimeChanged, GetDuration];// ==========if kBuild20 thenkProtMeta.protoDateNTimePopup := [protMeta:	kProtMeta.protoGeneralPopup,	//iSForm,	{item: "New",					value: kInheritedArgs, args: "dateNTime,inc,bbox,cbContext"}, //creates the popup	{item: "NewTime",				value: kInheritedArgs, args: "dateNTime"},	{item: "pickActionScript",		value: kInheritedArgs, args: "dateNTime"}, //called when the user taps the close box	//iPickC, //called if the popup is cancelled by a tap outside of the popup// ?? Affirmative, DateChanged, TimeChanged];// ==========if kBuild20 thenkProtMeta.protoTimePopup := [protMeta:	kProtMeta.protoGeneralPopup,	{item: "New",					value: kInheritedArgs, args: "time,inc,bbox,cbContext"}, //creates the popup	{item: "NewTime",				value: kInheritedArgs, args: "time"},	{item: "pickActionScript",		value: kInheritedArgs, args: "time"}, //called when the user taps the close box	//iPickC, //called if the popup is cancelled by a tap outside of the popup// ?? Affirmative, TimeChanged];// ==========if kBuild20 thenkProtMeta.protoAnalogTimePopup := kProtMeta.protoTimePopup;// ==========if kBuild20 thenkProtMeta.protoDateIntervalPopup := [protMeta:	kProtMeta.protoGeneralPopup,	//iSDone,	iDraw,	//iSForm,	//iClick,	{item: "New",					value: kInheritedArgs, args: "dates,bbox,cbContext"}, //creates the popup	{item: "NewTime",				value: kInheritedArgs, args: "startDate,stopOrMax"},	{item: "pickActionScript",		value: kInheritedArgs, args: "startDate,stopOrMax"}, //called when the user taps the close box	//iPickC, //called if the popup is cancelled by a tap outside of the popup// ?? Affirmative, IntervalChanged, GetDuration];// ==========if kBuild20 thenkProtMeta.protoYearPopup := [protMeta:	kProtMeta.protoGeneralPopup,	//viewJustify: 0,	{item: "DoneYear",				value: kInheritedArgs, args: "year"},	{item: "New",					value: kInheritedArgs, args: "year,bbox,cbContext"}, //creates the popup	{item: "NewTime",				value: kInheritedArgs, args: "year"},	//iPickC, //called if the popup is cancelled by a tap outside of the popup// ?? ClickDone, Affirmative];// ==========if kBuild20 thenkProtMeta.protoPeoplePopup := [protMeta:	kProtMeta.protoFloatNGo,	//viewJustify: 144	//viewFlags: 68	//viewFormat: 33554433	//viewEffect: 133120	LFetch(kProtMeta.protoPeoplePicker,"class",1,'|str=|,'item),	{item: "context"},		// NIL	{item: "options"},		//value: kNil},	{item: "selected"},		// NIL// ?? Init,New];// ==========if kBuild20 thenkProtMeta.protoLocationPopup := [protMeta:	kProtMeta.protoGeneralPopup,	//viewFormat: 1	{item: "New",	value: kInheritedArgs, args: "loc?,bbox,cbContext"}, //creates the popup// ?? Affirmative];// ==========// __ntRequired: {appSymbol: "EVAL", title: "EVAL"}, if kBuild20 thenkProtMeta.protoTransportPrefs := [protMeta:	kProtMeta.protoFloater,	//{item: "viewBounds", value: "SetBounds(0,0,200,100)"},	// 215,170?	//{item: "viewJustify",	value: 80},	{item: "appSymbol",		value: "'aSymbol"},	{item: "inboxPrefs",	value: kNil},	{item: "infoPrefs",		value: kNil},	{item: "outboxPrefs",	value: kNil},	{item: "sendPrefs",		value: kNil},	{item: "silentPrefs",	value: kNil},	{item: "title",			value: kEString},	//"\"title\""},// ?? ClosePrefs];// ==========if kBuild20 thenkProtMeta.protoCharEdit := [protMeta:	kProtMeta.clView,	//viewFlags: 7681	//viewJustify: 0	//{item: "viewLineSpacing",	value: 30}, //distance from the top of the viewBounds to the dotted line that you write on	iSDone,	iGest,	iDraw,	iStroke,	iChange,	iSForm,	iClick,	{item: "viewWordScript",	value: kInheritedUnit},	{item: "cellGap"},			//value: 6},	//amount of blank space between cells, in pixels	{item: "cellHeight"},		//value: 50},	//total height of each cell in pixels	{item: "cellWidth"},		//value: 24},	//width of each cell in pixels, including cellGap	//dispIndent?	//dispLeft?	{item: "frameCells"},		//value: kNil}, //Controls whether cells have a dotted frame. The frame is absent if the slot is nil	{item: "left"},				//value: 0},	//left of the view, if viewBounds is not specified	{item: "maxChars"},			//value: 8},	//number of cells to be displayed in the field. Required if top and left are specified instead of viewBounds	iPickA,	iPickC,	//recConfig ??	{_proto: {@444}, letterSpaceCursiveOption: NIL, rcSingleLetters: 1, inputmask: 16777216, dictionaries: 40, inhibitSymbolsDictionary: 1}	{item: "template"},			//value: kNil},	//Controls the interpretation of input in the edit cells	{item: "text",				value: kEString}, //initial and current value of the text displayed, unless the template slot is provided	{item: "top"},				//value: 0},	//top of the view, if viewBounds is not specified	{item: "wordLeft"},			//value: 1	{item: "wordRight"},		//value: nil// ?? GetFilter,UseTextAndTemplate, HandleTap, GetAlternates, TrimLeft, Scroll// RestoreUndoState, CellLocked, HandleScrub, SortMatches, CharPos, // UseNewTemplate, UseNewWord, InvalDrawCache, AddEndCaps, AddUpperCase// BubbleUp, GetWordForDisplay, FindCell, DisplayExternal, DeleteText,// ReplaceChar, PickBestChar, PadRight, FixedWord, MakeWordArray, // SetNewTemplate, SetNewWord, SaveUndoState, DeleteSpace, InsertSpace, FixedWordLength];// ==========kProtMeta.protoPicker := [protMeta:	kProtMeta.clPickView,	//viewFlags: 578	//viewFormat: 67109457	//textFlags: 1024	//viewJustify: 6	//viewOriginY: 0	//viewEffect: 393216	{item: "viewFont",				value: "@88"},	//ROM_fontSystem10Bold	iSDone,	iKeyD,	{item: "bounds",				value: kBounds},	{item: "callbackContext"},		//value: kNil},	//pickActionScript	{item: "pickAutoClose"},		//TRUE	{item: "pickBottomMargin"},		//2	//pickCancelledScript	{item: "pickItems",				value: kEArray},	{item: "pickItemsMarkable"},	// NIL	{item: "pickTextItemHeight"},	//13	{item: "pickLeftMargin"},		//4	{item: "pickMarkWidth"},		//10	{item: "pickRightMargin"},		// 5	{item: "pickTopMargin"},		// 2// ?? Scroll, GetItemMark, SetScrollers, GetScrollerValues, SetItemMark];kSlotMeta.bounds := kSlotMeta.viewBounds;if kBuild1x thencall kRemoveString with (kProtMeta.protoPicker, ["viewKeyDownScript"]);// ==========// required: type,title,symbol,dataTypesif kBuild20 thenkProtMeta.protoRoutingFormat := [protMeta:	NIL,	{item: "auxForm"},		//value: kNil},	{item: "dataTypes"},	//value: "'[frame,text]"}	{item: "MakeBodyAlias",	value: kScriptArgs, args: "targetInfo"},	{item: "ResolveBody",	value: kScriptArgs, args: kArgItem},	{item: "SetupItem",		value: kScriptArgs, args: "item,targetInfo"},	{item: "showMessage"},	//TRUE, 	{item: "sizeLimit"},	// NIL, 	{item: "storeAlias"},	// NIL, 	{item: "storeCursors"},	// TRUE, 	{item: "symbol"},		// protoRoutingFormat,	{item: "TargetSize",	value: kScriptArgs, args: "targetInfo"},	{item: "TextScript",	value: kScriptArgs, args: "item,reserved"},	{item: "title"},		// "Default", 	{item: "type"},			// printFormat, 	{item: "version"},		// 0, // ?? ProcessAlias, FindCursorFormat, ResolveItem, ParseCursor, SetupSlip];// ==========kProtMeta.protoPrintFormat :=if kBuild20 then [protMeta:	kProtMeta.protoRoutingFormat,	// also clView?	{item: "viewFlags"},	// 3	{item: "viewBounds",	value: kBounds},	{item: "viewFont"},		//12289	{item: "viewJustify"},	//240	iSForm,	iChild,	{item: "CountPages",		value: kScriptArgs, args: "item,target"},	{item: "FormatInitScript",	value: kScriptArgs, args: "item,reserved"},	//MakeBodyAlias	{item: "margins",		value: kBounds},	{item: "orientation"},	//portrait,	{item: "printNextPageScript",	value: kScript0},		//called when routing data so that your application can prepare the next page of info	//ResolveBody	//SetupItem	{item: "usesCursors"},	// NIL, // GetCursorFormat, SetMarginBounds, LastChanceToSetup, NextItem]else [protMeta:	NIL,	//??	{item: "viewFlags"},	// 3	{item: "viewBounds",	value: kBounds},	{item: "viewFont"},		//12289	{item: "viewJustify"},	//240	iSForm,	iChild,	{item: "printNextPageScript",	value: kScript0},];if kBuild20 thenkSlotMeta.margins := kSlotMeta.viewBounds;// ==========if kBuild20 thenkProtMeta.protoFrameFormat := kProtMeta.protoRoutingFormat;// ==========// required: viewSetupFormScript?kProtMeta.protoTextList := [protMeta:	kProtMeta.clView,	//viewFormat: 337	//viewFlags: 545,	{item: "viewFont",		value: "@87"}, 	//viewOriginY: 0 	iChild, 	iScrollD, 	iScrollU, 	iClick,	iBut,	//declareSelf: TextBase	{item: "DoScrollScript",	value: kInheritedArgs,	args: "offset"},	{item: "isShapeList"},		// NIL	//lineHeight	{item: "listItems",			value: kEArray},	//numItems	{item: "ScrollAmounts"},	// NIL	{item: "selectedItems",		value: kEArray},	{item: "selection"},		// 0,	{item: "useMultipleSelections"},	// NIL	{item: "useScrollers"},		// NIL	{item: "viewLines"},		// 0// ?? setViewHeight, SetupList, ShowScrollers, HiliteLine, GetViewWidth// GetTotalLines, InvertLine, GetViewHeight, GetVisibleLines, SetChild,// drawHilite, GetLineHeight];if kBuild1x thencall kRemoveString with (kProtMeta.protoTextList, [	"isShapeList", "useScrollers", "selectedItems", "useMultipleSelections", "ScrollAmounts"]);// ==========kProtMeta.protoExpandoShell := [protMeta:	kProtMeta.clView,	//viewFlags: 2561	{item: "viewLineSpacing",		value: 20}, 	iChild, 	iDraw,	iSForm,	iQuit,	iClick,	iKeyD,	{item: "CloseEdit",				value: kScriptArgs, args: kArgView},	//declareSelf: expando	{item: "editHeight",			value: 46},	{item: "editWidth"},			// 220	{item: "empty"},				// "--"	{item: "firstLine"},			// 0	{item: "indent"},				// 100	{item: "labelStyle",			value: "@100"},	{item: "lineHeight"},			// 16	{item: "lines",					value: kEArray},	{item: "numLines",				value: 0},	{item: "target"},				// NIL	{item: "textStyle"},			// 12291	{item: "writeProtected"},		// NIL// ?? ExpandKeys, ExpandNone, ExpandLine, viewHandleAddscript, SetLine];kSlotMeta.textStyle := kSlotMeta.labelStyle := kSlotMeta.viewFont;// ==========if kBuild20 thenkProtMeta.protoPasswordSlip := [protMeta:	kProtMeta.protoFloater,	//viewJustify: 80	iSDone,	//iSForm,	//protoDragger	//declareSelf: base	{item: "MatchedPassword",		value: kInherited0},	{item: "setPassword",			value: kScriptArgs, args: "pwd"},	{item: "verifyPassword"},	// TRUE// ?? MatchPassword, CurrentPassword, ];// ==========if kBuild20 thenkProtMeta.protoSendButton := kProtMeta.protoPopupButton; /*[protMeta:	kProtMeta.protoPopupButton,	//viewJustify: 8407046, 	//iSForm,	//iDraw,	//iBut,	//iPickA,    //text: "Send",// ?? PadText, PrepareForSubmission, SubmitIt];*/// ==========if kBuild20 thenkProtMeta.protoTouchTonePad := [protMeta:	kProtMeta.protoKeypad,	//{item: "viewBounds",	value: "RelBounds(0,0,75,100)"},	{item: "keyPressScript", 	value: kInheritedArg},];// ==========if kBuild20 thenkProtMeta.protoTitleText := kProtMeta.protoStatusText; /*[protMeta:	kProtMeta.protoStatusText,	//{item: "viewBounds",	value: "SetBounds(10,6,180,31)"},	//viewJustify: 8192	//viewFont: 9216	//name: titleText];*/// ==========if kBuild20 thenkProtMeta.protoNameRefDataDef := [protMeta:	NIL,	//pickActionScript: <function, 3 arg(s) #456C15>, 	//pickCancelledScript: <function, 2 arg(s) #456AD5>, 	{item: "class"},			//nameRef	{item: "columns",			value: kEArray},	{item: "name"},				//"List"	{item: "entryType"},		// NIL	{item: "MakeNameRef",		value: kInheritedArgs, args: "obj,dataClass"},	{item: "New",				value: kInheritedArgs, args: "tapInfo,context"},	{item: "OpenEditor",		value: kInheritedArgs, args: "tapInfo,context,why"},	{item: "query"},			//value: kNil},	{item: "singleSelect"},		//NIL	{item: "soupToQuery",		value: kEString},	{item: "Validate",			value: kInheritedArgs, args: "nameRef,paths"},	{item: "validationFrame"},	//NIL// ?? DefaultOpenEditor, Get, MakeCanonicalNameRef, MakePopup, NewEntry// PopVal, NewEntry, GetPrimaryPath, ModifyEntry, GetSuffix, Equivalent// FixupPostAdd, PrepareToAdd, HitItem, GetObjSlot, defaultNewDone, defaultEditDone];// ==========if kBuild20 thenkProtMeta.protoPeopleDataDef := [protMeta:	kProtMeta.protoNameRefDataDef,	//class: |nameRef.people|	//entryType: person	{item: "Equivalent",			value: kInheritedArgs,	args: "nameRef1,nameRef2,paths"},	{item: "GetItemRoutingFrame",	value: kInheritedArgs,	args: kArgItem},	//GetRoutingInfo(object)	//GetRoutingTitle(objects, width, font)	//name: "Names"	{item: "primaryPath"},			// name	{item: "primaryPathMapper"},	//value: kNil},	//soupToQuery];// ==========if kBuild20 thenkProtMeta.protoStatusIcon := [protMeta:	kProtMeta.clPictureView,	//viewFlags: 1, 	//viewFormat: NIL, 	iSForm,    //icon: NIL, 	{item: "name"},	//icon, // ?? viewUpdateFormScript];// ==========if kBuild20 thenkProtMeta.protoWordInfo := kEMeta; /*[protMeta:	NIL,	//id: -1,     //start: 0, 	//stop: 0, 	//flags: 0, 	//unitID: NIL, 	//words: NIL, 	//strokes: NIL, 	//ink: NIL, 	//unitData: NIL// ?? SetWords, GetWords, AutoAdd, AutoRemove// Learn, TestFlags, SetFlags, ClearFlags,// AddCapitalized, RemoveAddedEntries, MoveFirst];*/// ==========if kBuild20 thenkProtMeta.protoWordInterp := kEMeta; /*[protMeta:	NIL,	//word: NIL,	//score: 0,	//label: -1,	//index: -1];*/// ==========if kBuild20 thenkProtMeta.protoStatusProgress := [protMeta:	kProtMeta.clView,	//viewFlags: 3	//viewJustify: 8208	//viewFormat: 0	iSForm,	iDraw,	{item: "name"},					// progress, // ?? viewUpdateFormScript];// ==========if kBuild20 thenkProtMeta.protoStatusBarber := [protMeta:	kProtMeta.clView,	//viewFlags: 3	//viewJustify: 8208	//viewFormat: 0	iSDone,	iDraw,	{item: "name"},					// barber, // ?? viewUpdateFormScript];// ==========// @465 defined/doc??if kBuild20 thenkProtMeta.protoListView := kEMeta; /*[protMeta:	NIL,];*/// ==========// where doc??if kBuild20 thenkProtMeta.protoPhonePad := [protMeta:	kProtMeta.clView,	//viewFlags: 1];// ==========// where doc??if kBuild20 thenkProtMeta.protoFormatPicker := kProtMeta.protoLabelPicker; /*[protMeta:	kProtMeta.protoLabelPicker,	??];*/// ==========// obsolete?if kBuild20 thenkProtMeta.protoNumberPicker := [protMeta:	kProtMeta.clView,	//viewFlags: 1	//viewFormat: NIL	iChange,	iSDone,	//declareSelf: digitBase	{item: "minValue",	value: 0},	{item: "maxValue",	value: 0},	{item: "showLeadingZeros"},		// NIL	{item: "value",	value: 0},];// ==========if kBuild20 thenkProtMeta.protoDigitalClock := [protMeta:	kProtMeta.clView,	//viewFlags: 513	{item: "increment"},	// 1	{item: "midnite"},		// NIL	{item: "time",			value: 0},	{item: "TimeChanged",	value: kScript0},	{item: "wrapping"},		// TRUE// ?? Refresh, Update, Advance];// ==========if kBuild20 thenkProtMeta.protoAMPMCluster := [protMeta:	kProtMeta.protoRadioCluster,	iSForm,	{item: "ClusterChanged",	value: kInherited0}, //?	{item: "time",				value: 0},];// ==========if kBuild20 thenkProtMeta.protoThumbNail := [protMeta:	kProtMeta.clView,	//viewFlags: 545	//viewFormat: 336	//viewJustify: 246	iSDone,	iDraw,	iGest,	iClick,	{item: "DoneScrolling",			value: kScript0},	{item: "GetScalingInfo",		value: kScript0},	{item: "Image"},				//value: kNil},	{item: "ImageTarget"},			//value: kNil},	{item: "trackWhileScrolling"},	//TRUE// ?? RelocateGreyBox, ToggleThumbnail, OpenThumbnail, setup, Update];// ==========if kBuild20 thenkProtMeta.protoImageView := [protMeta:	kProtMeta.clView,	//viewFormat: 2	//viewFlags: 545	//viewJustify: 240	iSDone,	{item: "Annotations"},			//value: kNil},	//declareSelf: imagebase	{item: "dragCorridor"},			// 14	{item: "scalingInfo"},			//value: kNil},	{item: "ScalingInfoChanged",	value: kScriptArgs,	args: "slot"},	{item: "Setup",					value: kScriptArgs,	args: "img,annots,scaleInfo"},	{item: "TargetChanged",			value: kScript0},	{item: "zoomStops"},			//NIL// ?? CanScroll, CanZoomBy, GetAnnotationMode, GetAnnotations, GetScalingInfo// HasAnnotations, OpenImage, PenDown, ScrollBy, ScrollTo, SetAnnotationMode,// ToggleImage, ZoomBy, ZoomTo, ZoomToBox???// CalculateUsefulSizes, DoUndo, SetAcceleration, SetupSizes, SetupZoomStops, ZoomByDest];// ==========if kBuild20 thenkProtMeta.protoTransport := [protMeta:	NIL,	//viewFlags: 0	{item: "actionTitle"},		//"Send"	{item: "addressingClass"},	// |nameRef.email|	{item: "addressSymbols",	value: kEArray},	{item: "allowBodyCursors"},	//value: kNil},	{item: "AppClosed",			value: kScriptArgs,	args: "senderSym"},	{item: "AppInFront",		value: kScriptArgs, args: "inFront,senderSym"},	{item: "AppOpened",			value: kScriptArgs,	args: "senderSym"},	{item: "appSymbol"},		//NIL	{item: "CancelRequest",		value: kScriptArgs, args: "why"},	{item: "CanPutAway",		value: kScriptArgs, args: kArgItem},	{item: "ConnectionDetect",	value: kScript0},	{item: "dataTypes"},		// [frame]	{item: "defaultConfiguration"},	//{autoStatus: TRUE}	{item: "dialogStatusMsgs"},	//value: kNil}, a frame	{item: "GetFromText",		value: kScriptArgs, args: kArgItem},	{item: "GetTransportScripts",	value: kScriptArgs, args: kArgTarget},	{item: "group"},			//value: kNil},	//'print,'fax,'mail,'beam	{item: "groupIcon"},		//value: kNil},	{item: "groupTitle"},		//value: kNil},	{item: "icon",				value: kNil},	{item: "InstallScript",		value: kInheritedArgs, args: kArgSym},	{item: "IOBoxExtensions",	value: kInheritedArgs, args: "item,target,viewDefs,reserved"},	{item: "ItemDeleted",		value: kScriptArgs, args: kArgItem},	{item: "ItemDuplicated",	value: kScriptArgs, args: kArgItem},	{item: "ItemPutAway",		value: kScriptArgs, args: kArgItem},	{item: "itemStateMsgs"},	//value: kNil}, a frame	{item: "MakeLogEntry",		value: kScriptArgs, args: "logItem,item"},	{item: "MissingTarget",		value: kScriptArgs, args: "reserved"},	{item: "modalStatus"},		//NIL	{item: "NewItem",			value: kInheritedArgs, args: "context"},	{item: "PowerOffCheck",		value: kScriptArgs, args: "why"},	{item: "preferencesForm",	value: "protoTransportPrefs"},	{item: "ReceiveRequest",	value: kScriptArgs, args: "request"},	{item: "routingSlip",		value: "protoFullRouteSlip"},	{item: "SendRequest",		value: kScriptArgs, args: "request"},	//{item: "status"},			//idle	{item: "statusTemplate",	value: "protoStatusTemplate"},	{item: "title"},			//"Transport"	{item: "TranslateError",	value: kInheritedArgs, args: "err"},	{item: "transportInfoForm",	value: "protoTransportHeader"},	{item: "VerifyRoutingInfo",	value: kScriptArgs, args: "item,multiItem,entry,fmt"},// ?? CheckOutBox, CloseStatusDialog,// GetConfig, GetDefaultOwnerStore, GetFolderName, GetItemInfo, // GetItemStateString, GetItemTime, GetItemTitle, GetItemType,// GetNameText, GetStatusString, GetTitleInfoShape, GetToText?,// HandleError, HandleThrow, ignoreError, IsInItem, IsLogItem,// ItemCompleted, ItemRequest, NewFromItem, NormalizeAddress// QueueRequest, SetConfig, SetStatusDialog// BeginIO, CancelStatusNotify, CheckOutBoxSilently,// deleteItem, DeleteRemoteItems, DeleteRequest,// EndIO, itemchanged, ItemCommit, ItemCount, ItemSubmit, RefreshOwner, ResurrectStatusDialog// SetStatus, StatusNotify// UpdateItem, UpdateStatusDialog, UpdateStatusSlots// ];// ==========if kBuild20 thenkProtMeta.protoFullRouteSlip := [protMeta:	kProtMeta.protoFloater,	//viewEffect: 77661184	//viewFormat: 16	//iSForm,	iSDone,	iQuit,	iDraw,	{item: "viewHideScript",		value: kInherited0},	{item: "bottomIndent"},			// 29	//declareSelf: base	{item: "envelopeHeight"},		// 115	{item: "envelopeWidth"},		// 230	{item: "FormatChanged",			value: kScriptArgs, args: "fmt"},	{item: "OwnerInfoChanged",		value: kScript0},	{item: "PrepareToSend",			value: kScriptArgs, args: "when"},	{item: "TransportChanged",		value: kScriptArgs, args: kArgAppSym},// ?? BottomOfSlip, ContinueSend// AnimateIndent, AnimateSend, auxSetup, SetFieldDefaults, SetupBounds, SlipClosed, ToRefCheck];// ==========kProtMeta.protoEndpoint := [protMeta:	NIL,	{item: "configOptions",			value: kEArray},	{item: "ExceptionHandler",		value: kScriptArgs, args: "exc"},// disconnect, getOptions, output, listen, setOptions, connect, dispose, instantiate// disposeLeavingTEndpoint, hack_getOptions, runModemNavigator, hack_listen// hack_output, instantiateFromTEndpoint, readyForOutput, hack_readyForOutput// is120Lindy, hack_setOptions, disposeGlue, hack_connect, makeGlue, hack_instantiate];// ==========if kBuild20 thenkProtMeta.protoBasicEndpoint := [protMeta:	NIL,	{item: "encoding", 				value: 1},	//kMacRomanEncoding	{item: "EventHandler",			value: kScriptArgs, args: "event"},	LFetch(kProtMeta.protoEndpoint,"ExceptionHandler",1,'|str=|,'item),//Accept(options, acceptCallback)//Bind(options, bindCallback)//Cancel(cancelCallback)//Connect(options, connectCallback)//Disconnect(cancelPending, disconnectCallback)//Dispose()//FlushInput()//FlushPartial()//Input()//Instantiate(endpoint, options)//Listen(options, listenCallback)//Option(options, optionCallback)//Output(data, options, outputSpec)//Partial()//SetInputSpec(inputSpec)//State()//UnBind(unbindCallback)// disposeLeavingTEndpoint, disposeLeavingTool, instantiateFromTEndpoint, // requestsPending, SetState, ];// ==========if kBuild20 thenkProtMeta.protoStreamingEndpoint := kProtMeta.protoBasicEndpoint; /*[protMeta:	kProtMeta.protoBasicEndpoint,//StreamIn(streamSpec)//StreamOut(data, streamSpec)];*/// ==========if kBuild20 thenkProtMeta.protoSoundChannel := kEMeta; /*[protMeta:	NIL,//Close()//IsActive()//IsPaused()//Open()//Pause()//Schedule(soundFrameRef)//Start(async)//Stop()// getInputGain, GetVolume, IsOpen, newInputBlock, newRecording, SetInputGain, SetVolume];*/// ==========if kBuild20 thenkProtMeta.protoSoundFrame := [protMeta:	NIL,	//{item: "bufferCount",		value: 0},	// codec only	//{item: "bufferSize",		value: 0},	// codec only	{item: "Callback",			value: kScriptArgs, args: "state,result"},	//{item: "codecName",		value: kEString},	// codec only	{item: "compressionRatio",	value: 0},	{item: "compressionType"},	// 0	{item: "count"},			// NIL	{item: "dataType"},			// 8	{item: "loops"},			// NIL	{item: "samples"},			// NIL	{item: "samplingRate"},		// 22026.4	{item: "sndFrameType"},		//simpleSound	{item: "start"},			// NIL	{item: "volume"},			// NIL//GetPlayingTime()//GetSampleCount()//GetSampleSize()//GetSamplingRate()//SetRecordingLength(numSamples, Callback)// SetRecordingLengthNow, DeferredSetLength];// ==========if kBuild20 thenkProtMeta.protoRecorderView := [protMeta:	kProtMeta.clView,	//viewFlags: 3, 	//viewFormat: 1, 	//viewJustify: 0, 	//viewBounds: {left: 0, top: 0, right: 191, bottom: 23}, 	//viewEffect: 165920, 	iQuit,	iDraw,	iChange,	iSDone,	//declareSelf: base	//elapsedTime: 0 ?	{item: "statusText",	value: "{SetState: func(oldState,newState,hasSound)\nbegin\nend}"},//GetSounds()// FlushVBO, isActive, play, stop, UpdateSlider, ];// ==========if kBuild20 thenkProtMeta.protoTXViewFinder := kEMeta; /*[protMeta:	NIL,//FindString(object, str, startOffset, options)//GetCountCharacters()//GetRangeText(range)];*/// ==========if kBuild20 thenkProtMeta.protoTXView := [protMeta:	kProtMeta.clView,//ChangeRangeRulers(range, ruler, undoable)//ChangeRangeRuns(range, fontSpec, toggleFace, undoable)//Clear()//Copy()//Cut()//Externalize()//FindString(str, startOffset, options)//GetContinuousRun()//GetCountCharacters()//GetCountPages()//GetHiliteRange()//GetLineRange(offset)//GetRangeData(range, which)//GetScrollableRect()//GetScrollValues()//GetTotalHeight()//GetTotalWidth()//GetWordRange(offset)//HideRuler()//InsertPageBreak(range)//Internalize(object)//IsModified()//IsRulerShown()//Paste()//Replace(range, data, undoable)//ReplaceAll(str, startOffset, options, data)//PointToChar(point)//Scroll(scrollValues)//SetDrawOrigin(origin)//SetGeometry(isPaged, width, height, margins)//SetHiliteRange(newRange, showHilite, setKeyView)//SetStore(store)//ShowRuler(rulerSettings)//UpdateRulerInfo(rulerSettings)//ViewUpdateScrollersScript(updateMaxVal, scrolled)// CharToPoint, GetParagraphRange, SetReadOnly];// ==========/*should crosscheck that all viewMeta and protMeta stuffare in slotMeta???  just do removes once (here)??make sure all protos are represented?GetDateStringSpec field*/