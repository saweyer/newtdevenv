// Text of project NewtDraw20.¹ written on 2/11/97 at 10:04 AM// Beginning of text file Project Data// Newt Controls & Newt Drawing (autopart) 3.4// Copyright 1995-96. S. Weyer. All Rights Reserved Worldwideconstant kAutoCnst 		:= "NewtDraw";constant kVersionNum 	:= "3.4";constant kBetaVersion	:= "a";if not IsGlobalConstant('kBuild20)then DefineGlobalConstant('kBuild20,	platformVersion.platformFile = '|Newton 2.0| or	platformVersion.platformFile = '|MessagePad2.1|);	// ???if not IsGlobalConstant('kBuild1x)then DefineGlobalConstant('kBuild1x, not kBuild20);DefineGlobalConstant('kVersionString,	kVersionNum & kBetaVersion &	(if kDebugOn then "D") &	(if kProfileOn then "P") &	(if not kIgnoreNativeKeyword then "N") &	(if kBuild20 then "-2"));DefineGlobalConstant ('kVersion, kAutoCnst && kVersionString);Print(kVersion && DateNTime(time()));DeclareGlobalFn('DeclareGlobalFn,2);if kBuild1xthen begin	DeclareGlobalFn('GetGlobalVar,1);	DeclareGlobalFn('DefGlobalVar,2);	end;// GLOBAL functions/*DefineGlobalConstant('MyRoundTo,func(val,grid) // used in drawView:viewGestureScriptif grid then RIntToL(val/grid)*grid else val);*/DefineGlobalConstant('PerformVals,func(f,msg,aparams) // iterate over list of paramsbegin // e.g., :PerformVals(self,'removeNewt,clone(all_Newts))   local val;   foreach val in aparams   do Perform(f,msg,if isArray(val) then val else [val]);end);constant eString := ""; // an empty string (readonly)constant eArray := '[]; // an empty array  (readonly)constant slotErr    := "existing slot";constant subLeft    :=  4;  // left offset of Edit,Print,Aboutconstant subTop     := 18;  // top offset of Edit,Print,Aboutconstant subRight   := -4;  // right offset of Edit,Print,Aboutconstant subBottom  := -4;  // bottom offset of Edit,Printconstant kDragRadius := 5;constant delayMsecs := 10;constant kNewtControlTitle := "Newt Controls";constant kNewtDrawTitle := "Newt Drawing";constant kTimes     := "Times";constant kDist      := "Dist";constant kDeg       := "Deg";constant radiansPerDegree := 0.01745329252 ;  // 3.14159265359/180.0constant noteLeft :=    10;constant newtTop :=     34;            // noteTop+evalHeight+noteTopconstant noteWidth :=  226;constant newtHeight := 230;            // height of Newt drawing areaconstant newtBeep :=  ROM_hilitesound;constant poofSound := ROM_poof;constant newtRadius :=   10;constant newtArc2 :=     90;    // 2*45.  45 is half of arcconstant newt180_Arc := 135;    // 180-45constant distGrid :=     10;    // for line gestureconstant degGrid :=      45;constant kNewtSymbol 	:= '|NewtDevEnv:TKnollSys|;constant kPlugType		:= 'tools;constant kControlSym	:= 'newtControls;constant kDrawingSym	:= 'newtDrawing;constant kInstalled		:= 'installed;DefineGlobalConstant('kPkgSymbol,	Intern(kPackageName)); // kAppSymbol='autoPrint(kPkgSymbol);InstallScript := func(partFrame,removeFrame)begin	local gData :=		if kBuild1x and Functions.GetGlobals exists		then GetGlobals().(kNewtSymbol)		else GetGlobalVar(kNewtSymbol);	if gData	then begin		if not gData.installed // for compat if older plugins installed		then gData.(EnsureInternal(kInstalled)) := EnsureInternal({});		end	else begin		gData := EnsureInternal(				{constants: {}, libraries: {}, protos: {},				tools: {}, views: {}, installed: {}, });		if kBuild1x and Functions.GetGlobals exists		then GetGlobals().(EnsureInternal(kNewtSymbol)) := gData		else DefGlobalVar(EnsureInternal(kNewtSymbol), gData);		end;	gData.(kInstalled).(EnsureInternal(kPkgSymbol))	:= kVersion;	gData.(kPlugType).(EnsureInternal(kControlSym)) := partFrame.partData.(kControlSym);	gData.(kPlugType).(EnsureInternal(kDrawingSym)) := partFrame.partData.(kDrawingSym);end;RemoveScript := func(removeFrame)begin	local gData :=		if kBuild1x and Functions.GetGlobals exists		then GetGlobals().(kNewtSymbol)		else GetGlobalVar(kNewtSymbol);	RemoveSlot(gData.(kInstalled),  	kPkgSymbol);	RemoveSlot(gData.(kPlugType), 	kControlSym);	RemoveSlot(gData.(kPlugType), 	kDrawingSym);end;partData := {};// End of text file Project Data// Beginning of file EmptyLayout_view000 :=    {viewBounds: {left: 40, top: 24, right: 192, bottom: 120},     viewFlags: 1,     viewFormat: nil,     viewClass: 74    };constant |layout_EmptyLayout| := _view000;// End of file EmptyLayout// Beginning of file newtButtonProto_userproto000 :=    {     buttonClickScript:       func()       begin       	if copy // for Times       	then SetValue(evalField,'text,clone(expr));       	newtView:readEvalPrint(expr);       end,     viewBounds: {left: 26, top: 18, right: 56, bottom: 28},     copy: nil,     _proto: @226    };// After Script for "_userproto000"thisView := _userproto000;thisView.viewBounds := NILconstant |layout_newtButtonProto| := _userproto000;// End of file newtButtonProto// Beginning of file newtCheckProto_userproto001 :=    {viewBounds: {left: 24, top: 16, right: 112, bottom: 32},     valueChanged: func() :setPreferenceI(newtMsg,setVar,viewValue),     viewSetupFormScript: func() viewValue := GetVariable(self,newtVar),     setVar: nil,     _proto: @164    };// After Script for "_userproto001"thisView := _userproto001;thisView.viewBounds := NILconstant |layout_newtCheckProto| := _userproto001;// End of file newtCheckProto// Beginning of file newtFloatProto_userproto002 :=    {viewBounds: {left: -16, top: 22, right: 132, bottom: 98},     viewFormat: 83952385,     viewSetupFormScript:       func()       begin       	self.growView := self;       	local vb := newtView.viewBounds;       	if adjustBottom       	then self.viewBounds :=       		//call knewBounds with(newtView,subLeft,subTop,subRight,adjustBottom,nil,nil);       	RelBounds(       		subLeft,       		subTop,              		if subRight>0       		then subRight-subLeft       		else vb.right+subRight-vb.left-subLeft,              		if adjustBottom>0       		then adjustBottom-subTop       		else vb.bottom+adjustBottom-vb.top-subTop             );       end,     viewJustify: 0,     adjustBottom: nil,     viewOverviewScript: func() newtView:viewOverviewScript(),     viewClickScript:       func(unit) // 1.x       //:changeBounds(unit,TRUE));       self=growView       and ABS(GetPoint(firstY, unit) - :GlobalBox().top) <= kDragRadius       and ABS(GetPoint(firstX, unit) - :GlobalBox().left - ((viewBounds.right - viewBounds.left) div 2)) <= kDragRadius       and :Drag(unit, nil)   // returns TRUE       ,     viewDrawScript:       func()       begin       	constant y := -1;       	local INT x := (viewBounds.right - viewBounds.left) div 2;       	:DrawShape(       		MakeOval(       			x-kDragRadius, y-kDragRadius,	// left,top,       			x+kDragRadius, y+kDragRadius),	// right,bottom       			{transferMode: modeCopy,       			fillPattern: vfFillWhite,       			penSize: 2,       			});       end,     viewFlags: 576,     _proto: @180    };// After Script for "_userproto002"thisView := _userproto002;begin//thisView.viewBounds := NIL;RemoveSlot(thisView,'viewBounds);// when growing implemented, change to :changeBounds(unit,NIL) ???if kBuild20then begin	thisView._proto := protoDragNGo;	RemoveSlot(thisView, 'viewClickScript);	RemoveSlot(thisView, 'viewDrawScript);	RemoveSlot(thisView, 'viewFlags);	thisView.viewFormat := Bor(thisView.viewFormat, 208); //vfFrameDragger);	endelse begin	thisView.viewFormat := Bor(thisView.viewFormat, vfFrameMatte);	end;endconstant |layout_newtFloatProto| := _userproto002;// End of file newtFloatProto// Beginning of file newtInputProto_userproto003 :=    {viewBounds: {left: 16, top: 16, right: 168, bottom: 40},     viewFlags: 11009,     viewLineSpacing: 18,     viewChangedScript:       func(slot,view)       begin       	local val, ival;       	if slot='text       	then newtDrawing.(var) :=       		if val := StringToNumber(text)       		then if val = (ival := RIntToL(val)) or var='times               	then ival // return integer if necessary or possible       			else val       		else 0;       end,     viewSetupFormScript:       func()       begin          self.text := NumberStr(newtDrawing.(var));          inherited:viewSetupFormScript();       end,     textFlags: vNoSpaces,     _proto: @185    };// After Script for "_userproto003"thisView := _userproto003;thisView.viewBounds := NILconstant |layout_newtInputProto| := _userproto003;// End of file newtInputProto// Beginning of file newtPickerProto_userproto004 :=    {viewBounds: {left: 33, top: 17, right: 143, bottom: 39},     textSetup: func() labelCommands[GetVariable(self,newtVar)],     labelActionScript: func(cmd) :setPreferenceI(newtMsg,nil,cmd),     _proto: @190    };// After Script for "_userproto004"thisView := _userproto004;thisView.viewBounds := NILconstant |layout_newtPickerProto| := _userproto004;// End of file newtPickerProto// Beginning of file NewtControlsProtocontrolFloat :=    {viewBounds: {left: 4, top: 18, right: 236, bottom: 70},     title: kNewtControlTitle,     _proto: _userproto002    };refreshCheck :=    {text: "Refresh?",     viewBounds: {left: 158, top: 39, right: 212, bottom: 51},     newtMsg: 'refresh     ,     newtVar: 't_refresh,     _proto: _userproto001    };AddStepForm(controlFloat, refreshCheck);timesButton :=    {text: "Times",     viewBounds: {left: 2, top: 9, right: 32, bottom: 19},     expr: "local i; for i:=1 to times do begin :go(dist); :turn(deg); end",     copy: true,     _proto: _userproto000    };AddStepForm(controlFloat, timesButton);// After Script for "timesButton"thisView := timesButton;thisView.text := kTimestimesField :=    {viewBounds: {left: 36, top: 3, right: 76, bottom: 21},     var: 'times,     _proto: _userproto003    };AddStepForm(controlFloat, timesField);distButton :=    {text: "Dist",     viewBounds: {left: 80, top: 9, right: 110, bottom: 19},     expr: ":go(dist)",     _proto: _userproto000    };AddStepForm(controlFloat, distButton);// After Script for "distButton"thisView := distButton;thisView.text := kDistdistField :=    {viewBounds: {left: 114, top: 3, right: 154, bottom: 21},     var: 'dist,     _proto: _userproto003    };AddStepForm(controlFloat, distField);turnButton :=    {text: "Deg",     viewBounds: {left: 158, top: 9, right: 188, bottom: 19},     expr: ":turn(deg)"     ,     _proto: _userproto000    };AddStepForm(controlFloat, turnButton);// After Script for "turnButton"thisView := turnButton;thisView.text := kDegturnField :=    {viewBounds: {left: 192, top: 3, right: 232, bottom: 21},     var: 'deg,     _proto: _userproto003    };AddStepForm(controlFloat, turnField);eraseButton :=    {text: "Erase",     viewBounds: {left: 2, top: 25, right: 32, bottom: 35},     expr: ":erase()",     _proto: _userproto000    };AddStepForm(controlFloat, eraseButton);homeButton :=    {text: "Home",     viewBounds: {left: 2, top: 41, right: 32, bottom: 51},     expr: ":home()",     _proto: _userproto000    };AddStepForm(controlFloat, homeButton);penPicker :=    {viewBounds: {left: 37, top: 25, right: 82, bottom: 38},     labelCommands: ["0", "1", "2", "3", "4"],     text: "Pen",     newtVar: 't_pen,     newtMsg: 'pen,     _proto: _userproto004    };AddStepForm(controlFloat, penPicker);colorPicker :=    {viewBounds: {left: 86, top: 25, right: 174, bottom: 38},     labelCommands: ["none", "white", "ltGray", "gray", "dkGray","black"],     text: "Color",     newtMsg: 'color,     newtVar: 't_color,     _proto: _userproto004    };AddStepForm(controlFloat, colorPicker);newtCheck :=    {text: "Newt?",     viewBounds: {left: 178, top: 25, right: 226, bottom: 37},     newtMsg: 'visible     ,     newtVar: 't_visible,     _proto: _userproto001    };AddStepForm(controlFloat, newtCheck);controlTitle :=    {text: "",     viewBounds: {left: 0, top: -11, right: 85, bottom: -1},     viewJustify: 8388752,     _proto: @218    };AddStepForm(controlFloat, controlTitle);// After Script for "controlTitle"thisView := controlTitle;thisView.text := kNewtControlTitle// After Script for "controlFloat"thisView := controlFloat;beginif kBuild1xthen ArrayRemoveCount(thisView.stepChildren,0,1); // refreshCheckpartData.(kControlSym):= thisView;endconstant |layout_NewtControlsProto| := controlFloat;// End of file NewtControlsProto// Beginning of file NewtDrawingProtonewtFloat :=    {     goPt_1:       func(dx,dy,newpen) // :go, :goPt, :move, :movePt (&poly2,cCurve)       if (dy<>0 or dx<>0) and :PerformNewts('goPt_1,[dx,dy,newpen],nil)       then if t_angle=0   // common cases to avoid sin/cos           then :goPt_view(t_x + dx, t_y - dy, newpen)          else if t_angle=90          then :goPt_view(t_x + dy, t_y + dx, newpen)          else if t_angle=180          then :goPt_view(t_x - dx, t_y + dy, newpen)          else if t_angle=270          then :goPt_view(t_x - dy, t_y - dx, newpen)          else begin       //print(t_angle);             local dist, ang;             if dx = 0 // common cases to avoid atan             then begin                dist := dy; ang := t_angle; // traditional 'go'                end             else if dy=0             then begin                dist := dx;       			ang := if t_angle>=270 then t_angle-270 else t_angle+90;                end             else begin                dist := hypot(dx,dy);                ang := atan(dy/dx)/radiansPerDegree; // compute, then adjust for quadrant                ang := Remainder(t_angle + (if dx>0 then 90-ang else 270-ang),360);                if ang < 0 then ang := 360+ang;                end;             radians := ang * radiansPerDegree;             dx := dist * sin (radians);             dy := dist * cos (radians);             :goPt_view(t_x + dx, t_y - dy, newpen);             end,     goPt: func(dx,dy) :goPt_1(dx,dy,nil),     removenewt:       func(sym)       if isArray(sym)       then call PerformVals with(self,'removeNewt,clone(sym))       else begin //if call kremoveListItem with(newtDrawing,'all_Newts,sym)          local list := newtDrawing.all_Newts, val;          if list and SetContains(list,sym) and HasSlot(newtDrawing,sym)          then begin             val := newtDrawing.(sym);             RemoveSlot(newtDrawing,sym);             SetRemove(list,sym);             if length(list)=0 then newtDrawing.all_Newts := NIL;             :dirty()             end;       	end,     viewSetupDoneScript:       func()       if not t_rect // to avoid reinit ??       then begin          local lbox := :localBox();          self.t_rect := MakeShape(lbox); // for HitShape bounds testing in drawNewt       // for simplicity, width & height should be even          self.t_x := self.org_x := self.center_x := lbox.right/2;          self.t_y := self.org_y := self.center_y := lbox.bottom/2;          self.t_angle := 0;          self.all_points := []; self.all_pens := []; // :eraseNewt except may not be visible yet          self.points := self.t_newt := self.fpen := self.xornewt := nil; // ***          // let :viewDrawScript show Newt       end,     turnTo:       func(angle)  // keep 0<=t_angle<360. angle may be float       if :PerformNewts('turnTo,[angle],nil)       	and angle <> t_angle       then begin       	angle := Remainder(angle,360); //angle mod 360;       	t_angle := if angle<0 then 360+angle else angle;       	if t_newt       	then :DoDrawing('drawNewtClip, '[prev,true,nil]); // !!!c       	end,     Visible:       func(vis)       begin       	if :PerformNewts('visible,[vis],nil)       		and vis <> t_visible       		and (t_newt or vis)       	then :DoDrawing('drawNewtClip, [vis,nil,nil]); // !!!c       	t_visible := vis;       end,     drawNewtClip:       func(vis,hit,line) // !!!c elim. doDraw arg & recursive call       begin // inside of :viewDrawScript or :doDrawing       	if t_newt // erase old Newt       	then begin       		:drawShape(t_newt,xornewt);       		if vis = 'prev       		then vis := true;       		t_newt := nil; // avoid re-xoring       		end       	else if vis = 'prev       	then vis := nil;              	if line       	then :drawShape(line, fpen); // fpen set in :goPt_view              	if vis       	then begin       		local INT rad := newtRadius+(t_pen*2), itx := RIntToL(t_x), ity:=RIntToL(t_y);       		if hit or // don't need to test for pen/turnTo       			HitShape(t_rect, itx, ity)       		then :drawShape(t_newt :=       				MakeWedge(       					itx-rad,ity-rad,       					itx+rad,ity+rad,       					RInttoL(t_angle)+newt180_Arc,       					newtArc2),       				if xornewt then xornewt       				else xornewt := {transferMode: modeXor, fillPattern: t_color}       				);       		end;       end,     pendown: func() :pen(1),     viewgesturescript:       func(unit, gestureID)       if newtView:viewIsOpen(newtDrawing) // otherwise, this seems to run when it shouldn't, e.g, double-tap in an app's input field?       then begin          local gb := :GlobalBox(), newt := newtDrawing, dx, dy;          local x1 := GetPoint(firstX,unit)-gb.left;          local y1 := GetPoint(firstY,unit)-gb.top;          local x2 := GetPoint(finalX,unit)-gb.left;          local y2 := GetPoint(finalY,unit)-gb.top;          if all_Newts          then begin // find closest newt             local newtsym, anewt, dist2, dist;             foreach newtsym in all_Newts             do begin                anewt := GetSlot(newtDrawing,newtsym);                dist2 := hypot(anewt.t_x - x1,anewt.t_y - y1);                if not dist or dist2 < dist                then begin                   newt := anewt; dist := dist2;                   end;                end;             end;                 if gestureID=aeTap    // tap (49)          then begin       //if debugon then print(:isdoubleclick());             newt:goPt_view(x1,y1,nil); // view coord, current pen             TRUE;             end                 //else if gestureID=aeDoubleTap // doubletap(50)          //then newt:home()                 else if gestureID=aeHilite  // hilite (treat as drag)          then begin             newt:goPt_view(x2,y2,0); // view coord, pen up             TRUE;             end                 else if gestureID=aeScrub    // scrub (13)          then newt:erase() // returns TRUE from RefreshViews                 // could use aeCaret for turn, but have to look at extra pts                 else if gestureID=aeLine // line (16)          then begin             // coord sys (abs vs. rel) doesn't matter             dx := x2 - x1;             dy := y1 - y2; //flip             local newang := if dx=0                             then if dy>0 then 0 else 180                             else //call MyRoundTo with (atan(dy/dx)/radiansPerDegree,degGrid,'RIntToL);       								RIntToL(Atan(dy/dx)/radiansPerDegree/degGrid)*degGrid;             if dx>0    // adjust for quadrant             then newang := 90 - newang             else if dx<0             then newang := (270 - newang) mod 360;             // either turn to that heading, or if already there, go             if newt.t_angle=newang             then newt:goPt_1(0,//call MyRoundTo with (Hypot(dx,dy),distGrid,'RIntToL), nil)       								RIntToL(Hypot(dx,dy)/distGrid)*distGrid, nil)             else newt:turnTo(newang);             TRUE;             end                 //else print(gestureID) // returns NIL       end,     viewDrawScript:       func()       if :PerformNewts('viewDrawScript,eArray,nil)       then begin       	local INT i;       	local ARRAY pts;       	foreach i,pts in all_points       	do :drawShape(MakePolygon(pts), all_pens[i]);       	:drawNewtClip(t_visible, t_newt:=nil, nil);       	inherited:?viewDrawScript();       	end,     Move: func(dist) :goPt_1(0,dist,0),     save_1:       func(notedata)       if length(all_points)>0       then begin          local i, newdata, pts, len, nlen := length(notedata);          SetLength(notedata,nlen+length(all_points));          foreach i,pts in all_points          do begin             len := length(pts);             newdata := Array(len+2,nil);             newdata[0] := 8;  // line?             newdata[1] := len/2;             ArrayMunger(newdata,2,len+2,pts,0,len); // x,y reversed?             notedata[nlen+i] :=               {viewStationery: 'poly,                viewBounds: RelBounds(noteLeft, newtTop, noteWidth, newtHeight),                points: ArrayToPoints(newdata),                viewFormat: all_pens[i].penSize*256,   // vfPen undef                //+all_pens[i].penPattern*16, //??                };             end;       end,     viewFlags: 2596,     save:       func() // save current expression and picture(s) as a Note       begin          local notedata := [];          :PerformNewts('save_1,[notedata],true);                 if length(notedata)>0 // don't save empty drawings          then begin             // add last to minimize interference with method search             local text := clone(evalField.text);             StrReplace(text,kTimes,NumberStr(times),nil);             StrReplace(text,kDist, NumberStr(dist), nil);             StrReplace(text,kDeg,  NumberStr(deg), nil);             :saveNotePara(notedata,text,nil,nil);             end;       end,     penup: func() :pen(0),     t_rect: nil,     pen:       func(val)       begin       	:PerformNewts('pen,[val],nil);       	if val <> t_pen       	then begin       		t_pen := val; points := nil;       		if t_newt       		then :DoDrawing('drawNewtClip, ['prev,val,nil]); // !!!c       		end;       end,     viewIdleScript:       func()       if delayCount > 0       then begin          Perform(evalView,delayMsg,delayParams);          if (delayCount := delayCount-1) > 0          then delayMsecs                      // schedule again!          else evalButton:setMode(true,nil,nil); // returns NIL          end,     turn:       func(angle)       if angle <> 0 and :PerformNewts('turn,[angle],nil)       then :turnTo(t_angle + angle),     dist: 0,     viewBounds: {left: 0, top: 8, right: 224, bottom: 320},     _proto: _userproto002,     setHome:       func(x,y)       if :PerformNewts('setHome,[x,y],nil)       then :goPt_view(org_x := center_x + x, // see :home                       org_y := center_y - y,                       t_angle := 0) // pen=0!       ,     all_pens: nil,     Erase:       func()       begin          :eraseNewt(); // zap Newt stuff for next drawScript          PlaySound(poofSound);                 // from UpInSmoke example          local smokeBounds := newtDrawing:GlobalBox();          local danQuayle := BuildContext(       		{viewClass:clView,             viewFlags: vFloating,       		viewBounds: smokeBounds,       		ReOrientToScreen: @588, //ROM_DefRotateFunc       		});          local bm, top := smokeBounds.top, left := smokeBounds.left;          foreach bm in [ROM_cloud1,ROM_cloud2,ROM_cloud3]          do begin             bm := Clone(bm);             bm.bounds := smokeBounds;             GetRoot():CopyBits(bm,left,top,modeMask);             Sleep(2);             GetRoot():CopyBits(bm,left,top,modeBic);          end;          danQuayle:open(); danQuayle:close();                 //:dirty();          RefreshViews(); // normally only needed from call within prog       end,     goPt_view:       func(newx,newy,curpen) // x,y in view coord. single newt       // use reals for accuracy of location, integer for actual drawing       begin       	local line;       	if (if curpen then curpen else t_pen) > 0       	then begin       		local INT ix1 := RIntToL(t_x),  iy1 := RIntToL(t_y);       		local INT ix2 := RIntToL(newx), iy2 := RIntToL(newy);       		line := MakeLine(ix1,iy1,ix2,iy2);       		if points       		then begin       			AddArraySlot(points,ix2); AddArraySlot(points,iy2);       			end       		else begin       			points := [ix1,iy1,ix2,iy2];       			AddArraySlot(all_points,points);       			fpen := {penSize: t_pen, penPattern: t_color}; // cache for :drawNewtClip       			AddArraySlot(all_pens,fpen);       			end;       		end       	else points := nil;              	t_x := newx; t_y := newy;       	if t_newt or t_visible or line       	then begin       		:DoDrawing('drawNewtClip, [t_visible,nil,line]); // !!!c       		if t_refresh // !!!c       		then RefreshViews();       		end;       end,     viewScrollDownScript: func() nil,     beep: func() PlaySoundSync(newtBeep),     adjustBottom: subBottom,     deg: 0,     HOME:       func()       if :PerformNewts('home,eArray,nil)       then :goPt_view(org_x,org_y,t_angle := 0) // pen=0       ,     times: 0,     title: kNewtDrawTitle,     movePT: func(x,y) :goPt_1(x,y,0),     all_points: nil,     all_newts: nil,     viewScrollUpScript: func() nil,     Refresh: func(fl) t_refresh := fl,     go: func(dist) :goPt_1(0,dist,nil),     color:       func(val)       begin       	:PerformNewts('color,[val],nil);       	if val <> t_color       	then begin       		t_color := val; points := nil;       		if t_newt       		then begin       			if t_newt       			then :DoDrawing('drawNewtClip, '[nil,nil,nil]);	// !!!c erase old newt       			xornewt := nil; // uncache color       			:DoDrawing('drawNewtClip, '[true,true,nil]); // !!!c                end             else xornewt := nil;             end;       end,     addNewt:       func(sym,hx,hy,pen)       if isArray(sym)       then call PerformVals with (self,'addNewt,sym)       else if HasSlot(newtDrawing,sym)       then :error(['addNewt,slotErr], sym)       else begin          newtDrawing:eraseNewt(); // zap current "global" newt, points, etc.          hx := center_x + hx;          hy := center_y - hy;          newtDrawing.(sym) := {             _parent: newtView, // base?             _proto: newtDrawing,             t_visible: t_visible, t_newt: nil,             t_pen: if pen then pen else t_pen,             t_color: t_color, fpen: nil, xornewt: xornewt,             t_angle: 0, org_x: hx, org_y: hy, t_x: hx, t_y: hy,             points: nil, all_points: [], all_pens: [],             };          if all_Newts then AddArraySlot(all_Newts,sym) else all_Newts := [sym];          :dirty();          end,     delay:       func(msg,params,num)       begin          newtDrawing.delayMsg := msg;          newtDrawing.delayParams := params;          evalButton:setMode(NIL,num,delayMsecs);       end,     PerformNewts:       func(msg,params,single) // iterate over list of newts (symbols)       begin          local f;          if not newtView:ViewIsOpen(newtDrawing)          then begin newtDrawing:open(); RefreshViews(); end;                 if all_Newts and (self=evalView or self=newtDrawing) // ***          then foreach f in all_Newts // returns NIL               do Perform(newtDrawing.(f),msg,params)          else if single          then Perform(self,msg,params)          else TRUE;       end,     eraseNewt:       func()       if :PerformNewts('eraseNewt,eArray,nil)       then begin          all_points := []; all_pens := [];          points := t_newt := nil;          end    };_view001 :=    {text: "",     viewBounds: {top: -12, left: 0, right: 80, bottom: -1},     viewJustify: 8388752,     _proto: @218    };AddStepForm(newtFloat, _view001);// After Script for "_view001"thisView := _view001;thisView.text := kNewtDrawTitle// After Script for "newtFloat"thisView := newtFloat;begin	thisView.viewBounds := NIL;	partData.(kDrawingSym) := thisView;endconstant |layout_NewtDrawingProto| := newtFloat;// End of file NewtDrawingProto